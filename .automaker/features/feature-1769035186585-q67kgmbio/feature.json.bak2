{
  "category": "Uncategorized",
  "description": "Optimize Dockerfiles for Layer Caching\n\nRestructure Dockerfile COPY instructions to maximize Docker layer cache efficiency by separating dependency installation from source code changes.\n\nTechnical Implementation:\n- Reorder Dockerfile instructions to copy dependency manifests first (package.json, requirements.txt, go.mod, Gemfile, etc.)\n- Run dependency installation commands (npm install, pip install, go mod download, bundle install)\n- Copy remaining application source code last\n- Ensure .dockerignore excludes build artifacts, node_modules, and development files\n\nPattern to Apply:\n```\n# Before: Cache-busting pattern\nCOPY . /app\nRUN npm install\n\n# After: Cache-optimized pattern\nCOPY package*.json /app/\nRUN npm install\nCOPY . /app/\n```\n\nFiles to Modify:\n- All Dockerfiles in repository (./Dockerfile, services/*/Dockerfile, etc.)\n- Update .dockerignore if missing (exclude node_modules, .git, dist/, build/, __pycache__)\n\nLanguage-Specific Considerations:\n- Node.js: Copy package.json + package-lock.json before npm ci/install\n- Python: Copy requirements.txt/Pipfile before pip install\n- Go: Copy go.mod + go.sum before go mod download\n- Java/Maven: Copy pom.xml before mvn dependency:resolve\n- Ruby: Copy Gemfile + Gemfile.lock before bundle install\n\nAdditional Optimizations:\n- Use multi-stage builds to separate build dependencies from runtime\n- Combine RUN commands to reduce layers where appropriate\n- Consider BuildKit cache mounts for further optimization\n- Add --no-cache flags for production builds in CI/CD\n\nValidation:\n- Test builds with and without cache to verify layer reuse\n- Measure build time improvement (expect 50-90% reduction on cached builds)\n- Ensure application functionality unchanged after restructuring",
  "title": "",
  "images": [],
  "imagePaths": [],
  "textFilePaths": [],
  "skipTests": false,
  "model": "claude-opus",
  "thinkingLevel": "none",
  "reasoningEffort": "none",
  "branchName": "002-legal-ai-core",
  "priority": 2,
  "planningMode": "skip",
  "requirePlanApproval": false,
  "dependencies": [],
  "workMode": "current",
  "titleGenerating": "Optimize Dockerfiles for Layer Caching\n\nRestructure Dockerfile COPY instructions to maximize Docker layer cache efficiency by separating dependency installation from source code changes.\n\nTechnical Implementation:\n- Reorder Dockerfile instructions to copy dependency manifests first (package.json, requirements.txt, go.mod, Gemfile, etc.)\n- Run dependency installation commands (npm install, pip install, go mod download, bundle install)\n- Copy remaining application source code last\n- Ensure .dockerignore excludes build artifacts, node_modules, and development files\n\nPattern to Apply:\n```\n# Before: Cache-busting pattern\nCOPY . /app\nRUN npm install\n\n# After: Cache-optimized pattern\nCOPY package*.json /app/\nRUN npm install\nCOPY . /app/\n```\n\nFiles to Modify:\n- All Dockerfiles in repository (./Dockerfile, services/*/Dockerfile, etc.)\n- Update .dockerignore if missing (exclude node_modules, .git, dist/, build/, __pycache__)\n\nLanguage-Specific Considerations:\n- Node.js: Copy package.json + package-lock.json before npm ci/install\n- Python: Copy requirements.txt/Pipfile before pip install\n- Go: Copy go.mod + go.sum before go mod download\n- Java/Maven: Copy pom.xml before mvn dependency:resolve\n- Ruby: Copy Gemfile + Gemfile.lock before bundle install\n\nAdditional Optimizations:\n- Use multi-stage builds to separate build dependencies from runtime\n- Combine RUN commands to reduce layers where appropriate\n- Consider BuildKit cache mounts for further optimization\n- Add --no-cache flags for production builds in CI/CD\n\nValidation:\n- Test builds with and without cache to verify layer reuse\n- Measure build time improvement (expect 50-90% reduction on cached builds)\n- Ensure application functionality unchanged after restructuring",
  "status": "in_progress",
  "id": "feature-1769035186585-q67kgmbio",
  "descriptionHistory": [
    {
      "description": "Optimize Dockerfiles for Layer Caching\n\nRestructure Dockerfile COPY instructions to maximize Docker layer cache efficiency by separating dependency installation from source code changes.\n\nTechnical Implementation:\n- Reorder Dockerfile instructions to copy dependency manifests first (package.json, requirements.txt, go.mod, Gemfile, etc.)\n- Run dependency installation commands (npm install, pip install, go mod download, bundle install)\n- Copy remaining application source code last\n- Ensure .dockerignore excludes build artifacts, node_modules, and development files\n\nPattern to Apply:\n```\n# Before: Cache-busting pattern\nCOPY . /app\nRUN npm install\n\n# After: Cache-optimized pattern\nCOPY package*.json /app/\nRUN npm install\nCOPY . /app/\n```\n\nFiles to Modify:\n- All Dockerfiles in repository (./Dockerfile, services/*/Dockerfile, etc.)\n- Update .dockerignore if missing (exclude node_modules, .git, dist/, build/, __pycache__)\n\nLanguage-Specific Considerations:\n- Node.js: Copy package.json + package-lock.json before npm ci/install\n- Python: Copy requirements.txt/Pipfile before pip install\n- Go: Copy go.mod + go.sum before go mod download\n- Java/Maven: Copy pom.xml before mvn dependency:resolve\n- Ruby: Copy Gemfile + Gemfile.lock before bundle install\n\nAdditional Optimizations:\n- Use multi-stage builds to separate build dependencies from runtime\n- Combine RUN commands to reduce layers where appropriate\n- Consider BuildKit cache mounts for further optimization\n- Add --no-cache flags for production builds in CI/CD\n\nValidation:\n- Test builds with and without cache to verify layer reuse\n- Measure build time improvement (expect 50-90% reduction on cached builds)\n- Ensure application functionality unchanged after restructuring",
      "timestamp": "2026-01-21T22:39:46.719Z",
      "source": "initial"
    }
  ],
  "startedAt": "2026-01-21T22:39:46.769Z",
  "updatedAt": "2026-01-21T22:39:46.977Z"
}