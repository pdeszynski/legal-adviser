/**
 * Persisted Queries Client Module
 *
 * Provides utilities for using Automatic Persisted Queries (APQ).
 * This module loads the client manifest generated by GraphQL Codegen
 * and provides functions to compute query hashes and use persisted queries.
 *
 * Benefits:
 * - Reduced bandwidth: send query hash instead of full query
 * - Improved security: only pre-registered queries can be executed
 * - Better caching: CDN can cache requests by hash
 */

/**
 * Client manifest format (operation name -> hash)
 */
interface ClientManifest {
  [operationName: string]: string;
}

/**
 * Persisted query extension format
 */
interface PersistedQueryExtension {
  version: 1;
  sha256Hash: string;
}

/**
 * Loaded client manifest
 */
let clientManifest: ClientManifest | null = null;

/**
 * Load the client manifest from the generated file
 * This is called automatically on module import
 */
async function loadClientManifest(): Promise<void> {
  if (clientManifest !== null) {
    return; // Already loaded
  }

  try {
    // Dynamic import to avoid issues with SSR
    const manifest = await import('@/generated/persisted-queries/client.json');
    clientManifest = manifest.default || manifest;
    console.log(
      `[PersistedQueries] Loaded ${Object.keys(clientManifest).length} persisted queries`,
    );
  } catch (error) {
    console.warn('[PersistedQueries] Failed to load client manifest:', error);
    clientManifest = {}; // Empty manifest as fallback
  }
}

/**
 * Initialize the persisted queries client
 * Call this early in your app initialization (e.g., in root layout)
 */
export async function initializePersistedQueries(): Promise<void> {
  await loadClientManifest();
}

/**
 * Get the hash for an operation by name
 *
 * @param operationName - The name of the GraphQL operation (query/mutation)
 * @returns The SHA256 hash with "sha256:" prefix, or null if not found
 */
export function getOperationHash(operationName: string): string | null {
  return clientManifest?.[operationName] ?? null;
}

/**
 * Check if an operation is in the persisted queries manifest
 *
 * @param operationName - The name of the GraphQL operation
 * @returns True if the operation is persisted, false otherwise
 */
export function isOperationPersisted(operationName: string): boolean {
  return operationName in (clientManifest ?? {});
}

/**
 * Build the persisted query extension for a GraphQL request
 *
 * @param operationName - The name of the GraphQL operation
 * @returns The persisted query extension, or null if operation not found
 */
export function buildPersistedQueryExtension(
  operationName: string,
): PersistedQueryExtension | null {
  const hash = getOperationHash(operationName);
  if (!hash) {
    return null;
  }

  return {
    version: 1,
    sha256Hash: hash,
  };
}

/**
 * Compute SHA256 hash of a string
 *
 * @param text - The text to hash
 * @returns The SHA256 hash as a hex string with "sha256:" prefix
 */
export async function computeSha256(text: string): Promise<string> {
  const encoder = new TextEncoder();
  const data = encoder.encode(text);
  const hashBuffer = await crypto.subtle.digest('SHA-256', data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const hashHex = hashArray.map((b) => b.toString(16).padStart(2, '0')).join('');
  return `sha256:${hashHex}`;
}

/**
 * Extract operation name from a GraphQL query string
 * This is a simple regex-based extraction that works for most cases
 *
 * @param query - The GraphQL query string
 * @returns The operation name, or null if not found
 */
export function extractOperationName(query: string): string | null {
  // Match: query OperationName or mutation OperationName
  const match = query.match(/(?:query|mutation)\s+(\w+)/);
  return match?.[1] ?? null;
}

/**
 * Get all persisted operation names
 *
 * @returns Array of all operation names in the manifest
 */
export function getAllPersistedOperations(): string[] {
  return Object.keys(clientManifest ?? {});
}
