/**
 * GraphQL fetcher for React Query hooks generated by GraphQL Code Generator
 *
 * The typescript-react-query plugin expects the fetcher to return a function
 * that React Query can call. This is why we return a function here.
 *
 * This fetcher integrates with:
 * - Auth provider for JWT token management
 * - CSRF protection for mutations
 * - Session expiry handling with automatic token refresh
 * - Automatic Persisted Queries (APQ) for reduced bandwidth
 */
import { getAccessToken, tryRefreshToken } from '@/providers/auth-provider/auth-provider.client';
import { getCsrfHeaders } from '@/lib/csrf';
import { extractOperationName, buildPersistedQueryExtension } from '@/lib/persisted-queries';

const GRAPHQL_URL = process.env.NEXT_PUBLIC_GRAPHQL_URL || 'http://localhost:3001/graphql';

/**
 * Session expiry handler callback
 * Set by initializeSessionHandler to enable logout on 401/403
 */
let sessionExpiryHandler: (() => void) | null = null;

/**
 * Initialize the session expiry handler for generated hooks
 * Call this from a component that has access to logout and router
 */
export function initializeGeneratedHooksSessionHandler(handler: () => void): void {
  sessionExpiryHandler = handler;
}

/**
 * GraphQL error item from response
 */
export interface GraphQLErrorItem {
  message: string;
  locations?: Array<{ line: number; column: number }>;
  path?: string[];
  extensions?: Record<string, unknown>;
}

/**
 * GraphQL response with optional errors
 */
export interface GraphQLResult<T> {
  data?: T;
  errors?: GraphQLErrorItem[];
}

/**
 * Enhanced result type that includes errors with data
 * This allows components to handle partial data responses
 */
export type GeneratedHooksResult<T> = T & { _errors?: GraphQLErrorItem[] };

/**
 * Extract GraphQL errors from a result
 */
export function getGeneratedHooksErrors<T>(result: GeneratedHooksResult<T>): GraphQLErrorItem[] {
  return (result as unknown as { _errors?: GraphQLErrorItem[] })._errors ?? [];
}

/**
 * Check if a result has GraphQL errors
 */
export function hasGeneratedHooksErrors<T>(result: GeneratedHooksResult<T>): boolean {
  const errors = getGeneratedHooksErrors(result);
  return errors.length > 0;
}

/**
 * Execute a GraphQL query or mutation with authentication and error handling
 *
 * Features:
 * - Automatic JWT token injection
 * - CSRF token inclusion for mutations
 * - 401/403 session expiry handling with automatic token refresh
 * - Partial data support (errors attached to result when data exists)
 */
async function executeGraphQL<T>(
  query: string,
  variables?: Record<string, unknown>,
): Promise<GeneratedHooksResult<T>> {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
    ...getCsrfHeaders(), // Include CSRF token for mutations
  };

  // Include access token if available
  const accessToken = getAccessToken();
  if (accessToken) {
    headers['Authorization'] = `Bearer ${accessToken}`;
  }

  const response = await fetch(GRAPHQL_URL, {
    method: 'POST',
    headers,
    credentials: 'include', // Required for CORS to send/receive cookies
    body: JSON.stringify({
      query,
      variables,
    }),
  });

  // Handle session expiry (401/403)
  if (!response.ok) {
    // Check for 401 Unauthorized or 403 Forbidden
    if (response.status === 401 || response.status === 403) {
      // Try to refresh token first on 401
      if (response.status === 401) {
        const refreshed = await tryRefreshToken();
        if (refreshed) {
          // Retry the request with new token
          const newAccessToken = getAccessToken();
          if (newAccessToken) {
            headers['Authorization'] = `Bearer ${newAccessToken}`;
          }
          const retryResponse = await fetch(GRAPHQL_URL, {
            method: 'POST',
            headers,
            credentials: 'include',
            body: JSON.stringify({
              query,
              variables,
            }),
          });
          if (retryResponse.ok) {
            const result = (await retryResponse.json()) as GraphQLResult<T>;
            if (result.data && result.errors && result.errors.length > 0) {
              return {
                ...result.data,
                _errors: result.errors,
              } as GeneratedHooksResult<T> & T;
            }
            if (result.errors && result.errors.length > 0) {
              const errorMessages = result.errors.map((e) => e.message).join('; ');
              throw new Error(errorMessages || 'GraphQL error');
            }
            return result.data as GeneratedHooksResult<T> & T;
          }
        }
      }

      // Trigger session expiry handling
      if (sessionExpiryHandler) {
        sessionExpiryHandler();
      }
    }
    throw new Error(`GraphQL request failed: ${response.status}`);
  }

  const result = (await response.json()) as GraphQLResult<T>;

  // If we have both data and errors, return data with errors attached
  if (result.data && result.errors && result.errors.length > 0) {
    return {
      ...result.data,
      _errors: result.errors,
    } as GeneratedHooksResult<T> & T;
  }

  // If we only have errors (no data), throw with all error messages
  if (result.errors && result.errors.length > 0) {
    const errorMessages = result.errors.map((e) => e.message).join('; ');
    throw new Error(errorMessages || 'GraphQL error');
  }

  // No errors, return data normally
  return result.data as GeneratedHooksResult<T> & T;
}

/**
 * GraphQL fetcher for React Query hooks generated by GraphQL Code Generator
 *
 * This fetcher is used by the typescript-react-query plugin to generate
 * useQuery and useMutation hooks with full authentication and error handling.
 *
 * Supports Automatic Persisted Queries (APQ):
 * - Sends query hash instead of full query when available
 * - Falls back to full query if hash not found
 *
 * Usage in generated hooks:
 * ```tsx
 * const { data, error, isLoading } = useGetMyPreferencesQuery();
 * const { mutate, data, error } = useUpdateMyPreferencesMutation();
 * ```
 */
export function fetcher<TData, TVariables>(
  query: string,
  variables?: TVariables,
  options?: RequestInit['headers'],
) {
  return async (): Promise<TData> => {
    // Merge custom headers with defaults
    const headers: HeadersInit = {
      'Content-Type': 'application/json',
      ...(options ?? {}),
    };

    // Include access token if available
    const accessToken = getAccessToken();
    if (accessToken && typeof headers === 'object') {
      (headers as Record<string, string>)['Authorization'] = `Bearer ${accessToken}`;
    }

    // Include CSRF headers
    const csrfHeaders = getCsrfHeaders();
    if (typeof headers === 'object') {
      Object.assign(headers, csrfHeaders);
    }

    // Build request body with persisted query support
    const operationName = extractOperationName(query);
    const persistedQueryExtension =
      operationName !== null ? buildPersistedQueryExtension(operationName) : null;

    const body: Record<string, unknown> = {
      variables,
    };

    // Add persisted query extension if available
    if (persistedQueryExtension) {
      body.extensions = {
        persistedQuery: persistedQueryExtension,
      };
      // Only include query if not using persisted query (fallback)
      // For APQ, we send the hash first, then include query for fallback
      body.query = query;
    } else {
      // No persisted query available, send full query
      body.query = query;
    }

    const response = await fetch(GRAPHQL_URL, {
      method: 'POST',
      headers,
      credentials: 'include',
      body: JSON.stringify(body),
    });

    // Handle session expiry
    if (!response.ok) {
      if (response.status === 401 || response.status === 403) {
        if (response.status === 401) {
          const refreshed = await tryRefreshToken();
          if (refreshed) {
            const newAccessToken = getAccessToken();
            const retryHeaders: HeadersInit = {
              'Content-Type': 'application/json',
              ...(options ?? {}),
            };
            if (newAccessToken) {
              (retryHeaders as Record<string, string>)['Authorization'] =
                `Bearer ${newAccessToken}`;
            }
            Object.assign(retryHeaders, getCsrfHeaders());
            const retryResponse = await fetch(GRAPHQL_URL, {
              method: 'POST',
              headers: retryHeaders,
              credentials: 'include',
              body: JSON.stringify(body),
            });
            if (retryResponse.ok) {
              const json = await retryResponse.json();
              if (json.errors) {
                const { message } = json.errors[0] as { message: string };
                throw new Error(message);
              }
              return json.data as TData;
            }
          }
        }

        // Trigger session expiry handling
        if (sessionExpiryHandler) {
          sessionExpiryHandler();
        }
      }
      throw new Error(`GraphQL request failed: ${response.status}`);
    }

    const json = await response.json();

    if (json.errors) {
      const { message } = json.errors[0] as { message: string };
      throw new Error(message);
    }

    return json.data as TData;
  };
}

// Export the executeGraphQL function for direct use in custom scenarios
export { executeGraphQL };

export default fetcher;
