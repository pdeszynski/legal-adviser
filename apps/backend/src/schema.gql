# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type AIEngineMessageFormat {
  """Message content"""
  content: String!

  """Message role (user or assistant)"""
  role: String!
}

input ActivateUserInput {
  userId: ID!
}

type ActiveUsersCount {
  calculatedAt: DateTime!

  """Users active in last 7 days"""
  last7Days: Int!

  """Users active in last 24 hours"""
  last24Hours: Int!

  """Users active in last 30 days"""
  last30Days: Int!
}

input AdminCreateUserInput {
  email: String!
  firstName: String
  isActive: Boolean = true
  lastName: String
  password: String!
  role: String = "client"
  username: String
}

input AdminForceDisableTwoFactorInput {
  """The ID of the user to disable 2FA for"""
  userId: String!
}

type AdminForceDisableTwoFactorResponse {
  """The user ID"""
  id: String!

  """The updated 2FA status (should be false)"""
  twoFactorEnabled: Boolean!
}

type AdvancedLegalRulingSearchResponse {
  """Number of results returned"""
  count: Int!

  """Whether there are more results"""
  hasMore: Boolean!

  """Current offset"""
  offset: Int!

  """Human-readable explanation of the search query that was executed"""
  queryExplanation: String

  """Search results with relevance ranking"""
  results: [AggregatedLegalRulingSearchResult!]!

  """Total number of matching results (for pagination)"""
  totalCount: Int!
}

input AdvancedSearchLegalRulingsInput {
  """Filter by court type"""
  courtType: CourtType

  """Filter by ruling date from (ISO 8601 date string)"""
  dateFrom: String

  """Filter by ruling date to (ISO 8601 date string)"""
  dateTo: String

  """Filter by keywords (must match all)"""
  keywords: [String!]

  """Filter by legal area from metadata"""
  legalArea: String

  """Maximum number of results to return (default: 20, max: 100)"""
  limit: Int = 20

  """Number of results to skip for pagination"""
  offset: Int = 0

  """Array of search terms with operators and field specifications"""
  searchTerms: [AdvancedSearchTermInput!]!

  """Sources to search (default: all sources)"""
  sources: [SearchSource!] = [LOCAL, SAOS, ISAP]
}

input AdvancedSearchTermInput {
  """Field to search in (default: ALL)"""
  field: SearchField! = ALL

  """Boolean operator to combine with previous term (default: AND)"""
  operator: BooleanOperator! = AND

  """Search term text"""
  term: String!
}

type AffectedUserInfo {
  """Number of affected sessions"""
  affectedSessionCount: Int!

  """User email (if available)"""
  email: String

  """Number of empty messages for this user"""
  emptyMessageCount: Int!

  """List of affected session IDs"""
  sessionIds: [String!]!

  """The user ID"""
  userId: ID!
}

type AffectedUsersReport {
  """Total number of affected users"""
  totalAffectedUsers: Int!

  """Total number of empty messages across all users"""
  totalEmptyMessages: Int!

  """List of affected users with details"""
  users: [AffectedUserInfo!]!
}

type AgentLatencyMetrics {
  """Agent type"""
  agentType: AgentType!

  """Average latency in milliseconds"""
  avgLatency: Float!

  """Maximum latency in milliseconds"""
  maxLatency: Float!

  """Median latency in milliseconds"""
  medianLatency: Float!

  """Minimum latency in milliseconds"""
  minLatency: Float!

  """P95 latency in milliseconds"""
  p95Latency: Int!

  """Total request count"""
  requestCount: Int!
}

"""Type of AI agent or workflow"""
enum AgentType {
  CLARIFICATION_AGENT
  CLASSIFIER_AGENT
  DRAFTING_AGENT
  QA_AGENT
  UNKNOWN
  WORKFLOW
}

type AggregatedLegalRulingSearchResponse {
  """Number of results returned"""
  count: Int!

  """Whether there are more results"""
  hasMore: Boolean!

  """Current offset"""
  offset: Int!

  """Search results with relevance ranking from multiple sources"""
  results: [AggregatedLegalRulingSearchResult!]!

  """Total number of matching results (for pagination)"""
  totalCount: Int!
}

type AggregatedLegalRulingSearchResult {
  """Highlighted snippet of matching content"""
  headline: String

  """Relevance score (higher is better)"""
  rank: Float!

  """The matching legal ruling"""
  ruling: LegalRuling!

  """Source of the result"""
  source: SearchSource!
}

input AggregatedSearchLegalRulingsInput {
  """Filter by court type"""
  courtType: CourtType

  """Filter by ruling date from (ISO 8601 date string)"""
  dateFrom: String

  """Filter by ruling date to (ISO 8601 date string)"""
  dateTo: String

  """Maximum number of results to return (default: 20, max: 100)"""
  limit: Int = 20

  """Number of results to skip for pagination"""
  offset: Int = 0

  """Search query text"""
  query: String!

  """Sources to search (default: all sources)"""
  sources: [SearchSource!] = [LOCAL, SAOS, ISAP]
}

"""Available AI models for legal operations"""
enum AiModelType {
  CLAUDE_3_OPUS
  CLAUDE_3_SONNET
  GPT_3_5_TURBO
  GPT_4
  GPT_4_TURBO
}

input AiModelTypeFilterComparison {
  eq: AiModelType
  gt: AiModelType
  gte: AiModelType
  iLike: AiModelType
  in: [AiModelType!]
  is: Boolean
  isNot: Boolean
  like: AiModelType
  lt: AiModelType
  lte: AiModelType
  neq: AiModelType
  notILike: AiModelType
  notIn: [AiModelType!]
  notLike: AiModelType
}

type AiOperationBreakdown {
  """Percentage of total cost"""
  costPercentage: Float!
  operationType: String!
  requestCount: Int!
  totalCost: Float!
  totalTokens: Int!
}

enum AiOperationType {
  CASE_CLASSIFICATION
  DOCUMENT_GENERATION
  EMBEDDING_GENERATION
  QUESTION_ANSWERING
  RAG_QUESTION_ANSWERING
  RULING_SEARCH
  SEMANTIC_SEARCH
}

type AiUsageMetrics {
  """Average cost per request"""
  avgCostPerRequest: Float!

  """Average tokens per request"""
  avgTokensPerRequest: Int!
  periodEnd: DateTime!
  periodStart: DateTime!

  """Total cost in USD"""
  totalCost: Float!
  totalRequests: Int!
  totalTokens: Int!
}

type AiUsageRecord {
  costCalculated: Float!
  createdAt: DateTime!
  id: ID!
  metadata: String
  operationType: AiOperationType!
  requestCount: Float!
  resourceId: ID
  tokensUsed: Float!
  userId: String!
}

type AnalysisMetadata {
  analysisVersion: String
  modelUsed: String
  processingTimeMs: Float
}

input AnalysisMetadataInput {
  analysisVersion: String
  modelUsed: String
  processingTimeMs: Float
}

"""Status of the legal analysis process"""
enum AnalysisStatus {
  COMPLETED
  FAILED
  PENDING
  PROCESSING
}

input AnalysisStatusFilterComparison {
  eq: AnalysisStatus
  gt: AnalysisStatus
  gte: AnalysisStatus
  iLike: AnalysisStatus
  in: [AnalysisStatus!]
  is: Boolean
  isNot: Boolean
  like: AnalysisStatus
  lt: AnalysisStatus
  lte: AnalysisStatus
  neq: AnalysisStatus
  notILike: AnalysisStatus
  notIn: [AnalysisStatus!]
  notLike: AnalysisStatus
}

type AnalyticsDashboard {
  aiOperationBreakdown: [AiOperationBreakdown!]!
  aiUsage: AiUsageMetrics!
  documentTypeDistribution: [DocumentTypeDistribution!]!
  documents: DocumentMetrics!
  generatedAt: DateTime!
  queries: QueryMetrics!
  systemHealth: SystemHealthMetrics!
  userGrowth: UserGrowthMetrics!
}

"""Time period granularity for analytics data"""
enum AnalyticsPeriod {
  DAILY
  HOURLY
  MONTHLY
  WEEKLY
  YEARLY
}

type AnalyticsTimeSeriesPoint {
  count: Int!
  timestamp: DateTime!
  value: Float
}

input AnswerLegalQueryInput {
  """The AI-generated answer in Markdown format"""
  answerMarkdown: String!

  """Citations and references for the answer"""
  citations: [CreateCitationInput!]
}

type ApiKey {
  createdAt: DateTime!
  description: String
  expiresAt: DateTime
  id: ID!
  keyPrefix: String!
  lastUsedAt: DateTime
  lastUsedIp: String
  name: String!
  rateLimitPerMinute: Int
  scopes: [ApiKeyScope!]!
  status: ApiKeyStatus!
  updatedAt: DateTime!
  usageCount: Float!
  userId: String!
}

"""API key scopes/permissions"""
enum ApiKeyScope {
  AI_ANALYZE
  AI_GENERATE
  DOCUMENTS_DELETE
  DOCUMENTS_READ
  DOCUMENTS_WRITE
  PROFILE_READ
  PROFILE_WRITE
  QUERIES_DELETE
  QUERIES_READ
  QUERIES_WRITE
  RULINGS_READ
  RULINGS_SEARCH
  TEMPLATES_READ
  TEMPLATES_WRITE
}

"""API key status"""
enum ApiKeyStatus {
  ACTIVE
  EXPIRED
  REVOKED
}

input ApproveDocumentInput {
  """Document ID to approve"""
  documentId: ID!

  """Optional reason for approval"""
  reason: String
}

input AskLegalQuestionInput {
  """
  Response mode: LAWYER (detailed legal analysis) or SIMPLE (layperson-friendly)
  """
  mode: String

  """The legal question to ask the AI"""
  question: String!

  """
  Session ID for the user asking the question (optional - will be auto-created if not provided)
  """
  sessionId: String

  """
  Message type: TEXT (default question), CLARIFICATION_ANSWER (answers to clarification questions)
  """
  type: String
}

"""Type of action performed"""
enum AuditActionType {
  CREATE
  DELETE
  EXPORT
  LOGIN
  LOGOUT
  PAUSE
  READ
  RESUME
  UPDATE
}

input AuditActionTypeFilterComparison {
  eq: AuditActionType
  gt: AuditActionType
  gte: AuditActionType
  iLike: AuditActionType
  in: [AuditActionType!]
  is: Boolean
  isNot: Boolean
  like: AuditActionType
  lt: AuditActionType
  lte: AuditActionType
  neq: AuditActionType
  notILike: AuditActionType
  notIn: [AuditActionType!]
  notLike: AuditActionType
}

type AuditLog {
  action: AuditActionType!
  changeDetails: JSON
  createdAt: DateTime!
  errorMessage: String
  id: ID!
  ipAddress: String
  resourceId: String
  resourceType: AuditResourceType!
  statusCode: Int
  updatedAt: DateTime!
  user: User
  userAgent: String
  userId: String
}

input AuditLogAggregateFilter {
  action: AuditActionTypeFilterComparison
  and: [AuditLogAggregateFilter!]
  createdAt: DateFieldComparison
  id: IDFilterComparison
  ipAddress: StringFieldComparison
  or: [AuditLogAggregateFilter!]
  resourceId: StringFieldComparison
  resourceType: AuditResourceTypeFilterComparison
  updatedAt: DateFieldComparison
  userId: StringFieldComparison
}

type AuditLogAggregateGroupBy {
  action: AuditActionType
  createdAt(by: GroupBy! = DAY): DateTime
  id: ID
  ipAddress: String
  resourceId: String
  resourceType: AuditResourceType
  updatedAt(by: GroupBy! = DAY): DateTime
  userId: String
}

type AuditLogAggregateResponse {
  count: AuditLogCountAggregate
  groupBy: AuditLogAggregateGroupBy
  max: AuditLogMaxAggregate
  min: AuditLogMinAggregate
}

type AuditLogConnection {
  """Array of edges."""
  edges: [AuditLogEdge!]!

  """Paging information"""
  pageInfo: PageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type AuditLogCountAggregate {
  action: Int
  createdAt: Int
  id: Int
  ipAddress: Int
  resourceId: Int
  resourceType: Int
  updatedAt: Int
  userId: Int
}

type AuditLogEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the AuditLog"""
  node: AuditLog!
}

input AuditLogFilter {
  action: AuditActionTypeFilterComparison
  and: [AuditLogFilter!]
  createdAt: DateFieldComparison
  id: IDFilterComparison
  ipAddress: StringFieldComparison
  or: [AuditLogFilter!]
  resourceId: StringFieldComparison
  resourceType: AuditResourceTypeFilterComparison
  updatedAt: DateFieldComparison
  userId: StringFieldComparison
}

type AuditLogMaxAggregate {
  action: AuditActionType
  createdAt: DateTime
  id: ID
  ipAddress: String
  resourceId: String
  resourceType: AuditResourceType
  updatedAt: DateTime
  userId: String
}

type AuditLogMinAggregate {
  action: AuditActionType
  createdAt: DateTime
  id: ID
  ipAddress: String
  resourceId: String
  resourceType: AuditResourceType
  updatedAt: DateTime
  userId: String
}

input AuditLogSort {
  direction: SortDirection!
  field: AuditLogSortFields!
  nulls: SortNulls
}

enum AuditLogSortFields {
  action
  createdAt
  id
  ipAddress
  resourceId
  resourceType
  updatedAt
  userId
}

"""Type of resource affected"""
enum AuditResourceType {
  DOCUMENT
  SCHEDULE
  SESSION
  SYSTEM
  USER
  WEBHOOK
}

input AuditResourceTypeFilterComparison {
  eq: AuditResourceType
  gt: AuditResourceType
  gte: AuditResourceType
  iLike: AuditResourceType
  in: [AuditResourceType!]
  is: Boolean
  isNot: Boolean
  like: AuditResourceType
  lt: AuditResourceType
  lte: AuditResourceType
  neq: AuditResourceType
  notILike: AuditResourceType
  notIn: [AuditResourceType!]
  notLike: AuditResourceType
}

type AuthPayload {
  """JWT access token (null if 2FA is required)"""
  accessToken: String

  """
  JWT refresh token for obtaining new access tokens (null if 2FA is required)
  """
  refreshToken: String

  """True if user needs to provide 2FA token to complete login"""
  requiresTwoFactor: Boolean!

  """Temporary token for completing 2FA (only present when 2FA is required)"""
  twoFactorTempToken: String

  """Authenticated user information (null if 2FA is required)"""
  user: AuthUser
}

type AuthUser {
  disclaimerAccepted: Boolean!
  disclaimerAcceptedAt: DateTime
  email: String!
  firstName: String
  id: ID!
  isActive: Boolean!
  lastName: String

  """
  Array of user roles (single role wrapped as array for consistency with JWT format)
  """
  user_roles: [String!]!
  username: String
}

type Backup {
  createdAt: Timestamp
  expiresAt: Timestamp
  filename: String!
  id: ID!
  isRestored: Boolean!
  metadata: BackupMetadata
  restoreDate: Timestamp
  sizeBytes: Int!

  """Size in human-readable format (MB)"""
  sizeMB: Float!
  status: String!
  storagePath: String
  storageType: String!
}

type BackupMetadata {
  compression: String
  database: String!
  host: String!
  pgVersion: String
}

type BackupStats {
  activeBackups: Int!
  failedBackups: Int!
  lastBackupDate: Timestamp
  lastSuccessfulBackupDate: Timestamp
  successfulBackups: Int!
  totalBackups: Int!
  totalSizeMB: Float!
}

type BillingInfo {
  cancelAtPeriodEnd: Boolean!
  currentPeriodEnd: String!
  currentPeriodStart: String!
  daysRemaining: Int!
  nextBillingAmount: String
  paymentHistory: [PaymentHistoryItem!]!
  paymentMethods: [PaymentMethodInfo!]
  planName: String!
  planTier: PlanTier!
  status: SubscriptionStatus!
  subscriptionId: ID!
  usage: String!
}

"""Billing interval options"""
enum BillingInterval {
  MONTHLY
  YEARLY
}

input BooleanFieldComparison {
  is: Boolean
  isNot: Boolean
}

input BooleanFilter {
  eq: Boolean
  is: Boolean
}

"""Boolean operators for combining search terms"""
enum BooleanOperator {
  AND
  NOT
  OR
}

"""Budget ranges for implementation"""
enum BudgetRange {
  NOT_SPECIFIED
  OVER_100K
  RANGE_5K_10K
  RANGE_10K_25K
  RANGE_25K_50K
  RANGE_50K_100K
  UNDER_5K
}

input BulkActivateUsersInput {
  userIds: [ID!]!
}

input BulkChangeUserRolesInput {
  role: UserRole!
  userIds: [ID!]!
}

input BulkDeleteUsersInput {
  userIds: [ID!]!
}

type BulkDeleteUsersResult {
  failed: [BulkOperationError!]!
  success: [ID!]!
}

type BulkOperationError {
  error: String!
  id: String!
}

input BulkSendNotificationInput {
  """Channel to send notification through"""
  channel: NotificationChannel

  """Custom message override"""
  customMessage: String

  """Data for template rendering (JSON string)"""
  templateData: String

  """Type of notification template to use"""
  templateType: NotificationTemplateType!

  """List of user IDs"""
  userIds: [String!]!
}

type BulkSendNotificationResponse {
  """Number of failed notifications"""
  failed: Int!

  """List of user IDs that failed"""
  failedUserIds: [String!]

  """Number of successful notifications"""
  successful: Int!

  """Total number of notifications sent"""
  totalSent: Int!
}

input BulkSuspendUsersInput {
  reason: String!
  userIds: [ID!]!
}

input BulkUpdateSettingsInput {
  settings: [SystemSettingInput!]!
}

type BulkUsersResult {
  failed: [BulkOperationError!]!
  success: [User!]!
}

input CancelClarificationSessionInput {
  """ID of the clarification session to cancel"""
  sessionId: String!
}

input CancelSubscriptionInput {
  immediately: Boolean! = false
}

input ChangePasswordInput {
  """Current password"""
  currentPassword: String!

  """New password"""
  newPassword: String!
}

input ChangeUserRoleInput {
  role: UserRole!
  userId: ID!
}

type ChatCitation {
  article: String
  excerpt: String
  source: String!
  url: String
}

input ChatCitationInput {
  article: String
  excerpt: String
  source: String!
  url: String
}

type ChatContentSearchResponse {
  """Number of results returned"""
  count: Int!

  """Whether there are more results"""
  hasMore: Boolean!

  """Current offset"""
  offset: Int!

  """List of search results"""
  results: [ChatContentSearchResult!]!

  """Total count of matching messages"""
  totalCount: Int!
}

type ChatContentSearchResult {
  """Original message content"""
  content: String!

  """Context preview with highlighted match"""
  contextPreview: String

  """Message creation timestamp"""
  createdAt: DateTime!

  """Message content with highlighted matching text"""
  highlightedContent: String!

  """List of matched terms"""
  matchedTerms: [String!]!

  """Message ID"""
  messageId: ID!

  """Relevance ranking score (higher is more relevant)"""
  rank: Float!

  """Role of the message sender"""
  role: MessageRole!

  """Sequence order in the session"""
  sequenceOrder: Float!

  """Session ID"""
  sessionId: ID!

  """Total number of messages in the session"""
  sessionMessageCount: Int!

  """AI mode of the session"""
  sessionMode: ChatMode!

  """Session title"""
  sessionTitle: String
}

"""Export format for chat sessions"""
enum ChatExportFormat {
  JSON
  MARKDOWN
  PDF
}

type ChatExportResult {
  """Base64-encoded content of the export"""
  contentBase64: String!

  """Timestamp when the export was generated"""
  exportedAt: DateTime!

  """Size of the export in bytes"""
  fileSizeBytes: Float!

  """Filename for the export"""
  filename: String!

  """Format of the export"""
  format: ChatExportFormat!

  """MIME type of the export"""
  mimeType: String!

  """Session ID that was exported"""
  sessionId: ID!
}

type ChatMessage {
  """Legal citations/references in assistant responses"""
  citations: [ChatCitation!]

  """Message content (markdown for assistant responses)"""
  content: String!
  createdAt: DateTime!
  messageId: ID!

  """Additional message metadata"""
  metadata: ChatMessageMetadata

  """Original content before AI processing"""
  rawContent: String

  """Role of the message sender"""
  role: MessageRole!

  """Sequence order of the message within the session"""
  sequenceOrder: Float!

  """ID of the chat session this message belongs to"""
  sessionId: ID!

  """Type of message content"""
  type: ChatMessageType
}

interface ChatMessageInterface {
  """Message content"""
  content: String!

  """Creation timestamp"""
  createdAt: DateTime!

  """Unique message identifier"""
  messageId: ID!

  """Role of the message sender"""
  role: MessageRole!

  """Sequence order in conversation"""
  sequenceOrder: Float!

  """Session ID"""
  sessionId: ID!

  """Message type discriminator for resolving concrete types"""
  type: ChatMessageType
}

type ChatMessageMetadata {
  clarification: ClarificationInfoType
  confidence: Float
  keyTerms: [String!]
  language: String
  model: String
  queryType: String
}

input ChatMessageMetadataInput {
  """Clarification data for messages that need clarification"""
  clarification: ClarificationInfoInput

  """Confidence score of AI response (0-1)"""
  confidence: Float

  """Key legal terms extracted"""
  keyTerms: [String!]

  """Language detected"""
  language: String

  """Model used for generation (e.g., gpt-4o)"""
  model: String

  """Query type classification"""
  queryType: String
}

"""The type of message content"""
enum ChatMessageType {
  CITATION
  CLARIFICATION_ANSWER
  CLARIFICATION_QUESTION
  ERROR
  TEXT
}

"""The AI response mode for chat messages"""
enum ChatMode {
  LAWYER
  SIMPLE
}

input ChatModeFilterComparison {
  eq: ChatMode
  gt: ChatMode
  gte: ChatMode
  iLike: ChatMode
  in: [ChatMode!]
  is: Boolean
  isNot: Boolean
  like: ChatMode
  lt: ChatMode
  lte: ChatMode
  neq: ChatMode
  notILike: ChatMode
  notIn: [ChatMode!]
  notLike: ChatMode
}

type ChatSession {
  createdAt: DateTime!

  """Soft delete timestamp, null if not deleted"""
  deletedAt: DateTime
  id: ID!

  """Whether the session is pinned by the user"""
  isPinned: Boolean!

  """Timestamp of the last message for sorting"""
  lastMessageAt: DateTime

  """Number of messages in the session"""
  messageCount: Float!

  """AI response mode for this session"""
  mode: ChatMode!

  """Session title, auto-generated from first message if not provided"""
  title: String
  updatedAt: DateTime!
  user: User!
  userId: ID!
}

input ChatSessionAggregateFilter {
  and: [ChatSessionAggregateFilter!]
  createdAt: DateFieldComparison
  deletedAt: DateFieldComparison
  id: IDFilterComparison
  isPinned: BooleanFieldComparison
  lastMessageAt: DateFieldComparison
  messageCount: NumberFieldComparison
  mode: ChatModeFilterComparison
  or: [ChatSessionAggregateFilter!]
  title: StringFieldComparison
  updatedAt: DateFieldComparison
  userId: IDFilterComparison
}

type ChatSessionAggregateGroupBy {
  createdAt(by: GroupBy! = DAY): DateTime
  deletedAt: DateTime
  id: ID
  isPinned: Boolean
  lastMessageAt: DateTime
  messageCount: Float
  mode: ChatMode
  title: String
  updatedAt(by: GroupBy! = DAY): DateTime
  userId: ID
}

type ChatSessionAggregateResponse {
  avg: ChatSessionAvgAggregate
  count: ChatSessionCountAggregate
  groupBy: ChatSessionAggregateGroupBy
  max: ChatSessionMaxAggregate
  min: ChatSessionMinAggregate
  sum: ChatSessionSumAggregate
}

type ChatSessionAvgAggregate {
  messageCount: Float
}

type ChatSessionConnection {
  """Array of edges."""
  edges: [ChatSessionEdge!]!

  """Paging information"""
  pageInfo: PageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type ChatSessionCountAggregate {
  createdAt: Int
  deletedAt: Int
  id: Int
  isPinned: Int
  lastMessageAt: Int
  messageCount: Int
  mode: Int
  title: Int
  updatedAt: Int
  userId: Int
}

type ChatSessionDebugInfo {
  """Messages in AI Engine format (what gets sent to AI)"""
  aiEngineFormat: [AIEngineMessageFormat!]!

  """Total number of messages in history"""
  messageCount: Float!

  """Message previews with full details"""
  messages: [ConversationMessagePreview!]!

  """Role distribution in conversation"""
  roleDistribution: ConversationRoleDistribution!

  """Session ID"""
  sessionId: String!

  """Total characters across all messages"""
  totalCharacters: Float!

  """Verification information"""
  verification: ConversationHistoryVerification!
}

type ChatSessionDeleteResponse {
  createdAt: DateTime

  """Soft delete timestamp, null if not deleted"""
  deletedAt: DateTime
  id: ID

  """Whether the session is pinned by the user"""
  isPinned: Boolean

  """Timestamp of the last message for sorting"""
  lastMessageAt: DateTime

  """Number of messages in the session"""
  messageCount: Float

  """AI response mode for this session"""
  mode: ChatMode

  """Session title, auto-generated from first message if not provided"""
  title: String
  updatedAt: DateTime
  userId: ID
}

type ChatSessionEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the ChatSession"""
  node: ChatSession!
}

input ChatSessionFilter {
  and: [ChatSessionFilter!]
  createdAt: DateFieldComparison
  deletedAt: DateFieldComparison
  id: IDFilterComparison
  isPinned: BooleanFieldComparison
  lastMessageAt: DateFieldComparison
  messageCount: NumberFieldComparison
  mode: ChatModeFilterComparison
  or: [ChatSessionFilter!]
  title: StringFieldComparison
  updatedAt: DateFieldComparison
  userId: IDFilterComparison
}

type ChatSessionMaxAggregate {
  createdAt: DateTime
  deletedAt: DateTime
  id: ID
  lastMessageAt: DateTime
  messageCount: Float
  mode: ChatMode
  title: String
  updatedAt: DateTime
  userId: ID
}

type ChatSessionMinAggregate {
  createdAt: DateTime
  deletedAt: DateTime
  id: ID
  lastMessageAt: DateTime
  messageCount: Float
  mode: ChatMode
  title: String
  updatedAt: DateTime
  userId: ID
}

input ChatSessionSort {
  direction: SortDirection!
  field: ChatSessionSortFields!
  nulls: SortNulls
}

enum ChatSessionSortFields {
  createdAt
  deletedAt
  id
  isPinned
  lastMessageAt
  messageCount
  mode
  title
  updatedAt
  userId
}

type ChatSessionSumAggregate {
  messageCount: Float
}

type CheckEmailExistsResult {
  exists: Boolean!
  userId: String
  username: String
}

input CheckQuotaInput {
  amount: Int = 1
  quotaKey: String!
}

type CheckQuotaResponse {
  allowed: Boolean!
  limit: Int!
  message: String
  remaining: Int!
}

type Citation {
  article: String
  excerpt: String
  source: String!
  url: String
}

"""Message focused on legal citations and references"""
type CitationMessage implements ChatMessageInterface {
  citationCount: Float!
  citations: [ChatCitation!]!
  confidence: Float

  """Message content"""
  content: String!

  """Creation timestamp"""
  createdAt: DateTime!

  """Unique message identifier"""
  messageId: ID!
  queryType: String

  """Role of the message sender"""
  role: MessageRole!

  """Sequence order in conversation"""
  sequenceOrder: Float!

  """Session ID"""
  sessionId: ID!

  """Message type discriminator for resolving concrete types"""
  type: ChatMessageType
}

type ClarificationAnswer {
  answer: String!
  answered_at: DateTime
  question: String!
  question_type: String!
}

input ClarificationAnswerInput {
  """The user answer"""
  answer: String!

  """Unique identifier of the question being answered"""
  questionId: String!
}

type ClarificationAnswerItemType {
  answer: String!
  question: String!
  question_type: String
}

"""User's answers to clarification questions"""
type ClarificationAnswerMessage implements ChatMessageInterface {
  """When the answers were submitted"""
  answeredAt: DateTime
  answers: [ClarificationAnswerItemType!]!
  clarificationMessageId: ID

  """Message content"""
  content: String!

  """Creation timestamp"""
  createdAt: DateTime!

  """Unique message identifier"""
  messageId: ID!

  """Role of the message sender"""
  role: MessageRole!

  """Sequence order in conversation"""
  sequenceOrder: Float!

  """Session ID"""
  sessionId: ID!

  """Message type discriminator for resolving concrete types"""
  type: ChatMessageType
}

type ClarificationInfo {
  context_summary: String!
  needs_clarification: Boolean!
  next_steps: String!
  questions: [ClarificationQuestion!]!
}

input ClarificationInfoInput {
  answered: Boolean
  context_summary: String!
  currentRound: Float
  needs_clarification: Boolean!
  next_steps: String!
  questions: [LegacyClarificationQuestionInput!]!
  totalRounds: Float
}

type ClarificationInfoType {
  answered: Boolean
  context_summary: String!
  currentRound: Float
  needs_clarification: Boolean!
  next_steps: String!
  questions: [ClarificationQuestionType!]!
  totalRounds: Float
}

type ClarificationQuestion {
  hint: String
  options: [String!]
  question: String!
  question_type: String!
}

type ClarificationQuestionItemType {
  hint: String
  options: [String!]
  question: String!
  question_type: String!
}

"""Message from AI asking follow-up clarification questions to the user"""
type ClarificationQuestionMessage implements ChatMessageInterface {
  """Whether the clarification has been answered"""
  answered: Boolean

  """Message content"""
  content: String!
  context_summary: String!

  """Creation timestamp"""
  createdAt: DateTime!

  """Current clarification round"""
  currentRound: Float

  """Unique message identifier"""
  messageId: ID!
  next_steps: String!
  questions: [ClarificationQuestionItemType!]!

  """Role of the message sender"""
  role: MessageRole!

  """Sequence order in conversation"""
  sequenceOrder: Float!

  """Session ID"""
  sessionId: ID!

  """Total clarification rounds"""
  totalRounds: Float

  """Message type discriminator for resolving concrete types"""
  type: ChatMessageType
}

type ClarificationQuestionType {
  hint: String
  options: [String!]
  question: String!
  questionId: String
  questionType: String
  question_type: String
  required: Boolean
}

type ClarificationSession {
  """Accumulated context for AI processing"""
  accumulatedContext: [String!]

  """User answers to clarification questions"""
  answersReceived: [ClarificationAnswer!]!

  """Session completion timestamp"""
  completedAt: DateTime
  createdAt: DateTime!

  """Error message if session failed"""
  errorMessage: String

  """Session expiration timestamp"""
  expiresAt: DateTime!

  """Final query ID with complete answer"""
  finalQueryId: ID
  id: ID!
  originalQuery: String!
  queryId: ID!

  """Array of clarification question texts"""
  questionsAsked: [String!]!

  """Number of clarification rounds"""
  rounds: Float!
  sessionId: ID
  state: ClarificationState!
  updatedAt: DateTime!
}

"""The current state of a clarification session"""
enum ClarificationState {
  ANSWERED
  CANCELLED
  COMPLETE
  EXPIRED
  PENDING
}

type ClarificationValidationError {
  """Error code for programmatic handling"""
  code: String!

  """Error message describing what went wrong"""
  message: String!

  """The question ID that has validation errors"""
  questionId: String!
}

input ClassifyCaseInput {
  """Detailed description of the legal case to analyze"""
  caseDescription: String!

  """Additional context for the analysis"""
  context: String

  """User session ID for tracking"""
  sessionId: String!

  """Title or brief summary of the analysis"""
  title: String!
}

input CleanupEmptyMessagesInput {
  """Actually perform the cleanup (false = dry run)"""
  execute: Boolean = false

  """Mark truly empty messages for deletion"""
  markForDeletion: Boolean = false

  """Recover messages from clarification metadata"""
  recoverFromClarification: Boolean = true

  """Recover messages from rawContent if available"""
  recoverFromRawContent: Boolean = true
}

type CleanupEmptyMessagesResult {
  """Number of affected sessions"""
  affectedSessions: Int!

  """Number of affected users"""
  affectedUsers: Int!

  """Number of messages marked for deletion (truly empty)"""
  markedForDeletion: Int!

  """Number of messages recovered from clarification metadata"""
  recoveredFromClarification: Int!

  """Number of messages recovered from rawContent"""
  recoveredFromRawContent: Int!

  """List of affected session IDs"""
  sessionIds: [String!]!

  """Number of messages that could not be recovered"""
  unrecoverable: Int!

  """List of affected user IDs"""
  userIds: [String!]!
}

input CleanupEmptySessionsInput {
  """Actually perform the cleanup (false = dry run)"""
  execute: Boolean = false
}

type CleanupEmptySessionsResult {
  """Number of affected users"""
  affectedUsers: Int!

  """Number of sessions that were deleted"""
  deletedSessions: Int!

  """List of errors that occurred during cleanup"""
  errors: [CleanupErrorDetail!]!

  """List of deleted session IDs"""
  sessionIds: [String!]!

  """Number of sessions skipped (had messages or other issues)"""
  skippedSessions: Int!

  """Total number of empty sessions found"""
  totalEmptySessions: Int!

  """List of affected user IDs"""
  userIds: [String!]!
}

type CleanupErrorDetail {
  """Error message"""
  error: String!

  """The session ID that failed"""
  sessionId: ID!
}

type CommentPosition {
  endOffset: Float!
  section: String
  startOffset: Float!
  text: String
}

"""Resolution status of a document comment"""
enum CommentResolutionStatus {
  OPEN
  RESOLVED
}

input CommentResolutionStatusFilterComparison {
  eq: CommentResolutionStatus
  gt: CommentResolutionStatus
  gte: CommentResolutionStatus
  iLike: CommentResolutionStatus
  in: [CommentResolutionStatus!]
  is: Boolean
  isNot: Boolean
  like: CommentResolutionStatus
  lt: CommentResolutionStatus
  lte: CommentResolutionStatus
  neq: CommentResolutionStatus
  notILike: CommentResolutionStatus
  notIn: [CommentResolutionStatus!]
  notLike: CommentResolutionStatus
}

"""Company size categories"""
enum CompanySize {
  ENTERPRISE_500_PLUS
  LARGE_201_500
  MEDIUM_51_200
  SMALL_2_10
  SMALL_11_50
  SOLO
}

"""Company size categories for demo requests"""
enum CompanySizeEnum {
  ENTERPRISE
  LARGE
  MEDIUM
  SMALL
  SOLO
}

input CompleteTwoFactorLoginInput {
  """Backup code for account recovery (alternative to TOTP token)"""
  backupCode: String

  """Temporary token received from login when 2FA is required"""
  twoFactorTempToken: String!

  """The 6-digit TOTP token from authenticator app"""
  twoFactorToken: String
}

input ConditionalSectionInput {
  condition: String!
  description: String
  id: String!
}

"""Cursor for paging through collections"""
scalar ConnectionCursor

type ConversationHistoryVerification {
  """First message role"""
  firstRole: String

  """Whether any messages have empty content"""
  hasEmptyContent: Boolean!

  """Last message role"""
  lastRole: String

  """Whether message count matches between different queries"""
  messageCountMatches: Boolean!

  """Whether message order is valid"""
  orderValid: Boolean!
}

type ConversationMessagePreview {
  """Full message content"""
  content: String!

  """Content preview (first 100 chars)"""
  contentPreview: String!

  """Creation timestamp"""
  createdAt: String!

  """Message ID"""
  messageId: String!

  """Message role (USER or ASSISTANT)"""
  role: String!

  """Sequence order in conversation"""
  sequenceOrder: Float!
}

type ConversationRoleDistribution {
  """Number of assistant messages"""
  assistant: Float!

  """Number of user messages"""
  user: Float!
}

"""Type/level of court that issued the ruling"""
enum CourtType {
  ADMINISTRATIVE_COURT
  APPELLATE_COURT
  CONSTITUTIONAL_TRIBUNAL
  DISTRICT_COURT
  OTHER
  REGIONAL_COURT
  SUPREME_COURT
}

input CourtTypeFilterComparison {
  eq: CourtType
  gt: CourtType
  gte: CourtType
  iLike: CourtType
  in: [CourtType!]
  is: Boolean
  isNot: Boolean
  like: CourtType
  lt: CourtType
  lte: CourtType
  neq: CourtType
  notILike: CourtType
  notIn: [CourtType!]
  notLike: CourtType
}

input CreateAiUsageRecordInput {
  metadata: String
  operationType: AiOperationType!
  requestCount: Int = 1
  resourceId: ID
  tokensUsed: Int!
}

input CreateApiKeyInput {
  description: String
  expiresAt: String
  name: String!
  rateLimitPerMinute: Int = 60
  scopes: [ApiKeyScope!]!
}

type CreateApiKeyResponse {
  createdAt: String!
  description: String
  expiresAt: String
  id: ID!
  keyPrefix: String!
  name: String!
  rateLimitPerMinute: Int!
  rawKey: String!
  scopes: [ApiKeyScope!]!
  status: ApiKeyStatus!
  updatedAt: String!
}

input CreateBackupInput {
  """Description of the backup"""
  description: String

  """Optional custom name for the backup"""
  name: String

  """Tags for the backup"""
  tags: [String!]
}

input CreateChatSessionInput {
  """AI response mode for the session (LAWYER or SIMPLE)"""
  mode: ChatMode!
}

input CreateCitationInput {
  article: String
  excerpt: String
  source: String!
  url: String
}

input CreateClarificationSessionInput {
  """Initial context for the clarification session"""
  initialContext: [String!]

  """ID of the legal query that triggered clarification"""
  queryId: String!

  """Clarification questions to ask the user"""
  questions: [String!]!

  """Session ID for the user (optional)"""
  sessionId: String
}

input CreateCommentPositionInput {
  endOffset: Float!
  section: String
  startOffset: Float!
  text: String
}

input CreateDocumentCommentInput {
  authorId: String!
  documentId: String!
  position: CreateCommentPositionInput!
  resolutionStatus: CommentResolutionStatus = OPEN
  text: String!
}

input CreateDocumentMetadataInput {
  claimAmount: Float
  claimCurrency: String
  defendantName: String
  plaintiffName: String
}

input CreateDocumentTemplateInput {
  category: TemplateCategory!
  conditionalSections: [ConditionalSectionInput!]
  content: String!
  description: String
  isActive: Boolean = true
  name: String!
  polishFormattingRules: PolishFormattingRulesInput
  variables: [TemplateVariableInput!]!
}

input CreateDocumentVersionInput {
  authorUserId: ID
  changeDescription: String
  contentSnapshot: String!
  documentId: ID!
  sessionId: ID!
}

input CreateHubSpotContactInput {
  """Company name"""
  company: String

  """Company size"""
  companySize: String

  """Contact email address (required)"""
  email: String!

  """First name"""
  firstName: String

  """GDPR consent for data processing"""
  gdprConsent: Boolean

  """Job title"""
  jobTitle: String

  """Last name"""
  lastName: String

  """Additional message"""
  message: String

  """Phone number"""
  phone: String

  """Lead source"""
  source: String

  """Implementation timeline"""
  timeline: LeadTimeline

  """Use case description"""
  useCase: String

  """Company website"""
  website: String
}

input CreateInAppNotificationInput {
  """Optional action label for the action link button"""
  actionLabel: String

  """Optional action link for navigation (e.g., /documents/123)"""
  actionLink: String

  """The notification message content"""
  message: String!

  """Additional metadata for extensibility (JSON string)"""
  metadata: String

  """Read status - defaults to false (unread)"""
  read: Boolean

  """Type of notification for UI styling"""
  type: String

  """User ID to receive the notification"""
  userId: String!
}

input CreateLegalAnalysisInput {
  identifiedGrounds: [LegalGroundInput!]
  inputDescription: String!
  metadata: AnalysisMetadataInput
  relatedDocumentLinks: [RelatedDocumentLinkInput!]
  sessionId: String!
  title: String!
}

input CreateLegalDocumentInput {
  metadata: CreateDocumentMetadataInput
  sessionId: String!
  title: String!
  type: DocumentType! = OTHER
}

input CreateLegalDocumentInputV2 {
  content: String!
  documentType: DocumentTypeV2!

  """JSON metadata as string"""
  metadataJson: String
  ownerId: ID!
  title: String!
}

input CreateLegalQueryInput {
  answerMarkdown: String
  citations: [CreateCitationInput!]
  question: String!
  sessionId: String
}

input CreateLegalRulingInput {
  courtName: String!
  courtType: CourtType! = OTHER
  fullText: String
  metadata: CreateRulingMetadataInput
  rulingDate: String!
  signature: String!
  summary: String
}

input CreateNotificationInput {
  """Error message if sending failed"""
  errorMessage: String

  """SendGrid message ID"""
  messageId: String

  """Additional metadata (JSON string)"""
  metadata: String

  """Recipient email address"""
  recipientEmail: String!

  """Timestamp when email was sent"""
  sentAt: String

  """Notification status"""
  status: NotificationStatus = PENDING

  """Email subject line"""
  subject: String!

  """Email template type"""
  template: EmailTemplateType!

  """Template data for rendering (JSON string)"""
  templateData: String

  """User ID (if notification is for a registered user)"""
  userId: String
}

input CreateOneChatSessionInput {
  """The record to create"""
  chatSession: CreateChatSessionInput!
}

input CreateOneDocumentCommentInput {
  """The record to create"""
  documentComment: CreateDocumentCommentInput!
}

input CreateOneDocumentTemplateInput {
  """The record to create"""
  documentTemplate: CreateDocumentTemplateInput!
}

input CreateOneDocumentVersionInput {
  """The record to create"""
  documentVersion: CreateDocumentVersionInput!
}

input CreateOneInAppNotificationInput {
  """The record to create"""
  inAppNotification: CreateInAppNotificationInput!
}

input CreateOneLegalAnalysisInput {
  """The record to create"""
  legalAnalysis: CreateLegalAnalysisInput!
}

input CreateOneLegalDocumentInput {
  """The record to create"""
  legalDocument: CreateLegalDocumentInput!
}

input CreateOneLegalQueryInput {
  """The record to create"""
  legalQuery: CreateLegalQueryInput!
}

input CreateOneLegalRulingInput {
  """The record to create"""
  legalRuling: CreateLegalRulingInput!
}

input CreateOneNotificationInput {
  """The record to create"""
  notification: CreateNotificationInput!
}

input CreateOneUserPreferencesInput {
  """The record to create"""
  userPreferences: CreateUserPreferencesInput!
}

input CreateRulingMetadataInput {
  keywords: [String!]
  legalArea: String
  relatedCases: [String!]
  sourceReference: String
}

input CreateScheduleInput {
  """Action the schedule performs"""
  action: ScheduleActionInput!

  """Initial paused state"""
  paused: Boolean = false

  """Schedule behavior policies"""
  policies: SchedulePoliciesInput

  """Unique identifier for the schedule"""
  scheduleId: String!

  """Schedule specification (when it runs)"""
  spec: ScheduleSpecInput!
}

type CreateScheduleResult {
  """Message describing the creation result"""
  message: String

  """The ID of the created schedule"""
  scheduleId: ID!

  """Whether the creation was successful"""
  success: Boolean!
}

input CreateSubscriptionPlanInput {
  billingInterval: BillingInterval = MONTHLY
  description: String
  displayOrder: Int = 0
  features: String!
  maxUsers: Int
  name: String!
  price: Int!
  stripePriceId: String
  stripeYearlyPriceId: String
  tier: PlanTier!
  trialDays: Int = 0
  yearlyDiscount: Int = 0
}

input CreateTemplateInput {
  category: TemplateCategory!
  conditionalSections: JSON
  content: String!
  description: String
  isActive: Boolean = true
  name: String!
  polishFormattingRules: JSON
  variables: JSON!
}

input CreateUserInput {
  email: String!
  firstName: String
  isActive: Boolean
  lastName: String
  username: String
}

input CreateUserPreferencesInput {
  aiModel: AiModelType = GPT_4_TURBO
  dateFormat: String
  emailNotifications: Boolean = true
  inAppNotifications: Boolean = true
  locale: String = "en"
  notificationPreferences: NotificationPreferencesInput
  theme: ThemePreference = SYSTEM
  timezone: String
  userId: String!
}

input CreateUserSubscriptionInput {
  planId: ID!
  stripeCustomerId: String
  stripeSubscriptionId: String
}

input CreateWebhookInput {
  description: String
  events: [WebhookEvent!]!
  headers: String
  maxRetries: Int = 3
  name: String!
  timeoutMs: Int = 30000
  url: String!
}

type CreateWebhookResponse {
  createdAt: String!
  description: String
  events: [WebhookEvent!]!
  failureCount: Int!
  headers: String
  id: ID!
  lastDeliveryAt: String
  lastSuccessAt: String
  maxRetries: Int!
  name: String!
  secret: String!
  status: WebhookStatus!
  successCount: Int!
  timeoutMs: Int!
  updatedAt: String!
  url: String!
}

type CursorEventPayload {
  color: String
  documentId: ID!
  position: Float!
  selectionLength: Float!
  timestamp: DateTime!
  userId: ID!
  userName: String!
}

input CursorPaging {
  """Paginate after opaque cursor"""
  after: ConnectionCursor

  """Paginate before opaque cursor"""
  before: ConnectionCursor

  """Paginate first"""
  first: Int

  """Paginate last"""
  last: Int
}

type DailyUsage {
  date: DateTime!
  totalCost: Float!
  totalRequests: Int!
  totalTokens: Int!
}

type DailyUsageResponse {
  dailyUsage: [DailyUsage!]!
  periodEnd: DateTime!
  periodStart: DateTime!
  totalCost: Float!
  totalRequests: Int!
  totalTokens: Int!
}

input DashboardAnalyticsInput {
  endDate: DateTime
  period: AnalyticsPeriod = DAILY
  startDate: DateTime
}

input DateFieldComparison {
  between: DateFieldComparisonBetween
  eq: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  is: Boolean
  isNot: Boolean
  lt: DateTime
  lte: DateTime
  neq: DateTime
  notBetween: DateFieldComparisonBetween
  notIn: [DateTime!]
}

input DateFieldComparisonBetween {
  lower: DateTime!
  upper: DateTime!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input DeleteChatSessionInput {
  """Session ID to delete (soft delete)"""
  sessionId: ID!
}

type DeleteChatSessionResult {
  """Deletion type (hard or soft)"""
  deletionType: String!

  """Number of messages deleted with this session"""
  messageCount: Int!

  """The ID of the deleted session"""
  sessionId: ID!

  """Whether the deletion was successful"""
  success: Boolean!
}

input DeleteDocumentInputV2 {
  deletedBy: ID!
  documentId: ID!
  reason: String
}

input DeleteOneChatSessionInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteOneDocumentCommentInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteOneDocumentTemplateInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteOneInAppNotificationInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteOneLegalAnalysisInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteOneLegalDocumentInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteOneLegalQueryInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteOneLegalRulingInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteOneUserPreferencesInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteOneUserSessionInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteScheduleInput {
  """Confirmation that the user intends to delete the schedule"""
  confirm: Boolean! = false

  """Optional reason for deletion (logged to audit trail)"""
  reason: String

  """The ID of the schedule to delete"""
  scheduleId: String!
}

"""Webhook delivery status"""
enum DeliveryStatus {
  FAILED
  PENDING
  RETRYING
  SUCCESS
}

type DemoRequest {
  budget: String
  company: String
  companySize: CompanySizeEnum
  contactedAt: DateTime
  createdAt: DateTime!
  email: String!
  fullName: String!
  hubspotContactId: String
  id: ID!
  industry: String
  metadata: String
  preferredDemoTime: DateTime
  status: DemoRequestStatus!
  submittedAt: DateTime!
  timeline: String
  updatedAt: DateTime!
  useCase: String!
}

input DemoRequestAggregateFilter {
  and: [DemoRequestAggregateFilter!]
  email: StringFieldComparison
  id: IDFilterComparison
  or: [DemoRequestAggregateFilter!]
  status: DemoRequestStatusFilterComparison
}

type DemoRequestAggregateGroupBy {
  email: String
  id: ID
  status: DemoRequestStatus
}

type DemoRequestAggregateResponse {
  count: DemoRequestCountAggregate
  groupBy: DemoRequestAggregateGroupBy
  max: DemoRequestMaxAggregate
  min: DemoRequestMinAggregate
}

type DemoRequestAnalytics {
  """Company size distribution"""
  companySizeDistribution: [DemoRequestCompanySizeDistribution!]!
  generatedAt: DateTime!

  """Industry breakdown"""
  industryBreakdown: [DemoRequestIndustryBreakdown!]!

  """Lead source distribution"""
  leadSources: [DemoRequestLeadSource!]!
  metrics: DemoRequestMetrics!

  """Requests over time (by day)"""
  requestsOverTime: [DemoRequestTimeSeriesPoint!]!

  """Average response time metrics"""
  responseTimeMetrics: DemoRequestResponseTimeMetrics!

  """Status distribution for funnel visualization"""
  statusBreakdown: [DemoRequestStatusBreakdown!]!

  """Top mentioned use cases"""
  topUseCases: [DemoRequestTopUseCase!]!
}

type DemoRequestCompanySizeDistribution {
  companySize: String!
  count: Int!

  """Percentage of total"""
  percentage: Float!
}

type DemoRequestConnection {
  """Array of edges."""
  edges: [DemoRequestEdge!]!

  """Paging information"""
  pageInfo: PageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type DemoRequestCountAggregate {
  email: Int
  id: Int
  status: Int
}

type DemoRequestEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the DemoRequest"""
  node: DemoRequest!
}

input DemoRequestFilter {
  and: [DemoRequestFilter!]
  email: StringFieldComparison
  id: IDFilterComparison
  or: [DemoRequestFilter!]
  status: DemoRequestStatusFilterComparison
}

type DemoRequestIndustryBreakdown {
  count: Int!
  industry: String!

  """Percentage of total"""
  percentage: Float!
}

input DemoRequestInput {
  """Budget range for implementation"""
  budget: BudgetRange

  """Company name"""
  company: String!

  """Company size (number of employees)"""
  companySize: CompanySize!

  """Email address"""
  email: String!

  """Full name of the requester"""
  fullName: String!

  """Industry category"""
  industry: Industry!

  """Preferred time of day for demo"""
  preferredDemoTime: PreferredTimeSlot

  """Referrer URL for tracking"""
  referrer: String

  """Timeline for implementation"""
  timeline: DemoTimeline!

  """Specific use case or requirements"""
  useCase: String!

  """UTM campaign parameter for tracking"""
  utmCampaign: String

  """UTM content parameter for tracking"""
  utmContent: String

  """UTM medium parameter for tracking"""
  utmMedium: String

  """UTM source parameter for tracking"""
  utmSource: String

  """UTM term parameter for tracking"""
  utmTerm: String
}

type DemoRequestLeadSource {
  """Number of requests from this source"""
  count: Int!

  """UTM medium"""
  medium: String

  """Percentage of total"""
  percentage: Float!

  """
  UTM source or "direct"
  """
  source: String
}

type DemoRequestMaxAggregate {
  email: String
  id: ID
  status: DemoRequestStatus
}

type DemoRequestMetrics {
  """Requests closed (won or lost)"""
  closedRequests: Int!

  """Requests that have been contacted"""
  contactedRequests: Int!

  """Contacted to scheduled conversion rate %"""
  contactedToScheduledRate: Float!

  """New requests (not yet contacted)"""
  newRequests: Int!

  """New to contacted conversion rate %"""
  newToContactedRate: Float!

  """Overall funnel conversion rate %"""
  overallConversionRate: Float!
  periodEnd: DateTime!
  periodStart: DateTime!

  """Requests qualified as leads"""
  qualifiedRequests: Int!

  """Requests with demos scheduled"""
  scheduledRequests: Int!

  """Total demo requests in period"""
  totalRequests: Int!
}

type DemoRequestMinAggregate {
  email: String
  id: ID
  status: DemoRequestStatus
}

type DemoRequestResponse {
  """Confirmation message with next steps"""
  message: String!

  """Whether the lead was qualified for immediate follow-up"""
  qualified: Boolean

  """Unique reference ID for the request"""
  referenceId: String

  """Whether the request was submitted successfully"""
  success: Boolean!
}

type DemoRequestResponseTimeMetrics {
  """Average hours from submission to first contact"""
  avgHoursToContact: Float!
  calculatedAt: DateTime!

  """Median hours to contact"""
  medianHoursToContact: Float!

  """Total contacted requests measured"""
  totalContacted: Int!
}

input DemoRequestSort {
  direction: SortDirection!
  field: DemoRequestSortFields!
  nulls: SortNulls
}

enum DemoRequestSortFields {
  email
  id
  status
}

"""Demo request status in the sales pipeline"""
enum DemoRequestStatus {
  CLOSED
  CONTACTED
  NEW
  QUALIFIED
  SCHEDULED
}

type DemoRequestStatusBreakdown {
  count: Int!

  """Percentage of total"""
  percentage: Float!
  status: String!
}

input DemoRequestStatusFilterComparison {
  eq: DemoRequestStatus
  gt: DemoRequestStatus
  gte: DemoRequestStatus
  iLike: DemoRequestStatus
  in: [DemoRequestStatus!]
  is: Boolean
  isNot: Boolean
  like: DemoRequestStatus
  lt: DemoRequestStatus
  lte: DemoRequestStatus
  neq: DemoRequestStatus
  notILike: DemoRequestStatus
  notIn: [DemoRequestStatus!]
  notLike: DemoRequestStatus
}

type DemoRequestTimeSeriesPoint {
  count: Int!
  timestamp: DateTime!
}

type DemoRequestTopUseCase {
  """Number of similar requests"""
  count: Int!

  """Truncated use case text"""
  useCase: String!
}

"""Timeline preferences for demo"""
enum DemoTimeline {
  ASAP
  EXPLORING
  WITHIN_MONTH
  WITHIN_QUARTER
  WITHIN_WEEK
}

input DisableTwoFactorInput {
  """User password for confirmation"""
  password: String!
}

type DocumentActivityEntry {
  createdAt: DateTime!
  documentId: ID!

  """Document type"""
  documentType: String

  """Error message if failed"""
  errorMessage: String

  """The status of the document"""
  status: String!
  title: String!

  """When the status last changed"""
  updatedAt: DateTime!

  """User who owns the document"""
  userId: ID
}

type DocumentComment {
  author: User!
  authorId: String!
  createdAt: DateTime!
  document: LegalDocument!
  documentId: String!
  id: ID!
  position: CommentPosition!
  resolutionStatus: CommentResolutionStatus!
  resolvedAt: DateTime
  resolvedBy: ID
  text: String!
  updatedAt: DateTime!
}

input DocumentCommentAggregateFilter {
  and: [DocumentCommentAggregateFilter!]
  authorId: StringFieldComparison
  createdAt: DateFieldComparison
  documentId: StringFieldComparison
  id: IDFilterComparison
  or: [DocumentCommentAggregateFilter!]
  resolutionStatus: CommentResolutionStatusFilterComparison
  resolvedBy: IDFilterComparison
  text: StringFieldComparison
  updatedAt: DateFieldComparison
}

type DocumentCommentAggregateGroupBy {
  authorId: String
  createdAt(by: GroupBy! = DAY): DateTime
  documentId: String
  id: ID
  resolutionStatus: CommentResolutionStatus
  resolvedBy: ID
  text: String
  updatedAt(by: GroupBy! = DAY): DateTime
}

type DocumentCommentAggregateResponse {
  count: DocumentCommentCountAggregate
  groupBy: DocumentCommentAggregateGroupBy
  max: DocumentCommentMaxAggregate
  min: DocumentCommentMinAggregate
}

type DocumentCommentConnection {
  """Array of edges."""
  edges: [DocumentCommentEdge!]!

  """Paging information"""
  pageInfo: PageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type DocumentCommentCountAggregate {
  authorId: Int
  createdAt: Int
  documentId: Int
  id: Int
  resolutionStatus: Int
  resolvedBy: Int
  text: Int
  updatedAt: Int
}

type DocumentCommentDeleteResponse {
  authorId: String
  createdAt: DateTime
  documentId: String
  id: ID
  position: CommentPosition
  resolutionStatus: CommentResolutionStatus
  resolvedAt: DateTime
  resolvedBy: ID
  text: String
  updatedAt: DateTime
}

type DocumentCommentEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the DocumentComment"""
  node: DocumentComment!
}

input DocumentCommentFilter {
  and: [DocumentCommentFilter!]
  authorId: StringFieldComparison
  createdAt: DateFieldComparison
  documentId: StringFieldComparison
  id: IDFilterComparison
  or: [DocumentCommentFilter!]
  resolutionStatus: CommentResolutionStatusFilterComparison
  resolvedBy: IDFilterComparison
  text: StringFieldComparison
  updatedAt: DateFieldComparison
}

type DocumentCommentMaxAggregate {
  authorId: String
  createdAt: DateTime
  documentId: String
  id: ID
  resolutionStatus: CommentResolutionStatus
  resolvedBy: ID
  text: String
  updatedAt: DateTime
}

type DocumentCommentMinAggregate {
  authorId: String
  createdAt: DateTime
  documentId: String
  id: ID
  resolutionStatus: CommentResolutionStatus
  resolvedBy: ID
  text: String
  updatedAt: DateTime
}

input DocumentCommentSort {
  direction: SortDirection!
  field: DocumentCommentSortFields!
  nulls: SortNulls
}

enum DocumentCommentSortFields {
  authorId
  createdAt
  documentId
  id
  resolutionStatus
  resolvedBy
  text
  updatedAt
}

type DocumentEditEventPayload {
  documentId: ID!
  operation: String!
  timestamp: DateTime!
  userId: ID!
  userName: String!
  version: Float!
}

type DocumentGenerationMetrics {
  """Average generation time in seconds"""
  avgGenerationTime: Int!

  """Failed document generations"""
  failedDocuments: Int!
  periodEnd: DateTime!
  periodStart: DateTime!

  """Success rate as percentage"""
  successRate: Float!

  """Successfully generated documents"""
  successfulDocuments: Int!

  """Total documents generated"""
  totalDocuments: Int!
}

type DocumentMetadata {
  claimAmount: Float
  claimCurrency: String
  defendantName: String
  plaintiffName: String
}

input DocumentMetadataInput {
  claimAmount: Float
  claimCurrency: String
  defendantName: String
  plaintiffName: String
}

type DocumentMetrics {
  completedDocuments: Int!
  draftDocuments: Int!
  failedDocuments: Int!

  """Documents currently generating"""
  generatingDocuments: Int!
  periodEnd: DateTime!
  periodStart: DateTime!

  """Success rate as percentage"""
  successRate: Float!
  totalDocuments: Int!
}

type DocumentQueueMetrics {
  calculatedAt: DateTime!

  """Documents in COMPLETED status (total)"""
  completedCount: Int!

  """Documents currently in DRAFT status"""
  draftCount: Int!

  """Documents in FAILED status (total)"""
  failedCount: Int!

  """Documents currently in GENERATING status"""
  generatingCount: Int!
}

type DocumentShare {
  createdAt: DateTime!
  documentId: String!
  expiresAt: DateTime
  id: ID!
  permission: SharePermission!
  sharedByUserId: String!
  sharedWithUserId: String!
  updatedAt: DateTime!
}

"""Status of document generation"""
enum DocumentStatus {
  COMPLETED
  DRAFT
  FAILED
  GENERATING
}

type DocumentStatusChange {
  """ID of the document"""
  documentId: String!

  """Error message if status is FAILED"""
  error: String

  """Optional message describing the status change"""
  message: String

  """New status after the change"""
  newStatus: DocumentStatus!

  """Previous status before the change"""
  previousStatus: DocumentStatus!

  """ID of the session"""
  sessionId: String!

  """ISO timestamp of the status change"""
  timestamp: String!
}

input DocumentStatusFilterComparison {
  eq: DocumentStatus
  gt: DocumentStatus
  gte: DocumentStatus
  iLike: DocumentStatus
  in: [DocumentStatus!]
  is: Boolean
  isNot: Boolean
  like: DocumentStatus
  lt: DocumentStatus
  lte: DocumentStatus
  neq: DocumentStatus
  notILike: DocumentStatus
  notIn: [DocumentStatus!]
  notLike: DocumentStatus
}

"""Status of the document lifecycle"""
enum DocumentStatusV2 {
  APPROVED
  ARCHIVED
  DELETED
  DRAFT
  PENDING_REVIEW
  PUBLISHED
}

type DocumentTemplate {
  category: TemplateCategory!
  conditionalSections: JSON
  content: String!
  createdAt: DateTime!
  description: String
  id: ID!
  isActive: Boolean!
  name: String!
  polishFormattingRules: JSON
  updatedAt: DateTime!
  usageCount: Float!
  variables: JSON!
}

input DocumentTemplateAggregateFilter {
  and: [DocumentTemplateAggregateFilter!]
  category: TemplateCategoryFilterComparison
  createdAt: DateFieldComparison
  description: StringFieldComparison
  id: IDFilterComparison
  isActive: BooleanFieldComparison
  name: StringFieldComparison
  or: [DocumentTemplateAggregateFilter!]
  updatedAt: DateFieldComparison
}

type DocumentTemplateAggregateGroupBy {
  category: TemplateCategory
  createdAt(by: GroupBy! = DAY): DateTime
  description: String
  id: ID
  isActive: Boolean
  name: String
  updatedAt(by: GroupBy! = DAY): DateTime
}

type DocumentTemplateAggregateResponse {
  count: DocumentTemplateCountAggregate
  groupBy: DocumentTemplateAggregateGroupBy
  max: DocumentTemplateMaxAggregate
  min: DocumentTemplateMinAggregate
}

type DocumentTemplateConnection {
  """Array of edges."""
  edges: [DocumentTemplateEdge!]!

  """Paging information"""
  pageInfo: PageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type DocumentTemplateCountAggregate {
  category: Int
  createdAt: Int
  description: Int
  id: Int
  isActive: Int
  name: Int
  updatedAt: Int
}

type DocumentTemplateDeleteResponse {
  category: TemplateCategory
  conditionalSections: JSON
  content: String
  createdAt: DateTime
  description: String
  id: ID
  isActive: Boolean
  name: String
  polishFormattingRules: JSON
  updatedAt: DateTime
  usageCount: Float
  variables: JSON
}

type DocumentTemplateEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the DocumentTemplate"""
  node: DocumentTemplate!
}

input DocumentTemplateFilter {
  and: [DocumentTemplateFilter!]
  category: TemplateCategoryFilterComparison
  createdAt: DateFieldComparison
  description: StringFieldComparison
  id: IDFilterComparison
  isActive: BooleanFieldComparison
  name: StringFieldComparison
  or: [DocumentTemplateFilter!]
  updatedAt: DateFieldComparison
}

type DocumentTemplateMaxAggregate {
  category: TemplateCategory
  createdAt: DateTime
  description: String
  id: ID
  name: String
  updatedAt: DateTime
}

type DocumentTemplateMinAggregate {
  category: TemplateCategory
  createdAt: DateTime
  description: String
  id: ID
  name: String
  updatedAt: DateTime
}

input DocumentTemplateSort {
  direction: SortDirection!
  field: DocumentTemplateSortFields!
  nulls: SortNulls
}

enum DocumentTemplateSortFields {
  category
  createdAt
  description
  id
  isActive
  name
  updatedAt
}

"""Type of legal document"""
enum DocumentType {
  COMPLAINT
  CONTRACT
  LAWSUIT
  OTHER
}

type DocumentTypeDistribution {
  count: Int!
  documentType: String!

  """Percentage of total"""
  percentage: Float!
}

input DocumentTypeFilterComparison {
  eq: DocumentType
  gt: DocumentType
  gte: DocumentType
  iLike: DocumentType
  in: [DocumentType!]
  is: Boolean
  isNot: Boolean
  like: DocumentType
  lt: DocumentType
  lte: DocumentType
  neq: DocumentType
  notILike: DocumentType
  notIn: [DocumentType!]
  notLike: DocumentType
}

"""Type of legal document"""
enum DocumentTypeV2 {
  AGREEMENT
  CONTRACT
  COURT_RULING
  LEGAL_OPINION
  OTHER
  POLICY
  REGULATION
  STATUTE
}

type DocumentVersion {
  authorUserId: String
  changeDescription: String
  contentSnapshot: String!
  createdAt: DateTime!
  document: LegalDocument!
  documentId: String!
  id: ID!
  session: UserSession!
  sessionId: String!
  versionNumber: Float!
}

input DocumentVersionAggregateFilter {
  and: [DocumentVersionAggregateFilter!]
  authorUserId: StringFieldComparison
  createdAt: DateFieldComparison
  documentId: StringFieldComparison
  id: IDFilterComparison
  or: [DocumentVersionAggregateFilter!]
  sessionId: StringFieldComparison
  versionNumber: NumberFieldComparison
}

type DocumentVersionAggregateGroupBy {
  authorUserId: String
  createdAt(by: GroupBy! = DAY): DateTime
  documentId: String
  id: ID
  sessionId: String
  versionNumber: Float
}

type DocumentVersionAggregateResponse {
  avg: DocumentVersionAvgAggregate
  count: DocumentVersionCountAggregate
  groupBy: DocumentVersionAggregateGroupBy
  max: DocumentVersionMaxAggregate
  min: DocumentVersionMinAggregate
  sum: DocumentVersionSumAggregate
}

type DocumentVersionAvgAggregate {
  versionNumber: Float
}

type DocumentVersionConnection {
  """Array of edges."""
  edges: [DocumentVersionEdge!]!

  """Paging information"""
  pageInfo: PageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type DocumentVersionCountAggregate {
  authorUserId: Int
  createdAt: Int
  documentId: Int
  id: Int
  sessionId: Int
  versionNumber: Int
}

type DocumentVersionEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the DocumentVersion"""
  node: DocumentVersion!
}

input DocumentVersionFilter {
  and: [DocumentVersionFilter!]
  authorUserId: StringFieldComparison
  createdAt: DateFieldComparison
  documentId: StringFieldComparison
  id: IDFilterComparison
  or: [DocumentVersionFilter!]
  sessionId: StringFieldComparison
  versionNumber: NumberFieldComparison
}

type DocumentVersionMaxAggregate {
  authorUserId: String
  createdAt: DateTime
  documentId: String
  id: ID
  sessionId: String
  versionNumber: Float
}

type DocumentVersionMinAggregate {
  authorUserId: String
  createdAt: DateTime
  documentId: String
  id: ID
  sessionId: String
  versionNumber: Float
}

input DocumentVersionSort {
  direction: SortDirection!
  field: DocumentVersionSortFields!
  nulls: SortNulls
}

enum DocumentVersionSortFields {
  authorUserId
  createdAt
  documentId
  id
  sessionId
  versionNumber
}

type DocumentVersionSumAggregate {
  versionNumber: Float
}

"""Email template types available in the system"""
enum EmailTemplateType {
  DEMO_REQUEST_CONFIRMATION
  DOCUMENT_COMPLETED
  DOCUMENT_FAILED
  INTEREST_CONFIRMATION
  SYSTEM_NOTIFICATION
  WELCOME
}

input EmailTemplateTypeFilterComparison {
  eq: EmailTemplateType
  gt: EmailTemplateType
  gte: EmailTemplateType
  iLike: EmailTemplateType
  in: [EmailTemplateType!]
  is: Boolean
  isNot: Boolean
  like: EmailTemplateType
  lt: EmailTemplateType
  lte: EmailTemplateType
  neq: EmailTemplateType
  notILike: EmailTemplateType
  notIn: [EmailTemplateType!]
  notLike: EmailTemplateType
}

type EmptyMessageAnalysis {
  """Content field value (should be empty)"""
  content: String

  """Timestamp when the message was created"""
  createdAt: String!

  """Whether metadata contains clarification data"""
  hasClarificationMetadata: Boolean!

  """Whether rawContent has data that can be recovered"""
  hasRecoverableRawContent: Boolean!

  """The message ID"""
  messageId: ID!

  """Raw content field value (may have data)"""
  rawContent: String

  """Message role"""
  role: MessageRole!

  """Sequence order in the conversation"""
  sequenceOrder: Int!

  """The session ID"""
  sessionId: ID!

  """The user ID"""
  userId: ID!
}

type EmptyMessagesSummary {
  """Number of affected sessions"""
  affectedSessions: Int!

  """Number of affected users"""
  affectedUsers: Int!

  """List of empty messages found"""
  messages: [EmptyMessageAnalysis!]!

  """Number of messages with recoverable rawContent"""
  recoverableFromRawContent: Int!

  """Total number of empty assistant messages found"""
  totalEmptyMessages: Int!

  """Number of messages that are truly empty (both content and rawContent)"""
  trulyEmpty: Int!

  """Number of messages with clarification metadata"""
  withClarificationMetadata: Int!
}

type EmptySessionAnalysis {
  """Timestamp when the session was created"""
  createdAt: String!

  """Chat mode (LAWYER or SIMPLE)"""
  mode: String!

  """The session ID"""
  sessionId: ID!

  """Session title (should be null for empty sessions)"""
  title: String

  """The user ID"""
  userId: ID!
}

type EmptySessionsMetrics {
  """Threshold for alerting (null = no threshold set)"""
  alertThreshold: Int

  """Current count of empty sessions in the database"""
  count: Int!

  """Whether the count exceeds the alert threshold"""
  requiresAttention: Boolean!

  """ISO timestamp of when this metric was collected"""
  timestamp: String!
}

type EnableTwoFactorResponse {
  """Backup codes for account recovery (show only once)"""
  backupCodes: [String!]!

  """QR code as base64 data URL for scanning"""
  qrCodeDataUrl: String!

  """The TOTP secret key for storing in authenticator app"""
  secret: String!
}

type ErrorSummary {
  count: Float!
  message: String!
  timestamp: String!
  type: String!
}

type ErrorTrackingStatus {
  criticalErrors: Float!
  lastError: ErrorSummary
  recentErrors: Float!
  totalErrors: Float!
}

input ExportChatSessionInput {
  """Optional custom filename (without extension)"""
  filename: String

  """Export format (PDF, MARKDOWN, or JSON)"""
  format: ChatExportFormat!

  """ID of the chat session to export"""
  sessionId: ID!
}

input ExportDocumentToPdfInput {
  """ID of the document to export"""
  documentId: ID!

  """PDF export options"""
  options: PdfExportOptionsInput
}

input FilterLegalRulingsInput {
  """Filter by court name (partial match)"""
  courtName: String

  """Filter by court type"""
  courtType: CourtType

  """Filter by ruling date from (ISO 8601 date string)"""
  dateFrom: String

  """Filter by ruling date to (ISO 8601 date string)"""
  dateTo: String

  """Filter by legal area from metadata (partial match)"""
  legalArea: String

  """Maximum number of results to return (default: 20, max: 100)"""
  limit: Int = 20

  """Number of results to skip for pagination"""
  offset: Int = 0
}

input FlagDocumentForModerationInput {
  """Document ID to flag for moderation"""
  documentId: ID!

  """Reason for flagging the document"""
  reason: String
}

input GenerateDocumentInput {
  metadata: DocumentMetadataInput
  sessionId: String!
  title: String!
  type: DocumentType! = OTHER
}

input GenerateFromTemplateInput {
  sessionId: String!
  templateId: String!
  title: String!
  variables: JSON!
}

"""Group by"""
enum GroupBy {
  DAY
  MONTH
  WEEK
  YEAR
}

type HubSpotContactResponse {
  """When the contact was created"""
  createdAt: String!

  """Contact email"""
  email: String!

  """HubSpot contact ID"""
  id: String!
}

input IDFilterComparison {
  eq: ID
  gt: ID
  gte: ID
  iLike: ID
  in: [ID!]
  is: Boolean
  isNot: Boolean
  like: ID
  lt: ID
  lte: ID
  neq: ID
  notILike: ID
  notIn: [ID!]
  notLike: ID
}

type InAppNotification {
  actionLabel: String
  actionLink: String
  createdAt: DateTime!
  id: ID!
  message: String!
  metadata: JSON
  read: Boolean!
  type: InAppNotificationType!
  user: User!
  userId: String!
}

input InAppNotificationAggregateFilter {
  and: [InAppNotificationAggregateFilter!]
  createdAt: DateFieldComparison
  id: IDFilterComparison
  message: StringFieldComparison
  or: [InAppNotificationAggregateFilter!]
  read: BooleanFieldComparison
  type: InAppNotificationTypeFilterComparison
  userId: StringFieldComparison
}

type InAppNotificationAggregateGroupBy {
  createdAt(by: GroupBy! = DAY): DateTime
  id: ID
  message: String
  read: Boolean
  type: InAppNotificationType
  userId: String
}

type InAppNotificationAggregateResponse {
  count: InAppNotificationCountAggregate
  groupBy: InAppNotificationAggregateGroupBy
  max: InAppNotificationMaxAggregate
  min: InAppNotificationMinAggregate
}

type InAppNotificationConnection {
  """Array of edges."""
  edges: [InAppNotificationEdge!]!

  """Paging information"""
  pageInfo: PageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type InAppNotificationCountAggregate {
  createdAt: Int
  id: Int
  message: Int
  read: Int
  type: Int
  userId: Int
}

type InAppNotificationCreatedPayload {
  """Optional action label for the action link"""
  actionLabel: String

  """Optional action link for navigation"""
  actionLink: String

  """Creation timestamp"""
  createdAt: DateTime!

  """Notification message"""
  message: String!

  """Additional metadata"""
  metadata: String

  """Notification ID"""
  notificationId: ID!

  """Type of notification"""
  type: InAppNotificationType!

  """User ID who received the notification"""
  userId: ID!
}

type InAppNotificationDeleteResponse {
  actionLabel: String
  actionLink: String
  createdAt: DateTime
  id: ID
  message: String
  metadata: JSON
  read: Boolean
  type: InAppNotificationType
  userId: String
}

type InAppNotificationEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the InAppNotification"""
  node: InAppNotification!
}

input InAppNotificationFilter {
  and: [InAppNotificationFilter!]
  createdAt: DateFieldComparison
  id: IDFilterComparison
  message: StringFieldComparison
  or: [InAppNotificationFilter!]
  read: BooleanFieldComparison
  type: InAppNotificationTypeFilterComparison
  userId: StringFieldComparison
}

type InAppNotificationMaxAggregate {
  createdAt: DateTime
  id: ID
  message: String
  type: InAppNotificationType
  userId: String
}

type InAppNotificationMinAggregate {
  createdAt: DateTime
  id: ID
  message: String
  type: InAppNotificationType
  userId: String
}

input InAppNotificationSort {
  direction: SortDirection!
  field: InAppNotificationSortFields!
  nulls: SortNulls
}

enum InAppNotificationSortFields {
  createdAt
  id
  message
  read
  type
  userId
}

"""Types of in-app notifications"""
enum InAppNotificationType {
  ERROR
  INFO
  SUCCESS
  SYSTEM
  WARNING
}

input InAppNotificationTypeFilterComparison {
  eq: InAppNotificationType
  gt: InAppNotificationType
  gte: InAppNotificationType
  iLike: InAppNotificationType
  in: [InAppNotificationType!]
  is: Boolean
  isNot: Boolean
  like: InAppNotificationType
  lt: InAppNotificationType
  lte: InAppNotificationType
  neq: InAppNotificationType
  notILike: InAppNotificationType
  notIn: [InAppNotificationType!]
  notLike: InAppNotificationType
}

"""Industry categories"""
enum Industry {
  CONSULTING
  FINANCE
  GOVERNMENT
  HEALTHCARE
  LAW_FIRM
  LEGAL_DEPARTMENT
  OTHER
  REAL_ESTATE
  TECHNOLOGY
}

input InterestRequestInput {
  """Company name"""
  company: String

  """GDPR consent checkbox"""
  consent: Boolean!

  """Email address"""
  email: String!

  """Full name of the requester"""
  fullName: String!

  """How they heard about us (lead source)"""
  leadSource: String

  """Job role or position"""
  role: String

  """Specific use case or requirements"""
  useCase: String
}

type InterestRequestResponse {
  """Confirmation message with next steps"""
  message: String!

  """Unique reference ID for the request"""
  referenceId: String

  """Whether the request was submitted successfully"""
  success: Boolean!
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

type LangfuseDebugConfig {
  """Base URL for Langfuse dashboard"""
  dashboardUrl: String

  """Whether Langfuse integration is enabled"""
  enabled: Boolean!

  """Langfuse host URL"""
  hostUrl: String

  """Langfuse trace URL template (use {traceId} as placeholder)"""
  traceUrlTemplate: String
}

type LangfuseTrace {
  """Type of agent or workflow"""
  agentType: AgentType!

  """Duration in milliseconds"""
  duration: Float

  """Timestamp when trace ended"""
  endTime: Timestamp

  """Unique trace ID"""
  id: ID!

  """Trace level"""
  level: TraceLevel

  """Metadata associated with the trace"""
  metadata: JSON

  """Model used for the trace"""
  model: String!

  """Trace name (operation name)"""
  name: String!

  """Number of observations (spans/generations) in the trace"""
  observationCount: Int!

  """Session ID associated with the trace"""
  sessionId: String!

  """Timestamp when trace started"""
  startTime: Timestamp

  """Trace status"""
  status: TraceStatus!

  """Timestamp when trace was created"""
  timestamp: Timestamp!

  """Token usage details"""
  usage: TokenUsage

  """User ID associated with the trace"""
  userId: String!
}

type LangfuseTraceDetail {
  """Type of agent or workflow"""
  agentType: AgentType!

  """Duration in milliseconds"""
  duration: Float

  """Timestamp when trace ended"""
  endTime: Timestamp

  """Error message if trace failed"""
  errorMessage: String!

  """When this data was fetched"""
  fetchedAt: Timestamp!

  """Unique trace ID"""
  id: ID!

  """Trace level"""
  level: TraceLevel

  """Metadata associated with the trace"""
  metadata: JSON

  """Model used for the trace"""
  model: String!

  """Trace name (operation name)"""
  name: String!

  """All observations within the trace"""
  observations: [TraceObservation!]!

  """Session ID associated with the trace"""
  sessionId: String!

  """Stack trace if trace failed"""
  stackTrace: String!

  """Timestamp when trace started"""
  startTime: Timestamp

  """Trace status"""
  status: TraceStatus!

  """Timestamp when trace was created"""
  timestamp: Timestamp!

  """Aggregated token usage"""
  usage: TokenUsage

  """User email if available"""
  userEmail: String!

  """User ID associated with the trace"""
  userId: String!
}

type LeadQualificationResponse {
  """Whether the lead is qualified"""
  qualified: Boolean!

  """Reason for qualification status"""
  reason: String

  """Lead qualification score"""
  score: Float!
}

"""Timeline for lead implementation"""
enum LeadTimeline {
  EXPLORING
  IMMEDIATE
  WITHIN_MONTH
  WITHIN_QUARTER
}

input LegacyClarificationQuestionInput {
  hint: String
  options: [String!]
  question: String!
  question_type: String!
}

type LegalAnalysis {
  createdAt: DateTime!
  errorMessage: String
  id: ID!
  identifiedGrounds: [LegalGround!]
  inputDescription: String!
  metadata: AnalysisMetadata
  overallConfidenceScore: Float
  recommendations: String
  relatedDocumentLinks: [RelatedDocumentLink!]
  session: UserSession!
  sessionId: String!
  status: AnalysisStatus!
  summary: String
  title: String!
  updatedAt: DateTime!
}

input LegalAnalysisAggregateFilter {
  and: [LegalAnalysisAggregateFilter!]
  createdAt: DateFieldComparison
  id: IDFilterComparison
  or: [LegalAnalysisAggregateFilter!]
  sessionId: StringFieldComparison
  status: AnalysisStatusFilterComparison
  title: StringFieldComparison
  updatedAt: DateFieldComparison
}

type LegalAnalysisAggregateGroupBy {
  createdAt(by: GroupBy! = DAY): DateTime
  id: ID
  sessionId: String
  status: AnalysisStatus
  title: String
  updatedAt(by: GroupBy! = DAY): DateTime
}

type LegalAnalysisAggregateResponse {
  count: LegalAnalysisCountAggregate
  groupBy: LegalAnalysisAggregateGroupBy
  max: LegalAnalysisMaxAggregate
  min: LegalAnalysisMinAggregate
}

type LegalAnalysisConnection {
  """Array of edges."""
  edges: [LegalAnalysisEdge!]!

  """Paging information"""
  pageInfo: PageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type LegalAnalysisCountAggregate {
  createdAt: Int
  id: Int
  sessionId: Int
  status: Int
  title: Int
  updatedAt: Int
}

type LegalAnalysisDeleteResponse {
  createdAt: DateTime
  errorMessage: String
  id: ID
  identifiedGrounds: [LegalGround!]
  inputDescription: String
  metadata: AnalysisMetadata
  overallConfidenceScore: Float
  recommendations: String
  relatedDocumentLinks: [RelatedDocumentLink!]
  sessionId: String
  status: AnalysisStatus
  summary: String
  title: String
  updatedAt: DateTime
}

type LegalAnalysisEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the LegalAnalysis"""
  node: LegalAnalysis!
}

input LegalAnalysisFilter {
  and: [LegalAnalysisFilter!]
  createdAt: DateFieldComparison
  id: IDFilterComparison
  or: [LegalAnalysisFilter!]
  sessionId: StringFieldComparison
  status: AnalysisStatusFilterComparison
  title: StringFieldComparison
  updatedAt: DateFieldComparison
}

type LegalAnalysisMaxAggregate {
  createdAt: DateTime
  id: ID
  sessionId: String
  status: AnalysisStatus
  title: String
  updatedAt: DateTime
}

type LegalAnalysisMinAggregate {
  createdAt: DateTime
  id: ID
  sessionId: String
  status: AnalysisStatus
  title: String
  updatedAt: DateTime
}

input LegalAnalysisSort {
  direction: SortDirection!
  field: LegalAnalysisSortFields!
  nulls: SortNulls
}

enum LegalAnalysisSortFields {
  createdAt
  id
  sessionId
  status
  title
  updatedAt
}

type LegalDocument {
  contentRaw: String
  createdAt: DateTime!

  """When the document was flagged for moderation"""
  flaggedAt: DateTime
  id: ID!
  metadata: DocumentMetadata

  """When the document was moderated"""
  moderatedAt: DateTime

  """ID of the admin who moderated this document"""
  moderatedById: ID

  """Reason for moderation decision"""
  moderationReason: String

  """Moderation status of the document"""
  moderationStatus: ModerationStatus
  pdfUrl: String
  session: UserSession!
  sessionId: String!
  status: DocumentStatus!
  title: String!
  type: DocumentType!
  updatedAt: DateTime!
}

input LegalDocumentAggregateFilter {
  and: [LegalDocumentAggregateFilter!]
  createdAt: DateFieldComparison
  id: IDFilterComparison
  moderationStatus: ModerationStatusFilterComparison
  or: [LegalDocumentAggregateFilter!]
  sessionId: StringFieldComparison
  status: DocumentStatusFilterComparison
  title: StringFieldComparison
  type: DocumentTypeFilterComparison
  updatedAt: DateFieldComparison
}

type LegalDocumentAggregateGroupBy {
  createdAt(by: GroupBy! = DAY): DateTime
  id: ID
  moderationStatus: ModerationStatus
  sessionId: String
  status: DocumentStatus
  title: String
  type: DocumentType
  updatedAt(by: GroupBy! = DAY): DateTime
}

type LegalDocumentAggregateResponse {
  count: LegalDocumentCountAggregate
  groupBy: LegalDocumentAggregateGroupBy
  max: LegalDocumentMaxAggregate
  min: LegalDocumentMinAggregate
}

type LegalDocumentConnection {
  """Array of edges."""
  edges: [LegalDocumentEdge!]!

  """Paging information"""
  pageInfo: PageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type LegalDocumentCountAggregate {
  createdAt: Int
  id: Int
  moderationStatus: Int
  sessionId: Int
  status: Int
  title: Int
  type: Int
  updatedAt: Int
}

type LegalDocumentDeleteResponse {
  contentRaw: String
  createdAt: DateTime

  """When the document was flagged for moderation"""
  flaggedAt: DateTime
  id: ID
  metadata: DocumentMetadata

  """When the document was moderated"""
  moderatedAt: DateTime

  """ID of the admin who moderated this document"""
  moderatedById: ID

  """Reason for moderation decision"""
  moderationReason: String

  """Moderation status of the document"""
  moderationStatus: ModerationStatus

  """Signed URL to download the PDF version of this document"""
  pdfUrl: String
  sessionId: String
  status: DocumentStatus
  title: String
  type: DocumentType
  updatedAt: DateTime
}

type LegalDocumentEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the LegalDocument"""
  node: LegalDocument!
}

input LegalDocumentFilter {
  and: [LegalDocumentFilter!]
  createdAt: DateFieldComparison
  id: IDFilterComparison
  moderationStatus: ModerationStatusFilterComparison
  or: [LegalDocumentFilter!]
  sessionId: StringFieldComparison
  status: DocumentStatusFilterComparison
  title: StringFieldComparison
  type: DocumentTypeFilterComparison
  updatedAt: DateFieldComparison
}

type LegalDocumentMaxAggregate {
  createdAt: DateTime
  id: ID
  moderationStatus: ModerationStatus
  sessionId: String
  status: DocumentStatus
  title: String
  type: DocumentType
  updatedAt: DateTime
}

type LegalDocumentMinAggregate {
  createdAt: DateTime
  id: ID
  moderationStatus: ModerationStatus
  sessionId: String
  status: DocumentStatus
  title: String
  type: DocumentType
  updatedAt: DateTime
}

type LegalDocumentSearchResponse {
  count: Int!
  hasMore: Boolean!
  offset: Int!
  results: [LegalDocumentSearchResult!]!
  totalCount: Int!
}

type LegalDocumentSearchResult {
  contentRaw: String
  createdAt: DateTime!

  """Highlighted snippet of matching content"""
  headline: String
  id: String!
  pdfUrl: String

  """Relevance ranking score (higher is more relevant)"""
  rank: Float!
  sessionId: String!
  status: DocumentStatus!
  title: String!
  type: DocumentType!
  updatedAt: DateTime!
}

input LegalDocumentSort {
  direction: SortDirection!
  field: LegalDocumentSortFields!
  nulls: SortNulls
}

enum LegalDocumentSortFields {
  createdAt
  id
  moderationStatus
  sessionId
  status
  title
  type
  updatedAt
}

type LegalDocumentV2 {
  content: String!
  createdAt: DateTime!
  documentType: DocumentTypeV2!
  id: ID!

  """JSON metadata as string"""
  metadataJson: String
  ownerId: ID!
  status: DocumentStatusV2!
  title: String!
  updatedAt: DateTime!
  version: Float!
}

type LegalGround {
  confidenceScore: Float!
  description: String!
  legalBasis: [String!]
  name: String!
  notes: String
}

input LegalGroundInput {
  confidenceScore: Float!
  description: String!
  legalBasis: [String!]
  name: String!
  notes: String
}

type LegalQuery {
  answerMarkdown: String
  citations: [Citation!]
  clarificationInfo: ClarificationInfo
  confidence: Float
  createdAt: DateTime!
  id: ID!
  keyTerms: [String!]
  queryType: String
  question: String!
  session: UserSession!
  sessionId: ID
  updatedAt: DateTime!
}

input LegalQueryAggregateFilter {
  and: [LegalQueryAggregateFilter!]
  createdAt: DateFieldComparison
  id: IDFilterComparison
  or: [LegalQueryAggregateFilter!]
  question: StringFieldComparison
  sessionId: IDFilterComparison
  updatedAt: DateFieldComparison
}

type LegalQueryAggregateGroupBy {
  createdAt(by: GroupBy! = DAY): DateTime
  id: ID
  question: String
  sessionId: ID
  updatedAt(by: GroupBy! = DAY): DateTime
}

type LegalQueryAggregateResponse {
  count: LegalQueryCountAggregate
  groupBy: LegalQueryAggregateGroupBy
  max: LegalQueryMaxAggregate
  min: LegalQueryMinAggregate
}

type LegalQueryConnection {
  """Array of edges."""
  edges: [LegalQueryEdge!]!

  """Paging information"""
  pageInfo: PageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type LegalQueryCountAggregate {
  createdAt: Int
  id: Int
  question: Int
  sessionId: Int
  updatedAt: Int
}

type LegalQueryDeleteResponse {
  answerMarkdown: String
  citations: [Citation!]
  clarificationInfo: ClarificationInfo
  confidence: Float
  createdAt: DateTime
  id: ID
  keyTerms: [String!]
  queryType: String
  question: String
  sessionId: ID
  updatedAt: DateTime
}

type LegalQueryEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the LegalQuery"""
  node: LegalQuery!
}

input LegalQueryFilter {
  and: [LegalQueryFilter!]
  createdAt: DateFieldComparison
  id: IDFilterComparison
  or: [LegalQueryFilter!]
  question: StringFieldComparison
  sessionId: IDFilterComparison
  updatedAt: DateFieldComparison
}

type LegalQueryMaxAggregate {
  createdAt: DateTime
  id: ID
  question: String
  sessionId: ID
  updatedAt: DateTime
}

type LegalQueryMinAggregate {
  createdAt: DateTime
  id: ID
  question: String
  sessionId: ID
  updatedAt: DateTime
}

type LegalQuerySearchResponse {
  count: Int!
  hasMore: Boolean!
  offset: Int!
  results: [LegalQuerySearchResult!]!
  totalCount: Int!
}

type LegalQuerySearchResult {
  answerMarkdown: String
  createdAt: DateTime!

  """Highlighted snippet of matching content"""
  headline: String
  id: String!
  question: String!

  """Relevance ranking score (higher is more relevant)"""
  rank: Float!
  sessionId: String
  updatedAt: DateTime!
}

input LegalQuerySort {
  direction: SortDirection!
  field: LegalQuerySortFields!
  nulls: SortNulls
}

enum LegalQuerySortFields {
  createdAt
  id
  question
  sessionId
  updatedAt
}

type LegalRuling {
  courtName: String!
  courtType: CourtType!
  createdAt: DateTime!
  fullText: String
  id: ID!
  metadata: RulingMetadata
  rulingDate: DateTime!
  signature: String!
  summary: String
  updatedAt: DateTime!
}

input LegalRulingAggregateFilter {
  and: [LegalRulingAggregateFilter!]
  courtName: StringFieldComparison
  courtType: CourtTypeFilterComparison
  createdAt: DateFieldComparison
  id: IDFilterComparison
  or: [LegalRulingAggregateFilter!]
  rulingDate: DateFieldComparison
  signature: StringFieldComparison
  updatedAt: DateFieldComparison
}

type LegalRulingAggregateGroupBy {
  courtName: String
  courtType: CourtType
  createdAt(by: GroupBy! = DAY): DateTime
  id: ID
  rulingDate(by: GroupBy! = DAY): DateTime
  signature: String
  updatedAt(by: GroupBy! = DAY): DateTime
}

type LegalRulingAggregateResponse {
  count: LegalRulingCountAggregate
  groupBy: LegalRulingAggregateGroupBy
  max: LegalRulingMaxAggregate
  min: LegalRulingMinAggregate
}

type LegalRulingConnection {
  """Array of edges."""
  edges: [LegalRulingEdge!]!

  """Paging information"""
  pageInfo: PageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type LegalRulingCountAggregate {
  courtName: Int
  courtType: Int
  createdAt: Int
  id: Int
  rulingDate: Int
  signature: Int
  updatedAt: Int
}

type LegalRulingDeleteResponse {
  courtName: String
  courtType: CourtType
  createdAt: DateTime
  fullText: String
  id: ID
  metadata: RulingMetadata
  rulingDate: DateTime
  signature: String
  summary: String
  updatedAt: DateTime
}

type LegalRulingEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the LegalRuling"""
  node: LegalRuling!
}

input LegalRulingFilter {
  and: [LegalRulingFilter!]
  courtName: StringFieldComparison
  courtType: CourtTypeFilterComparison
  createdAt: DateFieldComparison
  id: IDFilterComparison
  or: [LegalRulingFilter!]
  rulingDate: DateFieldComparison
  signature: StringFieldComparison
  updatedAt: DateFieldComparison
}

type LegalRulingMaxAggregate {
  courtName: String
  courtType: CourtType
  createdAt: DateTime
  id: ID
  rulingDate: DateTime
  signature: String
  updatedAt: DateTime
}

type LegalRulingMinAggregate {
  courtName: String
  courtType: CourtType
  createdAt: DateTime
  id: ID
  rulingDate: DateTime
  signature: String
  updatedAt: DateTime
}

type LegalRulingSearchResponse {
  """Number of results returned"""
  count: Int!

  """Whether there are more results"""
  hasMore: Boolean!

  """Current offset"""
  offset: Int!

  """Search results with relevance ranking"""
  results: [LegalRulingSearchResult!]!

  """Total number of matching results (for pagination)"""
  totalCount: Int!
}

type LegalRulingSearchResult {
  """Highlighted snippet of matching content"""
  headline: String

  """Relevance score (higher is better)"""
  rank: Float!

  """The matching legal ruling"""
  ruling: LegalRuling!
}

input LegalRulingSort {
  direction: SortDirection!
  field: LegalRulingSortFields!
  nulls: SortNulls
}

enum LegalRulingSortFields {
  courtName
  courtType
  createdAt
  id
  rulingDate
  signature
  updatedAt
}

type LocalStorageMigrationStatus {
  """Whether the user has completed migration"""
  hasMigrated: Boolean!

  """Timestamp of last migration attempt"""
  lastMigrationAt: String

  """Number of sessions migrated"""
  sessionsMigrated: Int!
}

input LoginInput {
  """Backup code for account recovery (alternative to TOTP token)"""
  backupCode: String

  """User password"""
  password: String!

  """6-digit TOTP token (if 2FA is enabled)"""
  twoFactorToken: String

  """Username or email address"""
  username: String!
}

"""The role of the message sender"""
enum MessageRole {
  ASSISTANT
  SYSTEM
  USER
}

input MigrateChatBulkInput {
  """Sessions to migrate"""
  sessions: [MigrateChatSessionInput!]!

  """Skip sessions that already exist in the database"""
  skipDuplicates: Boolean = false
}

type MigrateChatBulkResult {
  """Number of failed migrations"""
  failedCount: Int!

  """Results for each session migration attempt"""
  results: [MigrateChatSessionResult!]!

  """Number of successfully migrated sessions"""
  successfulCount: Int!

  """Total number of messages migrated"""
  totalMessagesMigrated: Int!

  """Total number of sessions processed"""
  totalProcessed: Int!
}

input MigrateChatCitationInput {
  """Article or section reference"""
  article: String

  """Brief excerpt or description"""
  excerpt: String

  """Source of the citation"""
  source: String!

  """URL to the source document"""
  url: String
}

input MigrateChatMessageWithCitationsInput {
  """Citations for assistant messages"""
  citations: [MigrateChatCitationInput!]

  """Message content"""
  content: String!

  """Original content before AI processing"""
  rawContent: String

  """Role of the message sender"""
  role: MessageRole!

  """ISO timestamp of when the message was created"""
  timestamp: String
}

input MigrateChatSessionInput {
  """Messages to migrate"""
  messages: [MigrateChatMessageWithCitationsInput!]!

  """AI mode used for this session"""
  mode: ChatMode! = SIMPLE

  """Session ID from localStorage (UUID v4)"""
  sessionId: String!

  """Optional title for the session"""
  title: String
}

type MigrateChatSessionResult {
  """Error message if migration failed"""
  error: String

  """Number of messages migrated"""
  messageCount: Int!

  """The session ID in the database"""
  sessionId: ID!

  """Whether migration was successful"""
  success: Boolean!
}

type ModerationActionResult {
  """Action performed"""
  action: String!

  """Document ID"""
  documentId: ID!

  """Reason for the action"""
  reason: String

  """Whether user was notified"""
  userNotified: Boolean!
}

"""Moderation status of document"""
enum ModerationStatus {
  APPROVED
  PENDING
  REJECTED
}

input ModerationStatusFilterComparison {
  eq: ModerationStatus
  gt: ModerationStatus
  gte: ModerationStatus
  iLike: ModerationStatus
  in: [ModerationStatus!]
  is: Boolean
  isNot: Boolean
  like: ModerationStatus
  lt: ModerationStatus
  lte: ModerationStatus
  neq: ModerationStatus
  notILike: ModerationStatus
  notIn: [ModerationStatus!]
  notLike: ModerationStatus
}

type Mutation {
  """Accept the legal disclaimer for the current user"""
  acceptDisclaimer: AuthUser!

  """Activate a user account (admin only)"""
  activateUser(input: ActivateUserInput!): User!

  """Activate a webhook"""
  activateWebhook(id: String!): Webhook!

  """Add a citation to an existing legal query"""
  addCitationToQuery(citation: CreateCitationInput!, queryId: ID!): LegalQuery!

  """Create a backup (admin only)"""
  adminCreateBackup(input: CreateBackupInput): Backup!

  """Create a new user with password and role (admin only)"""
  adminCreateUser(input: AdminCreateUserInput!): User!

  """Delete a backup (admin only)"""
  adminDeleteBackup(id: ID!): Boolean!

  """Admin force-disable 2FA for a user (requires admin role)"""
  adminForceDisableTwoFactor(input: AdminForceDisableTwoFactorInput!): AdminForceDisableTwoFactorResponse!

  """Restore a backup (admin only)"""
  adminRestoreBackup(input: RestoreBackupInput!): Boolean!

  """Add AI-generated answer to a legal query"""
  answerLegalQuery(id: ID!, input: AnswerLegalQueryInput!): LegalQuery!

  """Approve a document after moderation review"""
  approveDocument(input: ApproveDocumentInput!): ModerationActionResult!

  """Ask a legal question and get AI answer synchronously"""
  askLegalQuestion(input: AskLegalQuestionInput!): LegalQuery!

  """Activate multiple user accounts (admin only)"""
  bulkActivateUsers(input: BulkActivateUsersInput!): BulkUsersResult!

  """Change roles for multiple users (admin only)"""
  bulkChangeUserRoles(input: BulkChangeUserRolesInput!): BulkUsersResult!

  """Delete multiple user accounts (admin only)"""
  bulkDeleteUsers(input: BulkDeleteUsersInput!): BulkDeleteUsersResult!

  """Suspend multiple user accounts (admin only)"""
  bulkSuspendUsers(input: BulkSuspendUsersInput!): BulkUsersResult!
  bulkUpsertSystemSettings(input: BulkUpdateSettingsInput!): [SystemSetting!]!

  """Cancel an active clarification session"""
  cancelClarificationSession(input: CancelClarificationSessionInput!): ClarificationSession!

  """Cancel the current user subscription"""
  cancelMySubscription(input: CancelSubscriptionInput!): UserSubscription!

  """Change password for the current user"""
  changePassword(input: ChangePasswordInput!): Boolean!

  """Upgrade or downgrade the current user subscription"""
  changeSubscriptionPlan(newPlanId: String!): UserSubscription!

  """Change a user role (admin only)"""
  changeUserRole(input: ChangeUserRoleInput!): User!

  """
  Analyze a case description using AI and identify applicable legal grounds
  """
  classifyCase(input: ClassifyCaseInput!): LegalAnalysis!

  """Cleanup empty assistant messages in the database"""
  cleanupEmptyMessages(input: CleanupEmptyMessagesInput!): CleanupEmptyMessagesResult!

  """Cleanup empty chat sessions (soft delete)"""
  cleanupEmptySessions(input: CleanupEmptySessionsInput!): CleanupEmptySessionsResult!

  """Complete a clarification session with final answer reference"""
  completeClarificationSession(finalQueryId: String!, sessionId: String!): ClarificationSession!

  """
  Complete login with 2FA token or backup code after receiving requiresTwoFactor response
  """
  completeTwoFactorLogin(input: CompleteTwoFactorLoginInput!): AuthPayload!

  """Create a new API key. The raw key is only shown once."""
  createApiKey(input: CreateApiKeyInput!): CreateApiKeyResponse!

  """Create a new chat session. Session ID is generated server-side."""
  createChatSession(input: CreateChatSessionInput!): ChatSession!

  """Create a new clarification session for a query"""
  createClarificationSession(input: CreateClarificationSessionInput!): ClarificationSession!
  createDocumentTemplate(input: CreateTemplateInput!): DocumentTemplate!
  createDocumentV2(input: CreateLegalDocumentInputV2!): LegalDocumentV2!

  """Create a contact in HubSpot from form submission"""
  createHubSpotContact(input: CreateHubSpotContactInput!): HubSpotContactResponse

  """Create a new subscription for the current user"""
  createMySubscription(input: CreateUserSubscriptionInput!): UserSubscription!
  createOneChatSession(input: CreateOneChatSessionInput!): ChatSession!
  createOneDocumentComment(input: CreateOneDocumentCommentInput!): DocumentComment!
  createOneDocumentTemplate(input: CreateOneDocumentTemplateInput!): DocumentTemplate!
  createOneDocumentVersion(input: CreateOneDocumentVersionInput!): DocumentVersion!
  createOneInAppNotification(input: CreateOneInAppNotificationInput!): InAppNotification!
  createOneLegalAnalysis(input: CreateOneLegalAnalysisInput!): LegalAnalysis!
  createOneLegalDocument(input: CreateOneLegalDocumentInput!): LegalDocument!
  createOneLegalQuery(input: CreateOneLegalQueryInput!): LegalQuery!
  createOneLegalRuling(input: CreateOneLegalRulingInput!): LegalRuling!
  createOneNotification(input: CreateOneNotificationInput!): Notification!

  """Create a new user (admin only)"""
  createOneUser(input: CreateUserInput!): User!
  createOneUserPreference(input: CreateOneUserPreferencesInput!): UserPreferences!

  """Create a new Temporal schedule for recurring workflow execution"""
  createSchedule(input: CreateScheduleInput!): CreateScheduleResult!

  """Create a new subscription plan (admin only)"""
  createSubscriptionPlan(input: CreateSubscriptionPlanInput!): SubscriptionPlan!
  createUsageRecord(input: CreateAiUsageRecordInput!): AiUsageRecord!

  """Create a new webhook. The secret is only shown once."""
  createWebhook(input: CreateWebhookInput!): CreateWebhookResponse!

  """Deactivate a webhook (temporary pause)"""
  deactivateWebhook(id: String!): Webhook!

  """Delete an API key permanently. This action cannot be undone."""
  deleteApiKey(id: String!): Boolean!

  """Soft delete a chat session"""
  deleteChatSession(input: DeleteChatSessionInput!): ChatSession!
  deleteDocument(id: ID!): Boolean! @deprecated(reason: "Use deleteOneLegalDocument instead")
  deleteDocumentTemplate(id: ID!): Boolean!
  deleteDocumentV2(input: DeleteDocumentInputV2!): Boolean!

  """Delete a legal query (deprecated)"""
  deleteLegalQuery(id: ID!): Boolean! @deprecated(reason: "Use deleteOneLegalQuery instead")
  deleteOneChatSession(input: DeleteOneChatSessionInput!): ChatSessionDeleteResponse!
  deleteOneDocumentComment(input: DeleteOneDocumentCommentInput!): DocumentCommentDeleteResponse!
  deleteOneDocumentTemplate(input: DeleteOneDocumentTemplateInput!): DocumentTemplateDeleteResponse!
  deleteOneInAppNotification(input: DeleteOneInAppNotificationInput!): InAppNotificationDeleteResponse!
  deleteOneLegalAnalysis(input: DeleteOneLegalAnalysisInput!): LegalAnalysisDeleteResponse!
  deleteOneLegalDocument(input: DeleteOneLegalDocumentInput!): LegalDocumentDeleteResponse!
  deleteOneLegalQuery(input: DeleteOneLegalQueryInput!): LegalQueryDeleteResponse!
  deleteOneLegalRuling(input: DeleteOneLegalRulingInput!): LegalRulingDeleteResponse!

  """Delete a user (admin only)"""
  deleteOneUser(id: ID!): User!
  deleteOneUserPreference(input: DeleteOneUserPreferencesInput!): UserPreferencesDeleteResponse!
  deleteOneUserSession(input: DeleteOneUserSessionInput!): UserSessionDeleteResponse!

  """Permanently delete a Temporal schedule (requires confirmation)"""
  deleteSchedule(input: DeleteScheduleInput!): ScheduleDeletionResult!

  """Delete a subscription plan (admin only)"""
  deleteSubscriptionPlan(id: String!): Boolean!
  deleteSystemSetting(key: String!): Boolean!

  """Delete a webhook permanently. This action cannot be undone."""
  deleteWebhook(id: String!): Boolean!

  """Disable 2FA with password confirmation"""
  disableTwoFactorAuth(input: DisableTwoFactorInput!): Boolean!

  """Disable a webhook"""
  disableWebhook(id: String!): Webhook!

  """Generate TOTP secret and QR code for 2FA setup"""
  enableTwoFactorAuth: EnableTwoFactorResponse!

  """Export a chat session to PDF, Markdown, or JSON format"""
  exportChatSession(input: ExportChatSessionInput!): ChatExportResult!

  """Queue a document for PDF export"""
  exportDocumentToPdf(input: ExportDocumentToPdfInput!): PdfExportJob!

  """Export a document to PDF and wait for the result"""
  exportDocumentToPdfSync(input: ExportDocumentToPdfInput!): PdfExportResult!

  """Flag a document for moderation review"""
  flagDocumentForModeration(input: FlagDocumentForModerationInput!): ModerationActionResult!
  generateDocument(input: GenerateDocumentInput!): LegalDocument!
  generateDocumentFromTemplate(input: GenerateFromTemplateInput!): LegalDocument!

  """Permanently delete a chat session and all messages (cannot be undone)"""
  hardDeleteChatSession(input: DeleteChatSessionInput!): DeleteChatSessionResult!

  """
  Authenticate user with username/email and password. Supports 2FA with twoFactorToken or backupCode.
  """
  login(input: LoginInput!): AuthPayload!

  """Mark all notifications as read for a user"""
  markAllNotificationsAsRead(userId: String!): Int!

  """Mark localStorage migration as complete for the current user"""
  markLocalStorageMigrated: LocalStorageMigrationStatus!

  """Mark a notification as read"""
  markNotificationAsRead(notificationId: String!, userId: String!): String!

  """Migrate a single chat session from localStorage to the database"""
  migrateChatSession(input: MigrateChatSessionInput!): MigrateChatSessionResult!

  """Migrate multiple chat sessions from localStorage to the database"""
  migrateChatSessionsBulk(input: MigrateChatBulkInput!): MigrateChatBulkResult!

  """Pause a running Temporal schedule"""
  pauseSchedule(input: PauseScheduleInput!): Boolean!

  """Pin or unpin a chat session"""
  pinChatSession(input: PinChatSessionInput!): ChatSession!
  publishDocumentV2(input: PublishDocumentInputV2!): LegalDocumentV2!

  """Check if a lead qualifies for deal creation"""
  qualifyHubSpotLead(input: CreateHubSpotContactInput!): LeadQualificationResponse!

  """Record usage for quota tracking"""
  recordUsage(amount: Float, quotaKey: String!): Boolean!

  """Refresh access token using a valid refresh token"""
  refreshToken(input: RefreshTokenInput!): RefreshTokenPayload!

  """Generate new backup codes (invalidates old ones)"""
  regenerateBackupCodes: RegenerateBackupCodesResponse!

  """Register a new user account"""
  register(input: RegisterInput!): AuthPayload!

  """Reject a document after moderation review"""
  rejectDocument(input: RejectDocumentInput!): ModerationActionResult!

  """
  Render a template with variable substitution without creating a document
  """
  renderTemplate(input: RenderTemplateInput!): String!

  """Reset the localStorage migration flag to allow re-migration"""
  resetLocalStorageMigration: LocalStorageMigrationStatus!
  resetMyPreferences: UserPreferences!

  """Reset a user password (admin only)"""
  resetUserPassword(input: ResetUserPasswordInput!): User!

  """Resume a subscription that was scheduled for cancellation"""
  resumeMySubscription: UserSubscription!

  """Resume a paused Temporal schedule"""
  resumeSchedule(input: ResumeScheduleInput!): Boolean!

  """Revoke an API key. This action cannot be undone."""
  revokeApiKey(id: String!): ApiKey!

  """Revoke a document share"""
  revokeDocumentShare(shareId: ID!): Boolean!

  """
  Rollback a document to a previous version. Creates a new version with the old content.
  """
  rollbackDocumentToVersion(authorUserId: ID, documentId: ID!, sessionId: ID!, versionNumber: Float!): LegalDocument!

  """Rotate webhook secret. The old secret will no longer work."""
  rotateWebhookSecret(id: String!): String!

  """Save a chat message to the database (used for streaming responses)"""
  saveChatMessage(input: SaveChatMessageInput!): SendChatMessageResponse!

  """Schedule a demo time (admin only)"""
  scheduleDemo(input: ScheduleDemoInput!): DemoRequest!
  seedSystemSettings: Boolean!

  """Send bulk notifications to multiple users"""
  sendBulkNotifications(input: BulkSendNotificationInput!): BulkSendNotificationResponse!

  """
  Send a chat message and get AI response. Stores both messages in the database.
  """
  sendChatMessageWithAI(input: SendChatMessageWithAIInput!): SendChatMessageWithAIResponse!

  """Send a notification to a user across specified channels"""
  sendNotification(input: SendNotificationInput!): SendNotificationResponse!

  """Share a document with a user"""
  shareDocument(input: ShareDocumentInput!): DocumentShare!

  """
  Submit answers to clarification questions. Validates answers and creates a user message.
  """
  submitClarificationAnswers(input: SubmitClarificationAnswersInput!): SubmitClarificationAnswersResponse!

  """
  Submit a demo request. No authentication required. The request will be synced to HubSpot and the sales team will be notified via email.
  """
  submitDemoRequest(input: DemoRequestInput!): DemoRequestResponse!

  """
  Submit an early access interest request. No authentication required. The request will be synced to HubSpot Early Access list. GDPR consent is required.
  """
  submitInterestRequest(input: InterestRequestInput!): InterestRequestResponse!

  """Submit a new legal query for AI processing"""
  submitLegalQuery(input: SubmitLegalQueryInput!): LegalQuery!

  """Suspend a user account (admin only)"""
  suspendUser(input: SuspendUserInput!): User!

  """Sync a lead to HubSpot with automatic qualification"""
  syncHubSpotLead(input: CreateHubSpotContactInput!, listType: String = "demo"): LeadQualificationResponse!

  """Test a webhook by sending a test event"""
  testWebhook(input: TestWebhookInput!): TestWebhookResponse!

  """Update an existing API key (name, scopes, rate limit, expiration)"""
  updateApiKey(id: String!, input: UpdateApiKeyInput!): ApiKey!

  """Update the title of a chat session"""
  updateChatSessionTitle(input: UpdateChatSessionTitleInput!): ChatSession!

  """Update the answered status of a clarification message"""
  updateClarificationStatus(input: UpdateClarificationStatusInput!): UpdateClarificationStatusResponse!

  """Update demo request status (admin only)"""
  updateDemoRequestStatus(input: UpdateDemoRequestStatusInput!): DemoRequest!
  updateDocument(id: ID!, input: UpdateDocumentInput!): LegalDocument!

  """Update the permission level of a document share"""
  updateDocumentSharePermission(input: UpdateSharePermissionInput!): DocumentShare!
  updateDocumentTemplate(id: ID!, input: UpdateTemplateInput!): DocumentTemplate!
  updateDocumentTitleV2(input: UpdateDocumentTitleInputV2!): LegalDocumentV2!
  updateMyPreferences(input: UpdateUserPreferencesInput!): UserPreferences!

  """Update notification preferences for a user"""
  updateNotificationPreferences(input: NotificationDeliveryPreferencesInput!): String!
  updateOneChatSession(input: UpdateOneChatSessionInput!): ChatSession!
  updateOneDocumentComment(input: UpdateOneDocumentCommentInput!): DocumentComment!
  updateOneDocumentTemplate(input: UpdateOneDocumentTemplateInput!): DocumentTemplate!
  updateOneDocumentVersion(input: UpdateOneDocumentVersionInput!): DocumentVersion!
  updateOneInAppNotification(input: UpdateOneInAppNotificationInput!): InAppNotification!
  updateOneLegalAnalysis(input: UpdateOneLegalAnalysisInput!): LegalAnalysis!
  updateOneLegalDocument(input: UpdateOneLegalDocumentInput!): LegalDocument!
  updateOneLegalQuery(input: UpdateOneLegalQueryInput!): LegalQuery!
  updateOneLegalRuling(input: UpdateOneLegalRulingInput!): LegalRuling!
  updateOneNotification(input: UpdateOneNotificationInput!): Notification!

  """Update a user (admin only)"""
  updateOneUser(id: ID!, input: UpdateUserInput!): User!
  updateOneUserPreference(input: UpdateOneUserPreferencesInput!): UserPreferences!

  """Update profile information for the current user"""
  updateProfile(input: UpdateProfileInput!): AuthUser!

  """Update an existing subscription plan (admin only)"""
  updateSubscriptionPlan(id: String!, input: UpdateSubscriptionPlanInput!): SubscriptionPlan!

  """Update an existing webhook (name, URL, events, headers, status)"""
  updateWebhook(id: String!, input: UpdateWebhookInput!): Webhook!
  upsertSystemSetting(input: SystemSettingInput!): SystemSetting!

  """Verify 2FA setup with first TOTP token to enable"""
  verifyTwoFactorSetup(input: VerifyTwoFactorSetupInput!): VerifyTwoFactorSetupResponse!
}

type Notification {
  createdAt: DateTime!
  errorMessage: String
  id: ID!
  messageId: String
  metadata: String
  recipientEmail: String!
  sentAt: DateTime
  status: NotificationStatus!
  subject: String!
  template: EmailTemplateType!
  templateData: String
  updatedAt: DateTime!
  userId: String
}

input NotificationAggregateFilter {
  and: [NotificationAggregateFilter!]
  createdAt: DateFieldComparison
  errorMessage: StringFieldComparison
  id: IDFilterComparison
  messageId: StringFieldComparison
  or: [NotificationAggregateFilter!]
  recipientEmail: StringFieldComparison
  sentAt: DateFieldComparison
  status: NotificationStatusFilterComparison
  subject: StringFieldComparison
  template: EmailTemplateTypeFilterComparison
  updatedAt: DateFieldComparison
  userId: StringFieldComparison
}

type NotificationAggregateGroupBy {
  createdAt(by: GroupBy! = DAY): DateTime
  errorMessage: String
  id: ID
  messageId: String
  recipientEmail: String
  sentAt(by: GroupBy! = DAY): DateTime
  status: NotificationStatus
  subject: String
  template: EmailTemplateType
  updatedAt(by: GroupBy! = DAY): DateTime
  userId: String
}

type NotificationAggregateResponse {
  count: NotificationCountAggregate
  groupBy: NotificationAggregateGroupBy
  max: NotificationMaxAggregate
  min: NotificationMinAggregate
}

"""Notification channel types"""
enum NotificationChannel {
  BOTH
  EMAIL
  IN_APP
}

type NotificationChannels {
  email: Boolean!
  inApp: Boolean!
  push: Boolean!
}

input NotificationChannelsInput {
  email: Boolean
  inApp: Boolean
  push: Boolean
}

type NotificationConnection {
  """Array of edges."""
  edges: [NotificationEdge!]!

  """Paging information"""
  pageInfo: PageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type NotificationCountAggregate {
  createdAt: Int
  errorMessage: Int
  id: Int
  messageId: Int
  recipientEmail: Int
  sentAt: Int
  status: Int
  subject: Int
  template: Int
  updatedAt: Int
  userId: Int
}

type NotificationDeliveryPreferences {
  """Enable email notifications"""
  emailEnabled: Boolean!

  """Notification types to exclude from email"""
  excludeEmailTypes: [NotificationTemplateType!]

  """Notification types to exclude from in-app"""
  excludeInAppTypes: [NotificationTemplateType!]

  """Enable in-app notifications"""
  inAppEnabled: Boolean!

  """User ID"""
  userId: String!
}

input NotificationDeliveryPreferencesInput {
  """Enable email notifications"""
  emailEnabled: Boolean = true

  """Notification types to exclude from email"""
  excludeEmailTypes: [NotificationTemplateType!]

  """Notification types to exclude from in-app"""
  excludeInAppTypes: [NotificationTemplateType!]

  """Enable in-app notifications"""
  inAppEnabled: Boolean = true

  """User ID"""
  userId: String!
}

type NotificationEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the Notification"""
  node: Notification!
}

input NotificationFilter {
  and: [NotificationFilter!]
  createdAt: DateFieldComparison
  errorMessage: StringFieldComparison
  id: IDFilterComparison
  messageId: StringFieldComparison
  or: [NotificationFilter!]
  recipientEmail: StringFieldComparison
  sentAt: DateFieldComparison
  status: NotificationStatusFilterComparison
  subject: StringFieldComparison
  template: EmailTemplateTypeFilterComparison
  updatedAt: DateFieldComparison
  userId: StringFieldComparison
}

type NotificationMaxAggregate {
  createdAt: DateTime
  errorMessage: String
  id: ID
  messageId: String
  recipientEmail: String
  sentAt: DateTime
  status: NotificationStatus
  subject: String
  template: EmailTemplateType
  updatedAt: DateTime
  userId: String
}

type NotificationMinAggregate {
  createdAt: DateTime
  errorMessage: String
  id: ID
  messageId: String
  recipientEmail: String
  sentAt: DateTime
  status: NotificationStatus
  subject: String
  template: EmailTemplateType
  updatedAt: DateTime
  userId: String
}

type NotificationPreferences {
  channels: NotificationChannels!
  documentUpdates: Boolean!
  marketingEmails: Boolean!
  queryResponses: Boolean!
  systemAlerts: Boolean!
}

input NotificationPreferencesInput {
  channels: NotificationChannelsInput
  documentUpdates: Boolean
  marketingEmails: Boolean
  queryResponses: Boolean
  systemAlerts: Boolean
}

"""Priority levels for notifications"""
enum NotificationPriority {
  HIGH
  LOW
  NORMAL
  URGENT
}

input NotificationSort {
  direction: SortDirection!
  field: NotificationSortFields!
  nulls: SortNulls
}

enum NotificationSortFields {
  createdAt
  errorMessage
  id
  messageId
  recipientEmail
  sentAt
  status
  subject
  template
  updatedAt
  userId
}

"""Status of email notifications"""
enum NotificationStatus {
  BOUNCED
  FAILED
  PENDING
  QUEUED
  SENT
}

input NotificationStatusFilterComparison {
  eq: NotificationStatus
  gt: NotificationStatus
  gte: NotificationStatus
  iLike: NotificationStatus
  in: [NotificationStatus!]
  is: Boolean
  isNot: Boolean
  like: NotificationStatus
  lt: NotificationStatus
  lte: NotificationStatus
  neq: NotificationStatus
  notILike: NotificationStatus
  notIn: [NotificationStatus!]
  notLike: NotificationStatus
}

"""Notification template types"""
enum NotificationTemplateType {
  DOCUMENT_COMPLETED
  DOCUMENT_FAILED
  DOCUMENT_SHARED
  EMAIL_VERIFICATION
  PASSWORD_CHANGED
  PASSWORD_RESET
  QUERY_COMPLETED
  QUERY_FAILED
  RULING_INDEXED
  RULING_SEARCH_READY
  SECURITY_ALERT
  SYSTEM_MAINTENANCE
  SYSTEM_UPDATE
  WELCOME
}

input NumberFieldComparison {
  between: NumberFieldComparisonBetween
  eq: Float
  gt: Float
  gte: Float
  in: [Float!]
  is: Boolean
  isNot: Boolean
  lt: Float
  lte: Float
  neq: Float
  notBetween: NumberFieldComparisonBetween
  notIn: [Float!]
}

input NumberFieldComparisonBetween {
  lower: Float!
  upper: Float!
}

"""Type of observation within a trace"""
enum ObservationType {
  EVENT
  GENERATION
  SPAN
}

type OperationBreakdown {
  cost: Float!
  operationType: AiOperationType!
  requestCount: Int!
  tokenCount: Int!
}

type PageInfo {
  """The cursor of the last returned record."""
  endCursor: ConnectionCursor

  """true if paging forward and there are more records."""
  hasNextPage: Boolean

  """true if paging backwards and there are more records."""
  hasPreviousPage: Boolean

  """The cursor of the first returned record."""
  startCursor: ConnectionCursor
}

input PauseScheduleInput {
  """Optional reason for pausing (logged to audit trail)"""
  reason: String

  """The ID of the schedule to pause"""
  scheduleId: String!
}

type PaymentHistoryItem {
  amount: String!
  createdAt: String!
  currency: String!
  description: String
  id: ID!
  invoiceId: String
  method: PaymentMethod!
  refundAmount: String
  refundedAt: String
  status: PaymentStatus!
}

"""Payment method"""
enum PaymentMethod {
  BANK_TRANSFER
  CREDIT_CARD
  DEBIT_CARD
  OTHER
  PAYPAL
}

type PaymentMethodInfo {
  brand: String!
  expiryMonth: String!
  expiryYear: String!
  id: String!
  isDefault: Boolean!
  last4: String!
}

"""Payment status"""
enum PaymentStatus {
  COMPLETED
  FAILED
  PARTIALLY_REFUNDED
  PENDING
  REFUNDED
}

type PdfExportJob {
  """Document ID being exported"""
  documentId: ID!

  """Unique job ID for tracking"""
  jobId: ID!

  """Message describing current state"""
  message: String!

  """Current status of the job"""
  status: String!
}

input PdfExportOptionsInput {
  """Page format (default: A4)"""
  format: PdfPageFormat = A4

  """Include footer with page numbers"""
  includeFooter: Boolean = true

  """Include header with document title and date"""
  includeHeader: Boolean = true

  """Include table of contents"""
  includeTableOfContents: Boolean = false

  """Language for formatting (default: "pl" for Polish)"""
  language: String = "pl"

  """Watermark text (e.g., "DRAFT")"""
  watermark: String
}

type PdfExportResult {
  """Document ID that was exported"""
  documentId: ID!

  """Size of the PDF file in bytes"""
  fileSizeBytes: Float!

  """Generated filename for the PDF"""
  filename: String!

  """Time taken to generate the PDF in milliseconds"""
  generationTimeMs: Float!

  """Number of pages in the PDF"""
  pageCount: Float!

  """Base64-encoded PDF content"""
  pdfBase64: String!
}

type PdfExportStatus {
  """Error message if job failed"""
  error: String

  """Job ID"""
  jobId: ID!

  """Job progress (0-100)"""
  progress: Float

  """Result if job is completed"""
  result: PdfExportResult

  """Current job status"""
  status: String!
}

"""Page format for PDF export"""
enum PdfPageFormat {
  A4
  LEGAL
  LETTER
}

input PinChatSessionInput {
  """True to pin, false to unpin"""
  isPinned: Boolean!

  """Session ID to pin/unpin"""
  sessionId: ID!
}

"""Subscription plan tiers"""
enum PlanTier {
  BASIC
  ENTERPRISE
  FREE
  PROFESSIONAL
}

input PolishFormattingRulesInput {
  addressFormat: String
  currencyFormat: String
  dateFormat: String
  legalCitations: Boolean
  numberFormat: String
}

"""Preferred time of day for demo"""
enum PreferredTimeSlot {
  AFTERNOON
  EVENING
  MORNING
}

input PublishDocumentInputV2 {
  documentId: ID!
  publishedBy: ID!
}

type Query {
  """Get a backup by ID (admin only)"""
  adminBackup(id: ID!): Backup

  """Get backup statistics (admin only)"""
  adminBackupStats: BackupStats!

  """Get all backups (admin only)"""
  adminBackups(limit: Float = 50, offset: Float = 0): [Backup!]!

  """
  Advanced search with boolean operators (AND, OR, NOT) and field-specific search
  """
  advancedSearchLegalRulings(input: AdvancedSearchLegalRulingsInput!): AdvancedLegalRulingSearchResponse!

  """Generate a report of users affected by empty messages"""
  affectedUsersForEmptyMessages: AffectedUsersReport!

  """
  Search legal rulings across multiple sources (LOCAL, SAOS, ISAP) with relevance ranking
  """
  aggregatedSearchLegalRulings(input: AggregatedSearchLegalRulingsInput!): AggregatedLegalRulingSearchResponse!
  aiUsageMetrics(input: DashboardAnalyticsInput): AiUsageMetrics!
  analyticsDashboard(input: DashboardAnalyticsInput): AnalyticsDashboard!

  """Analyze all empty assistant messages in the database"""
  analyzeEmptyMessages: EmptyMessagesSummary!

  """Analyze all empty chat sessions (messageCount = 0)"""
  analyzeEmptySessions: [EmptySessionAnalysis!]!
  auditLog(
    """The id of the record to find."""
    id: ID!
  ): AuditLog!
  auditLogAggregate(
    """Filter to find records to aggregate on"""
    filter: AuditLogAggregateFilter
  ): [AuditLogAggregateResponse!]!
  auditLogs(
    """Specify to filter the records returned."""
    filter: AuditLogFilter! = {}

    """Limit or page results."""
    paging: CursorPaging! = {first: 10}

    """Specify to sort results."""
    sorting: [AuditLogSort!]! = []
  ): AuditLogConnection!

  """Check if the current user can access a specific feature"""
  canAccessFeature(featureKey: String!): Boolean!

  """Get a single chat message by ID with proper type resolution"""
  chatMessageById(messageId: ID!): ChatMessageInterface

  """Get all messages for a chat session in sequence order"""
  chatMessages(sessionId: ID!): [ChatMessage!]!

  """
  Get chat messages for a session with proper type resolution based on message type
  """
  chatMessagesBySession(sessionId: ID!): [ChatMessageInterface!]!
  chatSessionAggregate(
    """Filter to find records to aggregate on"""
    filter: ChatSessionAggregateFilter
  ): [ChatSessionAggregateResponse!]!
  chatSessionById(
    """The id of the record to find."""
    id: ID!
  ): ChatSession!

  """Get a chat session with all its messages"""
  chatSessionDetail(
    """Session ID to fetch"""
    sessionId: ID!
  ): ChatSession

  """Get chat sessions for a user with filtering and sorting"""
  chatSessions(
    """Include soft deleted sessions"""
    includeDeleted: Boolean = false

    """Filter by pinned status"""
    isPinned: Boolean

    """Number of sessions to return"""
    limit: Int = 20

    """Filter by AI mode"""
    mode: ChatMode

    """Number of sessions to skip"""
    offset: Int = 0

    """Search in session titles"""
    search: String

    """Sort field (createdAt, lastMessageAt, title, messageCount)"""
    sortBy: String = "lastMessageAt"

    """Sort order (ASC, DESC)"""
    sortOrder: String = "DESC"

    """User ID to filter sessions (defaults to authenticated user)"""
    userId: ID
  ): [ChatSession!]!
  chatSessionsList(
    """Specify to filter the records returned."""
    filter: ChatSessionFilter! = {}

    """Limit or page results."""
    paging: CursorPaging! = {first: 10}

    """Specify to sort results."""
    sorting: [ChatSessionSort!]! = []
  ): ChatSessionConnection!

  """Check if email is already registered (admin only)"""
  checkEmailExists(email: String!): CheckEmailExistsResult

  """Check the current user quota for a specific resource"""
  checkQuota(input: CheckQuotaInput!): CheckQuotaResponse!

  """Get the active clarification session for a specific query"""
  clarificationSessionByQuery(queryId: String!): ClarificationSession

  """Get all clarification sessions in a specific state"""
  clarificationSessionsByState(state: ClarificationState!): [ClarificationSession!]!

  """Get all clarification sessions for a user session"""
  clarificationSessionsByUserSession(sessionId: String!): [ClarificationSession!]!

  """Count legal rulings matching filter criteria"""
  countLegalRulings(input: FilterLegalRulingsInput): Int!

  """Debug endpoint to inspect conversation history for a session"""
  debugConversationHistory(sessionId: ID!): ChatSessionDebugInfo!
  demoRequest(
    """The id of the record to find."""
    id: ID!
  ): DemoRequest!
  demoRequestAggregate(
    """Filter to find records to aggregate on"""
    filter: DemoRequestAggregateFilter
  ): [DemoRequestAggregateResponse!]!
  demoRequestAnalytics(input: DashboardAnalyticsInput): DemoRequestAnalytics!
  demoRequests(
    """Specify to filter the records returned."""
    filter: DemoRequestFilter! = {}

    """Limit or page results."""
    paging: CursorPaging! = {first: 10}

    """Specify to sort results."""
    sorting: [DemoRequestSort!]! = []
  ): DemoRequestConnection!

  """Get detailed information about a Temporal schedule"""
  describeSchedule(scheduleId: String!): ScheduleDetails
  documentComment(
    """The id of the record to find."""
    id: ID!
  ): DocumentComment!
  documentCommentAggregate(
    """Filter to find records to aggregate on"""
    filter: DocumentCommentAggregateFilter
  ): [DocumentCommentAggregateResponse!]!
  documentComments(
    """Specify to filter the records returned."""
    filter: DocumentCommentFilter! = {}

    """Limit or page results."""
    paging: CursorPaging! = {first: 10}

    """Specify to sort results."""
    sorting: [DocumentCommentSort!]! = []
  ): DocumentCommentConnection!

  """Get the latest version of a document"""
  documentLatestVersion(documentId: ID!): DocumentVersion
  documentMetrics(input: DashboardAnalyticsInput): DocumentMetrics!
  documentQueueMetrics: DocumentQueueMetrics!

  """Get all shares for a document"""
  documentShares(documentId: ID!): [DocumentShare!]!
  documentTemplate(
    """The id of the record to find."""
    id: ID!
  ): DocumentTemplate!
  documentTemplateAggregate(
    """Filter to find records to aggregate on"""
    filter: DocumentTemplateAggregateFilter
  ): [DocumentTemplateAggregateResponse!]!
  documentTemplates(
    """Specify to filter the records returned."""
    filter: DocumentTemplateFilter! = {}

    """Limit or page results."""
    paging: CursorPaging! = {first: 10}

    """Specify to sort results."""
    sorting: [DocumentTemplateSort!]! = []
  ): DocumentTemplateConnection!
  documentV2(id: ID!): LegalDocumentV2
  documentVersion(
    """The id of the record to find."""
    id: ID!
  ): DocumentVersion!
  documentVersionAggregate(
    """Filter to find records to aggregate on"""
    filter: DocumentVersionAggregateFilter
  ): [DocumentVersionAggregateResponse!]!

  """Get a specific version of a document"""
  documentVersionByNumber(documentId: ID!, versionNumber: Float!): DocumentVersion!

  """Count total versions for a document"""
  documentVersionCount(documentId: ID!): Float!

  """Get all versions for a document, ordered by version number descending"""
  documentVersionHistory(documentId: ID!): [DocumentVersion!]!
  documentVersions(
    """Specify to filter the records returned."""
    filter: DocumentVersionFilter! = {}

    """Limit or page results."""
    paging: CursorPaging! = {first: 10}

    """Specify to sort results."""
    sorting: [DocumentVersionSort!]! = []
  ): DocumentVersionConnection!
  documentsByOwnerV2(ownerId: ID!, status: DocumentStatusV2): [LegalDocumentV2!]!
  documentsBySession(sessionId: String!): [LegalDocument!]!

  """Get all documents shared with the current user"""
  documentsSharedWithMe(permission: SharePermission): [DocumentShare!]!

  """Get empty assistant messages for a specific session"""
  emptyMessagesForSession(sessionId: ID!): [EmptyMessageAnalysis!]!

  """Get empty assistant messages for a specific user"""
  emptyMessagesForUser(userId: ID!): [EmptyMessageAnalysis!]!

  """Get empty sessions count for monitoring (alert if threshold exceeded)"""
  emptySessionsMetrics(alertThreshold: Float = 100): EmptySessionsMetrics!

  """Filter legal rulings by multiple criteria"""
  filterLegalRulings(input: FilterLegalRulingsInput!): [LegalRuling!]!
  getActiveUsersCount: ActiveUsersCount!

  """Get formatted context for AI processing from a clarification session"""
  getClarificationContext(sessionId: String!): String
  getDocumentGenerationMetrics(input: DashboardAnalyticsInput): DocumentGenerationMetrics!
  getQueryVolume(input: DashboardAnalyticsInput): [AnalyticsTimeSeriesPoint!]!
  getTotalDocumentCount(input: DashboardAnalyticsInput): DocumentMetrics!
  getTotalTokenUsage(input: DashboardAnalyticsInput): [TokenUsageBreakdown!]!
  getUserGrowthStats(input: DashboardAnalyticsInput): UserGrowthStats!
  inAppNotification(
    """The id of the record to find."""
    id: ID!
  ): InAppNotification!
  inAppNotificationAggregate(
    """Filter to find records to aggregate on"""
    filter: InAppNotificationAggregateFilter
  ): [InAppNotificationAggregateResponse!]!
  inAppNotifications(
    """Specify to filter the records returned."""
    filter: InAppNotificationFilter! = {}

    """Limit or page results."""
    paging: CursorPaging! = {first: 10}

    """Specify to sort results."""
    sorting: [InAppNotificationSort!]! = []
  ): InAppNotificationConnection!
  langfuseDebugConfig: LangfuseDebugConfig
  langfuseLatencyMetrics(endDate: String, startDate: String): [AgentLatencyMetrics!]
  langfuseTokenUsageByAgent(endDate: String, startDate: String): [TokenUsageByAgent!]
  langfuseTraceDetail(traceId: String!): LangfuseTraceDetail

  """Get the URL to view a specific trace in Langfuse dashboard"""
  langfuseTraceUrl(traceId: String!): String
  langfuseTraces(input: TracesListInput): TracesListResponse
  langfuseUserAttribution(endDate: String, limit: Float = 20, startDate: String): [UserTraceAttribution!]
  legalAnalyses(
    """Specify to filter the records returned."""
    filter: LegalAnalysisFilter! = {}

    """Limit or page results."""
    paging: CursorPaging! = {first: 10}

    """Specify to sort results."""
    sorting: [LegalAnalysisSort!]! = []
  ): LegalAnalysisConnection!
  legalAnalysis(
    """The id of the record to find."""
    id: ID!
  ): LegalAnalysis!
  legalAnalysisAggregate(
    """Filter to find records to aggregate on"""
    filter: LegalAnalysisAggregateFilter
  ): [LegalAnalysisAggregateResponse!]!
  legalDocument(
    """The id of the record to find."""
    id: ID!
  ): LegalDocument!
  legalDocumentAggregate(
    """Filter to find records to aggregate on"""
    filter: LegalDocumentAggregateFilter
  ): [LegalDocumentAggregateResponse!]!
  legalDocuments(
    """Specify to filter the records returned."""
    filter: LegalDocumentFilter! = {}

    """Limit or page results."""
    paging: CursorPaging! = {first: 10}

    """Specify to sort results."""
    sorting: [LegalDocumentSort!]! = []
  ): LegalDocumentConnection!
  legalQueries(
    """Specify to filter the records returned."""
    filter: LegalQueryFilter! = {}

    """Limit or page results."""
    paging: CursorPaging! = {first: 10}

    """Specify to sort results."""
    sorting: [LegalQuerySort!]! = []
  ): LegalQueryConnection!
  legalQuery(
    """The id of the record to find."""
    id: ID!
  ): LegalQuery!
  legalQueryAggregate(
    """Filter to find records to aggregate on"""
    filter: LegalQueryAggregateFilter
  ): [LegalQueryAggregateResponse!]!
  legalRuling(
    """The id of the record to find."""
    id: ID!
  ): LegalRuling!
  legalRulingAggregate(
    """Filter to find records to aggregate on"""
    filter: LegalRulingAggregateFilter
  ): [LegalRulingAggregateResponse!]!

  """Find a legal ruling by its unique case signature"""
  legalRulingBySignature(signature: String!): LegalRuling
  legalRulings(
    """Specify to filter the records returned."""
    filter: LegalRulingFilter! = {}

    """Limit or page results."""
    paging: CursorPaging! = {first: 10}

    """Specify to sort results."""
    sorting: [LegalRulingSort!]! = []
  ): LegalRulingConnection!

  """Get legal rulings filtered by court type"""
  legalRulingsByCourtType(courtType: CourtType!, limit: Int = 20): [LegalRuling!]!

  """
  Get legal rulings from higher courts (Supreme, Appellate, Constitutional)
  """
  legalRulingsFromHigherCourts(limit: Int = 20): [LegalRuling!]!

  """Check the status of localStorage migration for the current user"""
  localStorageMigrationStatus: LocalStorageMigrationStatus!

  """Get current authenticated user information"""
  me: AuthUser

  """Get all API keys for the current user"""
  myApiKeys: [ApiKey!]!

  """
  Get billing information including subscription status and payment history
  """
  myBillingInfo: BillingInfo
  myDailyUsage(endDate: DateTime, startDate: DateTime): DailyUsageResponse!

  """Get payment history for the current user"""
  myPaymentHistory: [PaymentHistoryItem!]!
  myPreferences: UserPreferences!

  """Get the current user subscription"""
  mySubscription: UserSubscription
  myTotalCost(endDate: DateTime, startDate: DateTime): Float!
  myUsageRecords(endDate: DateTime, limit: Float = 100, offset: Float = 0, operationType: AiOperationType, startDate: DateTime): [AiUsageRecord!]!

  """Get usage statistics for the current user subscription"""
  myUsageStats: SubscriptionUsageStats

  """Get all webhooks for the current user"""
  myWebhooks(status: String): [Webhook!]!
  notification(
    """The id of the record to find."""
    id: ID!
  ): Notification!
  notificationAggregate(
    """Filter to find records to aggregate on"""
    filter: NotificationAggregateFilter
  ): [NotificationAggregateResponse!]!

  """Get notification preferences for a user"""
  notificationPreferences(userId: String!): NotificationDeliveryPreferences!
  notifications(
    """Specify to filter the records returned."""
    filter: NotificationFilter! = {}

    """Limit or page results."""
    paging: CursorPaging! = {first: 10}

    """Specify to sort results."""
    sorting: [NotificationSort!]! = []
  ): NotificationConnection!

  """Get the status of a PDF export job"""
  pdfExportStatus(jobId: ID!): PdfExportStatus!

  """Get all documents pending moderation review"""
  pendingModerationDocuments: [LegalDocument!]!

  """Get legal queries that are waiting for AI answers"""
  pendingQueries(limit: Float): [LegalQuery!]!
  publicSystemSettings: [SystemSetting!]!

  """Get all legal queries for a specific session"""
  queriesBySession(sessionId: String!): [LegalQuery!]!
  queryMetrics(input: DashboardAnalyticsInput): QueryMetrics!
  recentDocumentActivity(limit: Int = 10): RecentDocumentActivity!

  """Get recent notifications for a user"""
  recentNotifications(limit: Int, unreadOnly: Boolean, userId: String!): [InAppNotification!]!

  """
  Full-text search across chat messages with relevance ranking and highlighting
  """
  searchChatContent(
    """Context window: number of characters before/after match"""
    contextLength: Int = 150

    """Date range start (ISO 8601 format)"""
    dateFrom: String

    """Date range end (ISO 8601 format)"""
    dateTo: String

    """Number of results to return"""
    limit: Int = 20

    """Filter by AI mode"""
    mode: ChatMode

    """Number of results to skip"""
    offset: Int = 0

    """Search query for full-text search in message content"""
    query: String!

    """Filter by message role (USER, ASSISTANT, SYSTEM)"""
    role: MessageRole

    """Filter by session title"""
    sessionTitle: String

    """User ID to filter messages (defaults to authenticated user)"""
    userId: ID
  ): ChatContentSearchResponse!

  """Full-text search across documents with relevance ranking"""
  searchLegalDocuments(input: SearchLegalDocumentsInput!): LegalDocumentSearchResponse!

  """Full-text search across queries with relevance ranking"""
  searchLegalQueries(input: SearchLegalQueriesInput!): LegalQuerySearchResponse!

  """Full-text search for legal rulings with relevance ranking"""
  searchLegalRulings(input: SearchLegalRulingsInput!): LegalRulingSearchResponse!

  """Get a subscription plan by ID"""
  subscriptionPlan(id: String!): SubscriptionPlan

  """Get all active subscription plans ordered by price"""
  subscriptionPlans: [SubscriptionPlan!]!

  """Get comprehensive system health status for admin dashboard"""
  systemHealth: SystemHealthResponse!
  systemHealthMetrics(input: DashboardAnalyticsInput): SystemHealthMetrics!
  systemSetting(key: String!): SystemSetting
  systemSettings: [SystemSetting!]!
  systemSettingsByCategory(category: SettingCategory!): [SystemSetting!]!

  """Get detailed information about a Temporal schedule by ID"""
  temporalSchedule(scheduleId: String!): ScheduleDetails

  """List all Temporal schedules with pagination"""
  temporalSchedules(input: ScheduleListInput): ScheduleListResult!

  """Get the current status of Temporal workers"""
  temporalWorkerStatus: WorkerStatusResult!
  tokenUsageAnalytics(input: DashboardAnalyticsInput): TokenUsageAnalytics!
  tokenUsageByOperation(input: DashboardAnalyticsInput): [TokenUsageByOperation!]!
  tokenUsageExport(input: DashboardAnalyticsInput): TokenUsageExport!
  tokenUsageTrend(input: DashboardAnalyticsInput): [TokenUsageTrend!]!
  topUsersByUsage(by: String = "tokens", endDate: DateTime, limit: Float = 10, startDate: DateTime): String!

  """Get current 2FA settings and status"""
  twoFactorSettings: TwoFactorSettings

  """Get count of unread notifications for a user"""
  unreadNotificationCount(userId: String!): Int!
  usageStats(query: UsageStatsQueryInput!): UsageStatsResponse!

  """Get a user by ID (admin only)"""
  user(id: ID!): User
  userGrowthMetrics(input: DashboardAnalyticsInput): UserGrowthMetrics!
  userPreference(
    """The id of the record to find."""
    id: ID!
  ): UserPreferences!
  userPreferences(
    """Specify to filter the records returned."""
    filter: UserPreferencesFilter! = {}

    """Limit or page results."""
    paging: CursorPaging! = {first: 10}

    """Specify to sort results."""
    sorting: [UserPreferencesSort!]! = []
  ): UserPreferencesConnection!
  userPreferencesAggregate(
    """Filter to find records to aggregate on"""
    filter: UserPreferencesAggregateFilter
  ): [UserPreferencesAggregateResponse!]!
  userSession(
    """The id of the record to find."""
    id: ID!
  ): UserSession!
  userSessionAggregate(
    """Filter to find records to aggregate on"""
    filter: UserSessionAggregateFilter
  ): [UserSessionAggregateResponse!]!
  userSessions(
    """Specify to filter the records returned."""
    filter: UserSessionFilter! = {}

    """Limit or page results."""
    paging: CursorPaging! = {first: 10}

    """Specify to sort results."""
    sorting: [UserSessionSort!]! = []
  ): UserSessionConnection!
  userTokenLeaderboard(input: DashboardAnalyticsInput, limit: Int = 20): [UserTokenUsage!]!
  userUsageRecords(endDate: DateTime, limit: Float = 100, offset: Float = 0, operationType: AiOperationType, startDate: DateTime, userId: String!): [AiUsageRecord!]!

  """Get all users with filtering, sorting, and paging (admin only)"""
  users(filter: UserFilter, paging: UserPaging, sorting: [UserSort!]): [User!]!

  """Validate an API key and check if it has the required scopes"""
  validateApiKey(input: ValidateApiKeyInput!): ValidateApiKeyResponse!

  """Get a webhook by ID"""
  webhook(id: String!): Webhook!

  """Get recent deliveries for a webhook"""
  webhookDeliveries(limit: Float = 50, webhookId: String!): [WebhookDelivery!]!

  """Get webhook statistics for the current user"""
  webhookStats: WebhookStats!
}

type QueryMetrics {
  """Average citations per query"""
  avgCitationsPerQuery: Float!

  """Average queries per user"""
  avgQueriesPerUser: Float!
  periodEnd: DateTime!
  periodStart: DateTime!

  """Total citations across all queries"""
  totalCitations: Int!
  totalQueries: Int!
  uniqueUsers: Int!
}

type RecentDocumentActivity {
  """Documents currently being generated"""
  currentlyGenerating: [DocumentActivityEntry!]!
  fetchedAt: DateTime!
  recentCompletions: [DocumentActivityEntry!]!
  recentFailures: [DocumentActivityEntry!]!
}

input RefreshTokenInput {
  """Refresh token"""
  refreshToken: String!
}

type RefreshTokenPayload {
  """New JWT access token"""
  accessToken: String!

  """New JWT refresh token"""
  refreshToken: String!
}

type RegenerateBackupCodesResponse {
  """New backup codes for account recovery (show only once)"""
  codes: [String!]!
}

input RegisterInput {
  """Email address"""
  email: String!

  """First name"""
  firstName: String

  """Last name"""
  lastName: String

  """User password"""
  password: String!

  """Optional username"""
  username: String
}

input RejectDocumentInput {
  """Document ID to reject"""
  documentId: ID!

  """Reason for rejection (required)"""
  reason: String!
}

type RelatedDocumentLink {
  description: String
  documentId: String!
  relationshipType: String!
  relevanceScore: Float
}

input RelatedDocumentLinkInput {
  description: String
  documentId: String!
  relationshipType: String!
  relevanceScore: Float
}

input RenderTemplateInput {
  templateId: String!
  variables: JSON!
}

input ResetUserPasswordInput {
  newPassword: String!
  userId: ID!
}

input RestoreBackupInput {
  """Create a new database instead of overwriting"""
  createNewDatabase: Boolean
  id: ID!

  """New database name if createNewDatabase is true"""
  newDatabaseName: String

  """Target database name (defaults to current)"""
  targetDatabase: String
}

input ResumeScheduleInput {
  """Optional reason for resuming (logged to audit trail)"""
  reason: String

  """The ID of the schedule to resume"""
  scheduleId: String!
}

type RulingMetadata {
  keywords: [String!]
  legalArea: String
  relatedCases: [String!]
  sourceReference: String
}

input SaveChatMessageInput {
  """Citations (for assistant messages)"""
  citations: [ChatCitationInput!]

  """Message content"""
  content: String!

  """Additional metadata (for assistant messages)"""
  metadata: ChatMessageMetadataInput

  """Message role (USER or ASSISTANT)"""
  role: String!

  """The session ID"""
  sessionId: ID!

  """
  Type of message (text, clarification_question, clarification_answer, citation, error)
  """
  type: ChatMessageType
}

type ScheduleActionDetails {
  """JSON string of arguments passed to workflow"""
  args: String

  """Task queue for executions"""
  taskQueue: String!

  """Workflow ID template"""
  workflowId: String!

  """Workflow type being executed"""
  workflowType: String!
}

input ScheduleActionInput {
  """JSON string of arguments to pass to the workflow"""
  args: String

  """Task queue to dispatch workflows to"""
  taskQueue: String!

  """Type of action (currently only startWorkflow is supported)"""
  type: String!

  """Workflow ID template for each execution"""
  workflowId: String!

  """Workflow type to execute"""
  workflowType: String!
}

type ScheduleDeletionResult {
  """Message describing the deletion result"""
  message: String

  """The ID of the deleted schedule"""
  scheduleId: ID!

  """Whether the deletion was successful"""
  success: Boolean!
}

input ScheduleDemoInput {
  demoRequestId: ID!
  scheduledTime: DateTime!
}

type ScheduleDetails {
  """Action the schedule performs"""
  action: ScheduleActionDetails

  """Whether the schedule exists"""
  exists: Boolean!

  """Number of failed actions"""
  failedActions: String

  """ISO datetime of last run"""
  lastRunAt: String

  """Number of missed actions"""
  missedActions: String

  """ISO datetime of next run"""
  nextRunAt: String

  """Overlap policy"""
  overlap: ScheduleOverlapPolicy

  """Whether the schedule is currently paused"""
  paused: Boolean

  """Schedule ID"""
  scheduleId: ID!

  """Schedule specification"""
  spec: ScheduleSpecDetails

  """Schedule state information"""
  state: ScheduleStateInfo

  """Number of successful actions"""
  successfulActions: String

  """Total number of actions taken"""
  totalActions: String
}

input ScheduleListInput {
  """Maximum number of results to return"""
  pageSize: Int = 100

  """Continuation token from previous page"""
  pageToken: String
}

type ScheduleListResult {
  """Continuation token for pagination"""
  nextPageToken: String

  """List of schedule IDs"""
  scheduleIds: [String!]!

  """Total number of schedules"""
  totalCount: Int!
}

"""How to handle overlapping schedule executions"""
enum ScheduleOverlapPolicy {
  ALLOW_ALL
  BUFFER_ONE
  SKIP
}

input SchedulePoliciesInput {
  """Catchup window for missed runs (duration string, e.g., "1 day")"""
  catchupWindow: String

  """How to handle overlapping executions"""
  overlap: ScheduleOverlapPolicy

  """Whether to pause on failure"""
  pauseOnFailure: Boolean
}

type ScheduleSpecDetails {
  """Cron expression (if calendar-based)"""
  cronExpression: String

  """End time"""
  endTime: String

  """Interval in seconds (if interval-based)"""
  intervalSeconds: Float

  """Start time"""
  startTime: String

  """Timezone"""
  timezone: String
}

input ScheduleSpecInput {
  """
  Cron expression for execution schedule (e.g., "0 2 * * *" for daily at 2 AM)
  """
  cronExpression: String

  """End time (ISO 8601 string)"""
  endTime: String

  """Start time (ISO 8601 string)"""
  startTime: String

  """Timezone identifier (IANA tz database)"""
  timezone: String
}

type ScheduleStateInfo {
  """Number of failed actions"""
  failedActions: Float

  """Number of missed actions"""
  missedActions: Float

  """Number of currently running actions"""
  runningActions: Float

  """Number of successful actions"""
  successfulActions: Float

  """Total number of actions"""
  totalActions: Float
}

"""Specific fields to search in"""
enum SearchField {
  ALL
  COURT_NAME
  FULL_TEXT
  KEYWORDS
  LEGAL_AREA
  SIGNATURE
  SUMMARY
}

input SearchLegalDocumentsInput {
  """End date for date range filter (ISO 8601 format)"""
  endDate: String

  """Maximum number of results to return"""
  limit: Int

  """Number of results to skip for pagination"""
  offset: Int

  """Search query for full-text search across title and content"""
  query: String!

  """Filter by session ID"""
  sessionId: String

  """Start date for date range filter (ISO 8601 format)"""
  startDate: String

  """Filter by document status"""
  status: DocumentStatus

  """Filter by document type"""
  type: DocumentType
}

input SearchLegalQueriesInput {
  """End date for date range filter (ISO 8601 format)"""
  endDate: String

  """Maximum number of results to return"""
  limit: Int

  """Number of results to skip for pagination"""
  offset: Int

  """Search query for full-text search across questions and answers"""
  query: String!

  """Filter by session ID"""
  sessionId: String

  """Start date for date range filter (ISO 8601 format)"""
  startDate: String
}

input SearchLegalRulingsInput {
  """Filter by court type"""
  courtType: CourtType

  """Filter by ruling date from (ISO 8601 date string)"""
  dateFrom: String

  """Filter by ruling date to (ISO 8601 date string)"""
  dateTo: String

  """Maximum number of results to return (default: 20, max: 100)"""
  limit: Int = 20

  """Number of results to skip for pagination"""
  offset: Int = 0

  """Search query text"""
  query: String!
}

"""Source of the search result (LOCAL, SAOS, or ISAP)"""
enum SearchSource {
  ISAP
  LOCAL
  SAOS
}

type SendChatMessageResponse {
  """Message content"""
  content: String!

  """Timestamp when the message was created"""
  createdAt: String!

  """The created message ID"""
  messageId: ID!

  """Message role (USER or ASSISTANT)"""
  role: String!

  """Sequence order in the conversation"""
  sequenceOrder: Float!

  """The session ID"""
  sessionId: ID!

  """
  Type of message (text, clarification_question, clarification_answer, citation, error)
  """
  type: ChatMessageType
}

input SendChatMessageWithAIInput {
  """AI response mode (LAWYER or SIMPLE)"""
  mode: String!

  """The user question/message"""
  question: String!

  """Session ID (creates new session if not provided)"""
  sessionId: ID
}

type SendChatMessageWithAIResponse {
  """AI response content (for streaming compatibility)"""
  answerMarkdown: String

  """The AI assistant response"""
  assistantMessage: SendChatMessageResponse

  """Citations from the AI response"""
  citations: [ChatCitation!]

  """Confidence score of the AI response"""
  confidence: Float

  """Key legal terms extracted"""
  keyTerms: [String!]

  """Query type classification"""
  queryType: String

  """The session ID"""
  sessionId: ID!

  """The user message that was sent"""
  userMessage: SendChatMessageResponse!
}

input SendNotificationInput {
  """Optional action label for the action link button"""
  actionLabel: String

  """Optional action link for navigation"""
  actionLink: String

  """Channel to send notification through"""
  channel: NotificationChannel = BOTH

  """Optional custom message for in-app notification"""
  customMessage: String

  """Type of in-app notification for UI styling"""
  inAppType: InAppNotificationType

  """Additional metadata for tracking"""
  metadata: String

  """Priority level of the notification"""
  priority: NotificationPriority = NORMAL

  """Data for template rendering (JSON string)"""
  templateData: String

  """Type of notification template to use"""
  templateType: NotificationTemplateType!

  """User email address"""
  userEmail: String!

  """User ID to receive the notification"""
  userId: String!
}

type SendNotificationResponse {
  """Whether the email notification was sent"""
  emailSent: Boolean!

  """Whether the in-app notification was created"""
  inAppCreated: Boolean!

  """ID of the created in-app notification"""
  notificationId: String
}

type ServiceHealth {
  error: String
  lastCheck: String
  latency: Float
  status: ServiceStatus!
}

"""Health status of a service or system component"""
enum ServiceStatus {
  DEGRADED
  HEALTHY
  UNHEALTHY
}

"""Mode of operation for a user session"""
enum SessionMode {
  LAWYER
  SIMPLE
}

input SessionModeFilterComparison {
  eq: SessionMode
  gt: SessionMode
  gte: SessionMode
  iLike: SessionMode
  in: [SessionMode!]
  is: Boolean
  isNot: Boolean
  like: SessionMode
  lt: SessionMode
  lte: SessionMode
  neq: SessionMode
  notILike: SessionMode
  notIn: [SessionMode!]
  notLike: SessionMode
}

"""System setting categories"""
enum SettingCategory {
  AI
  FEATURE_FLAGS
  GENERAL
  MAINTENANCE
}

"""System setting value types"""
enum SettingValueType {
  BOOLEAN
  JSON
  NUMBER
  STRING
}

input ShareDocumentInput {
  """ID of the document to share"""
  documentId: ID!

  """Optional expiration date for the share (ISO 8601 format)"""
  expiresAt: String

  """Permission level to grant"""
  permission: SharePermission! = VIEW

  """ID of the user to share the document with"""
  sharedWithUserId: ID!
}

"""Permission level for document sharing"""
enum SharePermission {
  ADMIN
  COMMENT
  EDIT
  VIEW
}

"""Sort Directions"""
enum SortDirection {
  ASC
  DESC
}

"""Sort Nulls Options"""
enum SortNulls {
  NULLS_FIRST
  NULLS_LAST
}

input StringFieldComparison {
  eq: String
  gt: String
  gte: String
  iLike: String
  in: [String!]
  is: Boolean
  isNot: Boolean
  like: String
  lt: String
  lte: String
  neq: String
  notILike: String
  notIn: [String!]
  notLike: String
}

input StringFilter {
  eq: String
  iLike: String
  in: [String!]
}

input SubmitClarificationAnswersInput {
  """Array of question-answer pairs"""
  answers: [ClarificationAnswerInput!]!

  """The message ID containing the clarification questions"""
  clarificationMessageId: ID!

  """The session ID"""
  sessionId: ID!
}

type SubmitClarificationAnswersResponse {
  """The clarification message ID that was updated"""
  clarificationMessageId: ID!

  """Whether the submission was successful"""
  success: Boolean!

  """The created user message containing the answers"""
  userMessage: SendChatMessageResponse

  """Validation errors if submission failed"""
  validationErrors: [ClarificationValidationError!]
}

input SubmitLegalQueryInput {
  """The legal question to be answered by the AI"""
  question: String!

  """
  Session ID for the user submitting the query (optional - will be auto-created if not provided)
  """
  sessionId: String
}

type Subscription {
  """Real-time notifications when a new message is added"""
  chatMessageAdded(sessionId: ID!): ChatMessage!

  """Real-time updates when a chat session is modified"""
  chatSessionUpdated(sessionId: ID!): ChatSession!

  """Subscribe to cursor position updates for a document"""
  cursorUpdated(
    """Document ID to receive cursor updates for"""
    documentId: String!
  ): CursorEventPayload!

  """Subscribe to document edits for real-time collaboration"""
  documentEdited(
    """Document ID to receive edit updates for"""
    documentId: String!
  ): DocumentEditEventPayload!

  """Subscribe to document status changes"""
  documentStatusChanged(
    """Filter by document ID"""
    documentId: String

    """Filter by session ID"""
    sessionId: String
  ): DocumentStatusChange!

  """Subscribe to new in-app notifications"""
  inAppNotificationCreated(
    """Filter by user ID"""
    userId: String
  ): InAppNotificationCreatedPayload!

  """Subscribe to user joined events for a document"""
  userJoinedDocument(
    """Document ID to receive user joined events for"""
    documentId: String!
  ): UserJoinedEventPayload!

  """Subscribe to user left events for a document"""
  userLeftDocument(
    """Document ID to receive user left events for"""
    documentId: String!
  ): UserLeftEventPayload!
}

type SubscriptionPlan {
  billingInterval: BillingInterval!
  createdAt: DateTime!
  description: String
  displayOrder: Float!
  features: String!
  id: ID!
  isActive: Boolean!
  maxUsers: Int
  name: String!
  price: Float!
  stripePriceId: String
  stripeYearlyPriceId: String
  tier: PlanTier!
  trialDays: Float!
  updatedAt: DateTime!
  yearlyDiscount: Float!
}

"""Subscription status"""
enum SubscriptionStatus {
  ACTIVE
  CANCELED
  EXPIRED
  PAST_DUE
  TRIALING
}

type SubscriptionUsageStats {
  daysRemaining: Int!
  periodEnd: String!
  periodStart: String!
  planTier: PlanTier!
  subscriptionId: ID!
  usage: String!
}

input SuspendUserInput {
  reason: String!
  userId: ID!
}

type SystemHealthMetrics {
  """Active user sessions (placeholder)"""
  activeSessions: Int!

  """Average AI response time in ms (placeholder)"""
  avgResponseTime: Float!

  """Document generation success rate"""
  documentSuccessRate: Float!
  timestamp: DateTime!
}

type SystemHealthResponse {
  errors: ErrorTrackingStatus!
  services: [ServiceHealth!]
  status: ServiceStatus!
  timestamp: String!
  uptime: Float!
}

type SystemSetting {
  category: SettingCategory!
  createdAt: DateTime!
  description: String
  id: ID!
  key: String!
  metadata: String
  updatedAt: DateTime!
  value: String
  valueType: SettingValueType!
}

input SystemSettingInput {
  category: SettingCategory
  description: String
  key: String!
  metadata: String
  value: String
  valueType: SettingValueType
}

"""Category of legal document template"""
enum TemplateCategory {
  COMPLAINT
  CONTRACT
  LAWSUIT
  LETTER
  MOTION
  OTHER
}

input TemplateCategoryFilterComparison {
  eq: TemplateCategory
  gt: TemplateCategory
  gte: TemplateCategory
  iLike: TemplateCategory
  in: [TemplateCategory!]
  is: Boolean
  isNot: Boolean
  like: TemplateCategory
  lt: TemplateCategory
  lte: TemplateCategory
  neq: TemplateCategory
  notILike: TemplateCategory
  notIn: [TemplateCategory!]
  notLike: TemplateCategory
}

input TemplateVariableInput {
  defaultValue: String
  description: String
  label: String!
  name: String!
  required: Boolean!
  type: String!
  validation: JSON
}

input TestWebhookInput {
  event: String = "test.event"
  payload: String
  webhookId: String!
}

type TestWebhookResponse {
  durationMs: Int!
  error: String
  response: String
  statusCode: Int
  success: Boolean!
}

"""Standard text message from user or assistant"""
type TextChatMessage implements ChatMessageInterface {
  citations: [ChatCitation!]

  """Message content"""
  content: String!

  """Creation timestamp"""
  createdAt: DateTime!

  """Unique message identifier"""
  messageId: ID!

  """Role of the message sender"""
  role: MessageRole!

  """Sequence order in conversation"""
  sequenceOrder: Float!

  """Session ID"""
  sessionId: ID!

  """Message type discriminator for resolving concrete types"""
  type: ChatMessageType
}

"""Available theme options for the UI"""
enum ThemePreference {
  DARK
  LIGHT
  SYSTEM
}

input ThemePreferenceFilterComparison {
  eq: ThemePreference
  gt: ThemePreference
  gte: ThemePreference
  iLike: ThemePreference
  in: [ThemePreference!]
  is: Boolean
  isNot: Boolean
  like: ThemePreference
  lt: ThemePreference
  lte: ThemePreference
  neq: ThemePreference
  notILike: ThemePreference
  notIn: [ThemePreference!]
  notLike: ThemePreference
}

"""
`Date` type as integer. Type represents date and time as number of milliseconds from start of UNIX epoch.
"""
scalar Timestamp

type TokenUsage {
  """Completion tokens used"""
  completionTokens: Int!

  """Prompt tokens used"""
  promptTokens: Int!

  """Estimated cost in USD"""
  totalCost: Float!

  """Total tokens used"""
  totalTokens: Int!
}

type TokenUsageAnalytics {
  """All-time total cost"""
  allTimeCost: Float!

  """All-time total tokens"""
  allTimeTokens: Int!

  """Detected usage anomalies"""
  anomalies: [UsageAnomaly!]!

  """Average tokens per query"""
  avgTokensPerQuery: Int!

  """Breakdown by operation type"""
  byOperation: [TokenUsageByOperation!]!
  generatedAt: DateTime!
  periodEnd: DateTime!
  periodStart: DateTime!

  """Cost this month"""
  thisMonthCost: Float!

  """Tokens this month"""
  thisMonthTokens: Int!

  """Cost today"""
  todayCost: Float!

  """Tokens today"""
  todayTokens: Int!

  """Token usage over time"""
  trend: [TokenUsageTrend!]!

  """Per-user usage leaderboard"""
  userLeaderboard: [UserTokenUsage!]!
}

type TokenUsageBreakdown {
  periodEnd: DateTime!
  periodStart: DateTime!

  """Total cost in USD"""
  totalCost: Float!

  """Total requests"""
  totalRequests: Int!

  """Total tokens used"""
  totalTokens: Int!
}

type TokenUsageByAgent {
  """Agent type"""
  agentType: AgentType!

  """Average tokens per request"""
  avgTokensPerRequest: Int!

  """Total request count"""
  requestCount: Int!

  """Percentage of total tokens"""
  tokenPercentage: Float!

  """Total cost in USD"""
  totalCost: Float!

  """Total tokens used"""
  totalTokens: Int!
}

type TokenUsageByOperation {
  """Average tokens per request"""
  avgTokensPerRequest: Int!

  """Percentage of total cost"""
  costPercentage: Float!
  operationType: AiOperationType!
  requestCount: Int!

  """Percentage of total tokens"""
  tokenPercentage: Float!
  totalCost: Float!
  totalTokens: Int!
}

type TokenUsageExport {
  exportedAt: DateTime!
  operationBreakdown: [TokenUsageByOperation!]!
  periodEnd: DateTime!
  periodStart: DateTime!
  trendData: [TokenUsageTrend!]!
  userUsageData: [UserTokenUsage!]!
}

type TokenUsageTrend {
  """Percentage change from previous period"""
  changePercentage: Float
  cost: Float!
  requests: Int!
  timestamp: DateTime!
  tokens: Int!
}

"""Level of a Langfuse trace"""
enum TraceLevel {
  DEBUG
  DEFAULT
  ERROR
  INFO
  WARNING
}

type TraceObservation {
  """Duration in milliseconds"""
  duration: Float

  """Timestamp when observation ended"""
  endTime: Timestamp

  """Error message if failed"""
  errorMessage: String

  """Unique observation ID"""
  id: ID!

  """Input prompt(s)"""
  input: [String!]

  """Observation level"""
  level: TraceLevel

  """Metadata associated with the observation"""
  metadata: JSON

  """Model used (for generations)"""
  model: String

  """Observation name"""
  name: String!

  """Output completion(s)"""
  output: [String!]

  """Parent observation ID if nested"""
  parentObservationId: String

  """Stack trace if failed"""
  stackTrace: String

  """Timestamp when observation started"""
  startTime: Timestamp!

  """Observation status"""
  status: TraceStatus

  """Type of observation"""
  type: ObservationType!

  """Token usage (for generations)"""
  usage: TokenUsage
}

"""Status of a Langfuse trace"""
enum TraceStatus {
  ERROR
  SUCCESS
  UNKNOWN
}

input TracesListInput {
  """Filter by agent type"""
  agentType: AgentType

  """End date for filtering (ISO 8601)"""
  endDate: String

  """Number of items per page"""
  limit: Int = 20

  """Page number (1-indexed)"""
  page: Int = 1

  """Search term for filtering"""
  searchTerm: String

  """Filter by session ID"""
  sessionId: String

  """Sort field"""
  sortBy: String = "createdAt"

  """Sort order (ASC or DESC)"""
  sortOrder: String = "DESC"

  """Start date for filtering (ISO 8601)"""
  startDate: String

  """Filter by trace status"""
  status: TraceStatus

  """Filter by user ID"""
  userId: String
}

type TracesListResponse {
  """When this data was fetched"""
  fetchedAt: Timestamp!

  """Number of items per page"""
  limit: Int!

  """Current page number (1-indexed)"""
  page: Int!

  """Total number of traces matching the filter"""
  totalCount: Int!

  """Total number of pages"""
  totalPages: Int!

  """List of traces"""
  traces: [LangfuseTrace!]!
}

type TwoFactorSettings {
  """True if 2FA is fully enabled"""
  enabled: Boolean!

  """Timestamp when 2FA was last verified/enabled"""
  lastVerifiedAt: DateTime

  """Number of remaining backup codes"""
  remainingBackupCodes: Int

  """Current 2FA status"""
  status: TwoFactorStatus!
}

"""Status of two-factor authentication"""
enum TwoFactorStatus {
  DISABLED
  ENABLED
  PENDING
}

input UpdateApiKeyInput {
  description: String
  expiresAt: String
  name: String
  rateLimitPerMinute: Int
  scopes: [ApiKeyScope!]
}

input UpdateChatSessionInput {
  """Update pinned status"""
  isPinned: Boolean

  """Update AI response mode"""
  mode: ChatMode

  """Update session title"""
  title: String
}

input UpdateChatSessionTitleInput {
  """Session ID to update"""
  sessionId: ID!

  """New title for the session"""
  title: String!
}

input UpdateClarificationStatusInput {
  """Whether the clarification has been answered"""
  answered: Boolean!

  """JSON string of question-answer pairs"""
  answers: String

  """The message ID containing the clarification"""
  messageId: ID!
}

type UpdateClarificationStatusResponse {
  """The message ID that was updated"""
  messageId: ID!

  """The updated clarification status"""
  status: String

  """Whether the update was successful"""
  success: Boolean!
}

input UpdateDemoRequestStatusInput {
  demoRequestId: ID!
  status: String!
}

input UpdateDocumentCommentInput {
  position: CreateCommentPositionInput
  resolutionStatus: CommentResolutionStatus

  """
  ID of the user who resolved the comment (required when marking as resolved)
  """
  resolvedBy: String
  text: String
}

input UpdateDocumentInput {
  metadata: DocumentMetadataInput
  title: String
}

input UpdateDocumentTemplateInput {
  category: TemplateCategory
  conditionalSections: [ConditionalSectionInput!]
  content: String
  description: String
  isActive: String
  name: String
  polishFormattingRules: PolishFormattingRulesInput
  variables: [TemplateVariableInput!]
}

input UpdateDocumentTitleInputV2 {
  documentId: ID!
  title: String!
  updatedBy: ID!
}

input UpdateDocumentVersionInput {
  changeDescription: String
}

input UpdateInAppNotificationInput {
  """Optional action label for the action link button"""
  actionLabel: String

  """Optional action link for navigation"""
  actionLink: String

  """The notification message content"""
  message: String

  """Additional metadata for extensibility (JSON string)"""
  metadata: String

  """Read status"""
  read: Boolean

  """Type of notification for UI styling"""
  type: String
}

input UpdateLegalAnalysisInput {
  identifiedGrounds: [LegalGroundInput!]
  inputDescription: String
  metadata: AnalysisMetadataInput
  overallConfidenceScore: Float
  recommendations: String
  relatedDocumentLinks: [RelatedDocumentLinkInput!]
  summary: String
  title: String
}

input UpdateLegalDocumentInput {
  contentRaw: String
  metadata: CreateDocumentMetadataInput

  """Signed URL to download the PDF version of this document"""
  pdfUrl: String
  title: String
  type: DocumentType
}

input UpdateLegalQueryInput {
  answerMarkdown: String
  citations: [CreateCitationInput!]
  question: String
}

input UpdateLegalRulingInput {
  courtName: String
  courtType: CourtType
  fullText: String
  metadata: CreateRulingMetadataInput
  rulingDate: String
  signature: String
  summary: String
}

input UpdateNotificationInput {
  """Error message if sending failed"""
  errorMessage: String

  """SendGrid message ID"""
  messageId: String

  """Additional metadata (JSON string)"""
  metadata: String

  """Recipient email address"""
  recipientEmail: String

  """Timestamp when email was sent"""
  sentAt: String

  """Notification status"""
  status: NotificationStatus

  """Email subject line"""
  subject: String

  """Email template type"""
  template: EmailTemplateType

  """Template data for rendering (JSON string)"""
  templateData: String

  """User ID"""
  userId: String
}

input UpdateOneChatSessionInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateChatSessionInput!
}

input UpdateOneDocumentCommentInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateDocumentCommentInput!
}

input UpdateOneDocumentTemplateInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateDocumentTemplateInput!
}

input UpdateOneDocumentVersionInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateDocumentVersionInput!
}

input UpdateOneInAppNotificationInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateInAppNotificationInput!
}

input UpdateOneLegalAnalysisInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateLegalAnalysisInput!
}

input UpdateOneLegalDocumentInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateLegalDocumentInput!
}

input UpdateOneLegalQueryInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateLegalQueryInput!
}

input UpdateOneLegalRulingInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateLegalRulingInput!
}

input UpdateOneNotificationInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateNotificationInput!
}

input UpdateOneUserPreferencesInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateUserPreferencesInput!
}

input UpdateProfileInput {
  """Email address"""
  email: String

  """First name"""
  firstName: String

  """Last name"""
  lastName: String

  """Username"""
  username: String
}

input UpdateSharePermissionInput {
  """New permission level"""
  permission: SharePermission!

  """ID of the share to update"""
  shareId: ID!
}

input UpdateSubscriptionPlanInput {
  billingInterval: BillingInterval
  description: String
  displayOrder: Int
  features: String
  isActive: Boolean
  maxUsers: Int
  name: String
  price: Int
  stripePriceId: String
  stripeYearlyPriceId: String
  trialDays: Int
  yearlyDiscount: Int
}

input UpdateTemplateInput {
  category: TemplateCategory
  conditionalSections: JSON
  content: String
  description: String
  isActive: Boolean
  name: String
  polishFormattingRules: JSON
  variables: JSON
}

input UpdateUserInput {
  disclaimerAccepted: Boolean
  email: String
  firstName: String
  isActive: Boolean
  lastName: String
  username: String
}

input UpdateUserPreferencesInput {
  aiModel: AiModelType
  dateFormat: String
  emailNotifications: Boolean
  inAppNotifications: Boolean
  locale: String
  notificationPreferences: NotificationPreferencesInput
  theme: ThemePreference
  timezone: String
}

input UpdateWebhookInput {
  description: String
  events: [WebhookEvent!]
  headers: String
  maxRetries: Int
  name: String
  status: WebhookStatus
  timeoutMs: Int
  url: String
}

type UsageAnomaly {
  """Type of anomaly detected"""
  anomalyType: String!

  """Description of the anomaly"""
  description: String!
  detectedAt: DateTime!

  """Deviation from expected (percentage)"""
  deviationPercentage: Float!

  """Expected/normal token count"""
  expectedValue: Float!

  """Token count that triggered the anomaly"""
  tokenCount: Int!
  userEmail: String
  userId: ID
}

input UsageStatsQueryInput {
  endDate: DateTime
  operationType: AiOperationType
  startDate: DateTime
  userId: ID
}

type UsageStatsResponse {
  breakdownByOperation: [OperationBreakdown!]
  operationCount: Int!
  periodEnd: DateTime!
  periodStart: DateTime!
  totalCost: Float!
  totalRequests: Int!
  totalTokens: Int!
}

type User {
  createdAt: DateTime!
  disclaimerAccepted: Boolean!
  disclaimerAcceptedAt: DateTime
  email: String!
  firstName: String
  id: ID!
  isActive: Boolean!
  lastName: String
  role: String!

  """
  Array of user roles (single role wrapped as array for consistency with JWT format)
  """
  roles: [String!]!
  stripeCustomerId: String
  twoFactorEnabled: Boolean!
  twoFactorVerifiedAt: DateTime
  updatedAt: DateTime!
  username: String
}

input UserFilter {
  email: StringFilter
  isActive: BooleanFilter
  role: StringFilter
  username: StringFilter
}

type UserGrowthMetrics {
  activeUsers: Int!
  adminUsers: Int!

  """Growth rate as percentage"""
  growthRate: Float!
  newUsers: Int!
  periodEnd: DateTime!
  periodStart: DateTime!
  totalUsers: Int!
}

type UserGrowthStats {
  """Average growth rate"""
  avgGrowthRate: Float!
  newUsersPerPeriod: [AnalyticsTimeSeriesPoint!]!
  periodEnd: DateTime!
  periodStart: DateTime!

  """Total new users in range"""
  totalNewUsers: Int!
}

type UserJoinedEventPayload {
  color: String
  documentId: ID!
  timestamp: DateTime!
  userId: ID!
  userName: String!
}

type UserLeftEventPayload {
  documentId: ID!
  timestamp: DateTime!
  userId: ID!
  userName: String!
}

input UserPaging {
  after: String
  first: Int
}

type UserPreferences {
  aiModel: AiModelType!
  createdAt: DateTime!
  dateFormat: String
  emailNotifications: Boolean!
  getNotificationPreferences: NotificationPreferences!
  id: ID!
  inAppNotifications: Boolean!
  locale: String!
  theme: ThemePreference!
  timezone: String
  updatedAt: DateTime!
  user: User!
  userId: String!
}

input UserPreferencesAggregateFilter {
  aiModel: AiModelTypeFilterComparison
  and: [UserPreferencesAggregateFilter!]
  createdAt: DateFieldComparison
  emailNotifications: BooleanFieldComparison
  id: IDFilterComparison
  inAppNotifications: BooleanFieldComparison
  locale: StringFieldComparison
  or: [UserPreferencesAggregateFilter!]
  theme: ThemePreferenceFilterComparison
  updatedAt: DateFieldComparison
  userId: StringFieldComparison
}

type UserPreferencesAggregateGroupBy {
  aiModel: AiModelType
  createdAt(by: GroupBy! = DAY): DateTime
  emailNotifications: Boolean
  id: ID
  inAppNotifications: Boolean
  locale: String
  theme: ThemePreference
  updatedAt(by: GroupBy! = DAY): DateTime
  userId: String
}

type UserPreferencesAggregateResponse {
  count: UserPreferencesCountAggregate
  groupBy: UserPreferencesAggregateGroupBy
  max: UserPreferencesMaxAggregate
  min: UserPreferencesMinAggregate
}

type UserPreferencesConnection {
  """Array of edges."""
  edges: [UserPreferencesEdge!]!

  """Paging information"""
  pageInfo: PageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type UserPreferencesCountAggregate {
  aiModel: Int
  createdAt: Int
  emailNotifications: Int
  id: Int
  inAppNotifications: Int
  locale: Int
  theme: Int
  updatedAt: Int
  userId: Int
}

type UserPreferencesDeleteResponse {
  aiModel: AiModelType
  createdAt: DateTime
  dateFormat: String
  emailNotifications: Boolean
  id: ID
  inAppNotifications: Boolean
  locale: String
  theme: ThemePreference
  timezone: String
  updatedAt: DateTime
  userId: String
}

type UserPreferencesEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the UserPreferences"""
  node: UserPreferences!
}

input UserPreferencesFilter {
  aiModel: AiModelTypeFilterComparison
  and: [UserPreferencesFilter!]
  createdAt: DateFieldComparison
  emailNotifications: BooleanFieldComparison
  id: IDFilterComparison
  inAppNotifications: BooleanFieldComparison
  locale: StringFieldComparison
  or: [UserPreferencesFilter!]
  theme: ThemePreferenceFilterComparison
  updatedAt: DateFieldComparison
  userId: StringFieldComparison
}

type UserPreferencesMaxAggregate {
  aiModel: AiModelType
  createdAt: DateTime
  id: ID
  locale: String
  theme: ThemePreference
  updatedAt: DateTime
  userId: String
}

type UserPreferencesMinAggregate {
  aiModel: AiModelType
  createdAt: DateTime
  id: ID
  locale: String
  theme: ThemePreference
  updatedAt: DateTime
  userId: String
}

input UserPreferencesSort {
  direction: SortDirection!
  field: UserPreferencesSortFields!
  nulls: SortNulls
}

enum UserPreferencesSortFields {
  aiModel
  createdAt
  emailNotifications
  id
  inAppNotifications
  locale
  theme
  updatedAt
  userId
}

"""
User role with hierarchy: SUPER_ADMIN(5) > ADMIN(4) > LAWYER(3) > PARALEGAL(2) > CLIENT(1) > GUEST(0)
"""
enum UserRole {
  ADMIN
  CLIENT
  GUEST
  LAWYER
  PARALEGAL
  SUPER_ADMIN
}

type UserSession {
  createdAt: DateTime!
  endedAt: DateTime
  id: ID!
  mode: SessionMode!
  startedAt: DateTime
  updatedAt: DateTime!
  user: User!
  userId: String!
}

input UserSessionAggregateFilter {
  and: [UserSessionAggregateFilter!]
  createdAt: DateFieldComparison
  id: IDFilterComparison
  mode: SessionModeFilterComparison
  or: [UserSessionAggregateFilter!]
  updatedAt: DateFieldComparison
  userId: StringFieldComparison
}

type UserSessionAggregateGroupBy {
  createdAt(by: GroupBy! = DAY): DateTime
  id: ID
  mode: SessionMode
  updatedAt(by: GroupBy! = DAY): DateTime
  userId: String
}

type UserSessionAggregateResponse {
  count: UserSessionCountAggregate
  groupBy: UserSessionAggregateGroupBy
  max: UserSessionMaxAggregate
  min: UserSessionMinAggregate
}

type UserSessionConnection {
  """Array of edges."""
  edges: [UserSessionEdge!]!

  """Paging information"""
  pageInfo: PageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type UserSessionCountAggregate {
  createdAt: Int
  id: Int
  mode: Int
  updatedAt: Int
  userId: Int
}

type UserSessionDeleteResponse {
  createdAt: DateTime
  endedAt: DateTime
  id: ID
  mode: SessionMode
  startedAt: DateTime
  updatedAt: DateTime
  userId: String
}

type UserSessionEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the UserSession"""
  node: UserSession!
}

input UserSessionFilter {
  and: [UserSessionFilter!]
  createdAt: DateFieldComparison
  id: IDFilterComparison
  mode: SessionModeFilterComparison
  or: [UserSessionFilter!]
  updatedAt: DateFieldComparison
  userId: StringFieldComparison
}

type UserSessionMaxAggregate {
  createdAt: DateTime
  id: ID
  mode: SessionMode
  updatedAt: DateTime
  userId: String
}

type UserSessionMinAggregate {
  createdAt: DateTime
  id: ID
  mode: SessionMode
  updatedAt: DateTime
  userId: String
}

input UserSessionSort {
  direction: SortDirection!
  field: UserSessionSortFields!
  nulls: SortNulls
}

enum UserSessionSortFields {
  createdAt
  id
  mode
  updatedAt
  userId
}

input UserSort {
  direction: String!
  field: String!
}

type UserSubscription {
  cancelAtPeriodEnd: Boolean!
  canceledAt: DateTime
  createdAt: DateTime!
  currentPeriodEnd: DateTime!
  currentPeriodStart: DateTime!
  id: ID!
  lastPaymentAmount: Int
  lastPaymentAt: DateTime
  planId: String!
  startDate: DateTime!
  status: SubscriptionStatus!
  stripeCustomerId: String
  stripeSubscriptionId: String
  trialEndDate: DateTime
  updatedAt: DateTime!
  usage: String!
  userId: String!
}

type UserTokenUsage {
  """Average tokens per request"""
  avgTokensPerRequest: Float!
  periodEnd: DateTime!
  periodStart: DateTime!

  """Number of requests"""
  requestCount: Int!

  """Total cost in USD"""
  totalCost: Float!

  """Total tokens used by this user"""
  totalTokens: Int!
  userEmail: String
  userId: ID!
  userName: String
}

type UserTraceAttribution {
  """First trace timestamp"""
  firstTraceAt: Timestamp!

  """Last trace timestamp"""
  lastTraceAt: Timestamp!

  """Total cost in USD"""
  totalCost: Float!

  """Total tokens used"""
  totalTokens: Int!

  """Total trace count"""
  traceCount: Int!

  """User email"""
  userEmail: String

  """User ID"""
  userId: String!
}

input ValidateApiKeyInput {
  rawKey: String!
  requiredScopes: [ApiKeyScope!]
}

type ValidateApiKeyResponse {
  apiKeyId: ID
  isValid: Boolean!
  message: String
  scopes: [ApiKeyScope!]
  status: ApiKeyStatus
  userId: ID
}

input VerifyTwoFactorSetupInput {
  """The 6-digit TOTP token from authenticator app"""
  token: String!
}

type VerifyTwoFactorSetupResponse {
  """Backup codes for account recovery"""
  backupCodes: [String!]

  """True if verification was successful"""
  success: Boolean!
}

type Webhook {
  createdAt: DateTime!
  description: String
  events: [WebhookEvent!]!
  failureCount: Float!
  headers: String
  id: ID!
  lastDeliveryAt: DateTime
  lastSuccessAt: DateTime
  maxRetries: Float!
  name: String!
  status: WebhookStatus!
  successCount: Float!
  timeoutMs: Float!
  updatedAt: DateTime!
  url: String!
  userId: String!
}

type WebhookDelivery {
  attemptCount: Int!
  createdAt: DateTime!
  durationMs: Int
  errorMessage: String
  event: String!
  httpResponseCode: Int
  id: ID!
  jobId: String
  nextRetryAt: DateTime
  payload: String!
  responseBody: String
  status: DeliveryStatus!
  webhookId: String!
}

"""Events that can be subscribed to"""
enum WebhookEvent {
  DOCUMENT_CREATED
  DOCUMENT_DELETED
  DOCUMENT_EXPORTED
  DOCUMENT_GENERATION_COMPLETED
  DOCUMENT_UPDATED
  QUERY_ANSWERED
  QUERY_ASKED
  SUBSCRIPTION_CANCELLED
  SUBSCRIPTION_CREATED
  SUBSCRIPTION_UPGRADED
  USER_CREATED
  USER_UPDATED
}

type WebhookStats {
  activeWebhooks: Int!
  failedDeliveries: Int!
  pendingDeliveries: Int!
  successfulDeliveries: Int!
  totalDeliveries: Int!
  totalWebhooks: Int!
}

"""Webhook status"""
enum WebhookStatus {
  ACTIVE
  DISABLED
  INACTIVE
}

type WorkerStatusEntry {
  """Whether the worker is running"""
  running: Boolean!

  """Task queue this worker processes"""
  taskQueue: String!

  """Worker uptime in seconds"""
  uptimeSeconds: Int

  """Worker ID for tracking"""
  workerId: String
}

type WorkerStatusResult {
  """Number of workers currently running"""
  runningWorkers: Int!

  """Overall health status"""
  status: String

  """Total number of workers"""
  totalWorkers: Int!

  """List of worker status entries"""
  workers: [WorkerStatusEntry!]!
}