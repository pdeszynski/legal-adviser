# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

input ActivateUserInput {
  userId: ID!
}

type AdvancedLegalRulingSearchResponse {
  """Number of results returned"""
  count: Int!

  """Whether there are more results"""
  hasMore: Boolean!

  """Current offset"""
  offset: Int!

  """Human-readable explanation of the search query that was executed"""
  queryExplanation: String

  """Search results with relevance ranking"""
  results: [AggregatedLegalRulingSearchResult!]!

  """Total number of matching results (for pagination)"""
  totalCount: Int!
}

input AdvancedSearchLegalRulingsInput {
  """Filter by court type"""
  courtType: CourtType

  """Filter by ruling date from (ISO 8601 date string)"""
  dateFrom: String

  """Filter by ruling date to (ISO 8601 date string)"""
  dateTo: String

  """Filter by keywords (must match all)"""
  keywords: [String!]

  """Filter by legal area from metadata"""
  legalArea: String

  """Maximum number of results to return (default: 20, max: 100)"""
  limit: Int = 20

  """Number of results to skip for pagination"""
  offset: Int = 0

  """Array of search terms with operators and field specifications"""
  searchTerms: [AdvancedSearchTermInput!]!

  """Sources to search (default: all sources)"""
  sources: [SearchSource!] = [LOCAL, SAOS, ISAP]
}

input AdvancedSearchTermInput {
  """Field to search in (default: ALL)"""
  field: SearchField! = ALL

  """Boolean operator to combine with previous term (default: AND)"""
  operator: BooleanOperator! = AND

  """Search term text"""
  term: String!
}

type AggregatedLegalRulingSearchResponse {
  """Number of results returned"""
  count: Int!

  """Whether there are more results"""
  hasMore: Boolean!

  """Current offset"""
  offset: Int!

  """Search results with relevance ranking from multiple sources"""
  results: [AggregatedLegalRulingSearchResult!]!

  """Total number of matching results (for pagination)"""
  totalCount: Int!
}

type AggregatedLegalRulingSearchResult {
  """Highlighted snippet of matching content"""
  headline: String

  """Relevance score (higher is better)"""
  rank: Float!

  """The matching legal ruling"""
  ruling: LegalRuling!

  """Source of the result"""
  source: SearchSource!
}

input AggregatedSearchLegalRulingsInput {
  """Filter by court type"""
  courtType: CourtType

  """Filter by ruling date from (ISO 8601 date string)"""
  dateFrom: String

  """Filter by ruling date to (ISO 8601 date string)"""
  dateTo: String

  """Maximum number of results to return (default: 20, max: 100)"""
  limit: Int = 20

  """Number of results to skip for pagination"""
  offset: Int = 0

  """Search query text"""
  query: String!

  """Sources to search (default: all sources)"""
  sources: [SearchSource!] = [LOCAL, SAOS, ISAP]
}

"""Available AI models for legal operations"""
enum AiModelType {
  CLAUDE_3_OPUS
  CLAUDE_3_SONNET
  GPT_3_5_TURBO
  GPT_4
  GPT_4_TURBO
}

input AiModelTypeFilterComparison {
  eq: AiModelType
  gt: AiModelType
  gte: AiModelType
  iLike: AiModelType
  in: [AiModelType!]
  is: Boolean
  isNot: Boolean
  like: AiModelType
  lt: AiModelType
  lte: AiModelType
  neq: AiModelType
  notILike: AiModelType
  notIn: [AiModelType!]
  notLike: AiModelType
}

type AiOperationBreakdown {
  """Percentage of total cost"""
  costPercentage: Float!
  operationType: String!
  requestCount: Int!
  totalCost: Float!
  totalTokens: Int!
}

enum AiOperationType {
  CASE_CLASSIFICATION
  DOCUMENT_GENERATION
  EMBEDDING_GENERATION
  QUESTION_ANSWERING
  RAG_QUESTION_ANSWERING
  RULING_SEARCH
  SEMANTIC_SEARCH
}

type AiUsageMetrics {
  """Average cost per request"""
  avgCostPerRequest: Float!

  """Average tokens per request"""
  avgTokensPerRequest: Int!
  periodEnd: DateTime!
  periodStart: DateTime!

  """Total cost in USD"""
  totalCost: Float!
  totalRequests: Int!
  totalTokens: Int!
}

type AiUsageRecord {
  costCalculated: Float!
  createdAt: DateTime!
  id: ID!
  metadata: String
  operationType: AiOperationType!
  requestCount: Float!
  resourceId: ID
  tokensUsed: Float!
  userId: String!
}

type AnalysisMetadata {
  analysisVersion: String
  modelUsed: String
  processingTimeMs: Float
}

input AnalysisMetadataInput {
  analysisVersion: String
  modelUsed: String
  processingTimeMs: Float
}

"""Status of the legal analysis process"""
enum AnalysisStatus {
  COMPLETED
  FAILED
  PENDING
  PROCESSING
}

input AnalysisStatusFilterComparison {
  eq: AnalysisStatus
  gt: AnalysisStatus
  gte: AnalysisStatus
  iLike: AnalysisStatus
  in: [AnalysisStatus!]
  is: Boolean
  isNot: Boolean
  like: AnalysisStatus
  lt: AnalysisStatus
  lte: AnalysisStatus
  neq: AnalysisStatus
  notILike: AnalysisStatus
  notIn: [AnalysisStatus!]
  notLike: AnalysisStatus
}

type AnalyticsDashboard {
  aiOperationBreakdown: [AiOperationBreakdown!]!
  aiUsage: AiUsageMetrics!
  documentTypeDistribution: [DocumentTypeDistribution!]!
  documents: DocumentMetrics!
  generatedAt: DateTime!
  queries: QueryMetrics!
  systemHealth: SystemHealthMetrics!
  userGrowth: UserGrowthMetrics!
}

"""Time period granularity for analytics data"""
enum AnalyticsPeriod {
  DAILY
  HOURLY
  MONTHLY
  WEEKLY
  YEARLY
}

input AnswerLegalQueryInput {
  """The AI-generated answer in Markdown format"""
  answerMarkdown: String!

  """Citations and references for the answer"""
  citations: [CreateCitationInput!]
}

type ApiKey {
  createdAt: DateTime!
  description: String
  expiresAt: DateTime
  id: ID!
  keyPrefix: String!
  lastUsedAt: DateTime
  lastUsedIp: String
  name: String!
  rateLimitPerMinute: Int
  scopes: [ApiKeyScope!]!
  status: ApiKeyStatus!
  updatedAt: DateTime!
  usageCount: Float!
  userId: String!
}

"""API key scopes/permissions"""
enum ApiKeyScope {
  AI_ANALYZE
  AI_GENERATE
  DOCUMENTS_DELETE
  DOCUMENTS_READ
  DOCUMENTS_WRITE
  PROFILE_READ
  PROFILE_WRITE
  QUERIES_DELETE
  QUERIES_READ
  QUERIES_WRITE
  RULINGS_READ
  RULINGS_SEARCH
  TEMPLATES_READ
  TEMPLATES_WRITE
}

"""API key status"""
enum ApiKeyStatus {
  ACTIVE
  EXPIRED
  REVOKED
}

input ApproveDocumentInput {
  """Document ID to approve"""
  documentId: ID!

  """Optional reason for approval"""
  reason: String
}

input AskLegalQuestionInput {
  """
  Response mode: LAWYER (detailed legal analysis) or SIMPLE (layperson-friendly)
  """
  mode: String

  """The legal question to ask the AI"""
  question: String!

  """Session ID for the user asking the question"""
  sessionId: String!
}

"""Type of action performed"""
enum AuditActionType {
  CREATE
  DELETE
  EXPORT
  LOGIN
  LOGOUT
  READ
  UPDATE
}

input AuditActionTypeFilterComparison {
  eq: AuditActionType
  gt: AuditActionType
  gte: AuditActionType
  iLike: AuditActionType
  in: [AuditActionType!]
  is: Boolean
  isNot: Boolean
  like: AuditActionType
  lt: AuditActionType
  lte: AuditActionType
  neq: AuditActionType
  notILike: AuditActionType
  notIn: [AuditActionType!]
  notLike: AuditActionType
}

type AuditLog {
  action: AuditActionType!
  changeDetails: JSON
  createdAt: DateTime!
  errorMessage: String
  id: ID!
  ipAddress: String
  resourceId: String
  resourceType: AuditResourceType!
  statusCode: Int
  updatedAt: DateTime!
  user: User
  userAgent: String
  userId: String
}

input AuditLogAggregateFilter {
  action: AuditActionTypeFilterComparison
  and: [AuditLogAggregateFilter!]
  createdAt: DateFieldComparison
  id: IDFilterComparison
  ipAddress: StringFieldComparison
  or: [AuditLogAggregateFilter!]
  resourceId: StringFieldComparison
  resourceType: AuditResourceTypeFilterComparison
  updatedAt: DateFieldComparison
  userId: StringFieldComparison
}

type AuditLogAggregateGroupBy {
  action: AuditActionType
  createdAt(by: GroupBy! = DAY): DateTime
  id: ID
  ipAddress: String
  resourceId: String
  resourceType: AuditResourceType
  updatedAt(by: GroupBy! = DAY): DateTime
  userId: String
}

type AuditLogAggregateResponse {
  count: AuditLogCountAggregate
  groupBy: AuditLogAggregateGroupBy
  max: AuditLogMaxAggregate
  min: AuditLogMinAggregate
}

type AuditLogConnection {
  """Array of edges."""
  edges: [AuditLogEdge!]!

  """Paging information"""
  pageInfo: PageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type AuditLogCountAggregate {
  action: Int
  createdAt: Int
  id: Int
  ipAddress: Int
  resourceId: Int
  resourceType: Int
  updatedAt: Int
  userId: Int
}

type AuditLogEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the AuditLog"""
  node: AuditLog!
}

input AuditLogFilter {
  action: AuditActionTypeFilterComparison
  and: [AuditLogFilter!]
  createdAt: DateFieldComparison
  id: IDFilterComparison
  ipAddress: StringFieldComparison
  or: [AuditLogFilter!]
  resourceId: StringFieldComparison
  resourceType: AuditResourceTypeFilterComparison
  updatedAt: DateFieldComparison
  userId: StringFieldComparison
}

type AuditLogMaxAggregate {
  action: AuditActionType
  createdAt: DateTime
  id: ID
  ipAddress: String
  resourceId: String
  resourceType: AuditResourceType
  updatedAt: DateTime
  userId: String
}

type AuditLogMinAggregate {
  action: AuditActionType
  createdAt: DateTime
  id: ID
  ipAddress: String
  resourceId: String
  resourceType: AuditResourceType
  updatedAt: DateTime
  userId: String
}

input AuditLogSort {
  direction: SortDirection!
  field: AuditLogSortFields!
  nulls: SortNulls
}

enum AuditLogSortFields {
  action
  createdAt
  id
  ipAddress
  resourceId
  resourceType
  updatedAt
  userId
}

"""Type of resource affected"""
enum AuditResourceType {
  DOCUMENT
  SESSION
  SYSTEM
  USER
}

input AuditResourceTypeFilterComparison {
  eq: AuditResourceType
  gt: AuditResourceType
  gte: AuditResourceType
  iLike: AuditResourceType
  in: [AuditResourceType!]
  is: Boolean
  isNot: Boolean
  like: AuditResourceType
  lt: AuditResourceType
  lte: AuditResourceType
  neq: AuditResourceType
  notILike: AuditResourceType
  notIn: [AuditResourceType!]
  notLike: AuditResourceType
}

type AuthPayload {
  """JWT access token"""
  accessToken: String!

  """JWT refresh token for obtaining new access tokens"""
  refreshToken: String!

  """Authenticated user information"""
  user: AuthUser!
}

type AuthUser {
  disclaimerAccepted: Boolean!
  disclaimerAcceptedAt: DateTime
  email: String!
  firstName: String
  id: ID!
  isActive: Boolean!
  lastName: String
  role: String!
  username: String
}

type Backup {
  createdAt: Timestamp
  expiresAt: Timestamp
  filename: String!
  id: ID!
  isRestored: Boolean!
  metadata: BackupMetadata
  restoreDate: Timestamp
  sizeBytes: Int!

  """Size in human-readable format (MB)"""
  sizeMB: Float!
  status: String!
  storagePath: String
  storageType: String!
}

type BackupMetadata {
  compression: String
  database: String!
  host: String!
  pgVersion: String
}

type BackupStats {
  activeBackups: Int!
  failedBackups: Int!
  lastBackupDate: Timestamp
  lastSuccessfulBackupDate: Timestamp
  successfulBackups: Int!
  totalBackups: Int!
  totalSizeMB: Float!
}

type BillingInfo {
  cancelAtPeriodEnd: Boolean!
  currentPeriodEnd: String!
  currentPeriodStart: String!
  daysRemaining: Int!
  nextBillingAmount: String
  paymentHistory: [PaymentHistoryItem!]!
  paymentMethods: [PaymentMethodInfo!]
  planName: String!
  planTier: PlanTier!
  status: SubscriptionStatus!
  subscriptionId: ID!
  usage: String!
}

"""Billing interval options"""
enum BillingInterval {
  MONTHLY
  YEARLY
}

input BooleanFieldComparison {
  is: Boolean
  isNot: Boolean
}

"""Boolean operators for combining search terms"""
enum BooleanOperator {
  AND
  NOT
  OR
}

input BulkSendNotificationInput {
  """Channel to send notification through"""
  channel: NotificationChannel

  """Custom message override"""
  customMessage: String

  """Data for template rendering (JSON string)"""
  templateData: String

  """Type of notification template to use"""
  templateType: NotificationTemplateType!

  """List of user IDs"""
  userIds: [String!]!
}

type BulkSendNotificationResponse {
  """Number of failed notifications"""
  failed: Int!

  """List of user IDs that failed"""
  failedUserIds: [String!]

  """Number of successful notifications"""
  successful: Int!

  """Total number of notifications sent"""
  totalSent: Int!
}

input BulkUpdateSettingsInput {
  settings: [SystemSettingInput!]!
}

input CancelSubscriptionInput {
  immediately: Boolean! = false
}

input ChangePasswordInput {
  """Current password"""
  currentPassword: String!

  """New password"""
  newPassword: String!
}

input ChangeUserRoleInput {
  role: String!
  userId: ID!
}

input CheckQuotaInput {
  amount: Int = 1
  quotaKey: String!
}

type CheckQuotaResponse {
  allowed: Boolean!
  limit: Int!
  message: String
  remaining: Int!
}

type Citation {
  article: String
  excerpt: String
  source: String!
  url: String
}

input ClassifyCaseInput {
  """Detailed description of the legal case to analyze"""
  caseDescription: String!

  """Additional context for the analysis"""
  context: String

  """User session ID for tracking"""
  sessionId: String!

  """Title or brief summary of the analysis"""
  title: String!
}

type CommentPosition {
  endOffset: Float!
  section: String
  startOffset: Float!
  text: String
}

"""Resolution status of a document comment"""
enum CommentResolutionStatus {
  OPEN
  RESOLVED
}

input CommentResolutionStatusFilterComparison {
  eq: CommentResolutionStatus
  gt: CommentResolutionStatus
  gte: CommentResolutionStatus
  iLike: CommentResolutionStatus
  in: [CommentResolutionStatus!]
  is: Boolean
  isNot: Boolean
  like: CommentResolutionStatus
  lt: CommentResolutionStatus
  lte: CommentResolutionStatus
  neq: CommentResolutionStatus
  notILike: CommentResolutionStatus
  notIn: [CommentResolutionStatus!]
  notLike: CommentResolutionStatus
}

input ConditionalSectionInput {
  condition: String!
  description: String
  id: String!
}

"""Cursor for paging through collections"""
scalar ConnectionCursor

"""Type/level of court that issued the ruling"""
enum CourtType {
  ADMINISTRATIVE_COURT
  APPELLATE_COURT
  CONSTITUTIONAL_TRIBUNAL
  DISTRICT_COURT
  OTHER
  REGIONAL_COURT
  SUPREME_COURT
}

input CourtTypeFilterComparison {
  eq: CourtType
  gt: CourtType
  gte: CourtType
  iLike: CourtType
  in: [CourtType!]
  is: Boolean
  isNot: Boolean
  like: CourtType
  lt: CourtType
  lte: CourtType
  neq: CourtType
  notILike: CourtType
  notIn: [CourtType!]
  notLike: CourtType
}

input CreateAiUsageRecordInput {
  metadata: String
  operationType: AiOperationType!
  requestCount: Int = 1
  resourceId: ID
  tokensUsed: Int!
}

input CreateApiKeyInput {
  description: String
  expiresAt: String
  name: String!
  rateLimitPerMinute: Int = 60
  scopes: [ApiKeyScope!]!
}

type CreateApiKeyResponse {
  createdAt: String!
  description: String
  expiresAt: String
  id: ID!
  keyPrefix: String!
  name: String!
  rateLimitPerMinute: Int!
  rawKey: String!
  scopes: [ApiKeyScope!]!
  status: ApiKeyStatus!
  updatedAt: String!
}

input CreateBackupInput {
  """Description of the backup"""
  description: String

  """Optional custom name for the backup"""
  name: String

  """Tags for the backup"""
  tags: [String!]
}

input CreateCitationInput {
  article: String
  excerpt: String
  source: String!
  url: String
}

input CreateCommentPositionInput {
  endOffset: Float!
  section: String
  startOffset: Float!
  text: String
}

input CreateDocumentCommentInput {
  authorId: String!
  documentId: String!
  position: CreateCommentPositionInput!
  resolutionStatus: CommentResolutionStatus = OPEN
  text: String!
}

input CreateDocumentMetadataInput {
  claimAmount: Float
  claimCurrency: String
  defendantName: String
  plaintiffName: String
}

input CreateDocumentTemplateInput {
  category: TemplateCategory!
  conditionalSections: [ConditionalSectionInput!]
  content: String!
  description: String
  isActive: Boolean = true
  name: String!
  polishFormattingRules: PolishFormattingRulesInput
  variables: [TemplateVariableInput!]!
}

input CreateDocumentVersionInput {
  authorUserId: ID
  changeDescription: String
  contentSnapshot: String!
  documentId: ID!
  sessionId: ID!
}

input CreateInAppNotificationInput {
  """Optional action label for the action link button"""
  actionLabel: String

  """Optional action link for navigation (e.g., /documents/123)"""
  actionLink: String

  """The notification message content"""
  message: String!

  """Additional metadata for extensibility (JSON string)"""
  metadata: String

  """Read status - defaults to false (unread)"""
  read: Boolean

  """Type of notification for UI styling"""
  type: String

  """User ID to receive the notification"""
  userId: String!
}

input CreateLegalAnalysisInput {
  identifiedGrounds: [LegalGroundInput!]
  inputDescription: String!
  metadata: AnalysisMetadataInput
  relatedDocumentLinks: [RelatedDocumentLinkInput!]
  sessionId: String!
  title: String!
}

input CreateLegalDocumentInput {
  metadata: CreateDocumentMetadataInput
  sessionId: String!
  title: String!
  type: DocumentType! = OTHER
}

input CreateLegalDocumentInputV2 {
  content: String!
  documentType: DocumentTypeV2!

  """JSON metadata as string"""
  metadataJson: String
  ownerId: ID!
  title: String!
}

input CreateLegalQueryInput {
  answerMarkdown: String
  citations: [CreateCitationInput!]
  question: String!
  sessionId: String!
}

input CreateLegalRulingInput {
  courtName: String!
  courtType: CourtType! = OTHER
  fullText: String
  metadata: CreateRulingMetadataInput
  rulingDate: String!
  signature: String!
  summary: String
}

input CreateNotificationInput {
  """Error message if sending failed"""
  errorMessage: String

  """SendGrid message ID"""
  messageId: String

  """Additional metadata (JSON string)"""
  metadata: String

  """Recipient email address"""
  recipientEmail: String!

  """Timestamp when email was sent"""
  sentAt: String

  """Notification status"""
  status: NotificationStatus = PENDING

  """Email subject line"""
  subject: String!

  """Email template type"""
  template: EmailTemplateType!

  """Template data for rendering (JSON string)"""
  templateData: String

  """User ID (if notification is for a registered user)"""
  userId: String
}

input CreateOneDocumentCommentInput {
  """The record to create"""
  documentComment: CreateDocumentCommentInput!
}

input CreateOneDocumentTemplateInput {
  """The record to create"""
  documentTemplate: CreateDocumentTemplateInput!
}

input CreateOneDocumentVersionInput {
  """The record to create"""
  documentVersion: CreateDocumentVersionInput!
}

input CreateOneInAppNotificationInput {
  """The record to create"""
  inAppNotification: CreateInAppNotificationInput!
}

input CreateOneLegalAnalysisInput {
  """The record to create"""
  legalAnalysis: CreateLegalAnalysisInput!
}

input CreateOneLegalDocumentInput {
  """The record to create"""
  legalDocument: CreateLegalDocumentInput!
}

input CreateOneLegalQueryInput {
  """The record to create"""
  legalQuery: CreateLegalQueryInput!
}

input CreateOneLegalRulingInput {
  """The record to create"""
  legalRuling: CreateLegalRulingInput!
}

input CreateOneNotificationInput {
  """The record to create"""
  notification: CreateNotificationInput!
}

input CreateOneUserInput {
  """The record to create"""
  user: CreateUserInput!
}

input CreateOneUserPreferencesInput {
  """The record to create"""
  userPreferences: CreateUserPreferencesInput!
}

input CreateRulingMetadataInput {
  keywords: [String!]
  legalArea: String
  relatedCases: [String!]
  sourceReference: String
}

input CreateSubscriptionPlanInput {
  billingInterval: BillingInterval = MONTHLY
  description: String
  displayOrder: Int = 0
  features: String!
  maxUsers: Int
  name: String!
  price: Int!
  stripePriceId: String
  stripeYearlyPriceId: String
  tier: PlanTier!
  trialDays: Int = 0
  yearlyDiscount: Int = 0
}

input CreateTemplateInput {
  category: TemplateCategory!
  conditionalSections: JSON
  content: String!
  description: String
  isActive: Boolean = true
  name: String!
  polishFormattingRules: JSON
  variables: JSON!
}

input CreateUserInput {
  email: String!
  firstName: String
  isActive: Boolean
  lastName: String
  username: String
}

input CreateUserPreferencesInput {
  aiModel: AiModelType = GPT_4_TURBO
  dateFormat: String
  emailNotifications: Boolean = true
  inAppNotifications: Boolean = true
  locale: String = "en"
  notificationPreferences: NotificationPreferencesInput
  theme: ThemePreference = SYSTEM
  timezone: String
  userId: String!
}

input CreateUserSubscriptionInput {
  planId: ID!
  stripeCustomerId: String
  stripeSubscriptionId: String
}

input CreateWebhookInput {
  description: String
  events: [WebhookEvent!]!
  headers: String
  maxRetries: Int = 3
  name: String!
  timeoutMs: Int = 30000
  url: String!
}

type CreateWebhookResponse {
  createdAt: String!
  description: String
  events: [WebhookEvent!]!
  failureCount: Int!
  headers: String
  id: ID!
  lastDeliveryAt: String
  lastSuccessAt: String
  maxRetries: Int!
  name: String!
  secret: String!
  status: WebhookStatus!
  successCount: Int!
  timeoutMs: Int!
  updatedAt: String!
  url: String!
}

type CursorEventPayload {
  color: String
  documentId: ID!
  position: Float!
  selectionLength: Float!
  timestamp: DateTime!
  userId: ID!
  userName: String!
}

input CursorPaging {
  """Paginate after opaque cursor"""
  after: ConnectionCursor

  """Paginate before opaque cursor"""
  before: ConnectionCursor

  """Paginate first"""
  first: Int

  """Paginate last"""
  last: Int
}

type DailyUsage {
  date: DateTime!
  totalCost: Float!
  totalRequests: Int!
  totalTokens: Int!
}

type DailyUsageResponse {
  dailyUsage: [DailyUsage!]!
  periodEnd: DateTime!
  periodStart: DateTime!
  totalCost: Float!
  totalRequests: Int!
  totalTokens: Int!
}

input DashboardAnalyticsInput {
  endDate: DateTime
  period: AnalyticsPeriod = DAILY
  startDate: DateTime
}

input DateFieldComparison {
  between: DateFieldComparisonBetween
  eq: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  is: Boolean
  isNot: Boolean
  lt: DateTime
  lte: DateTime
  neq: DateTime
  notBetween: DateFieldComparisonBetween
  notIn: [DateTime!]
}

input DateFieldComparisonBetween {
  lower: DateTime!
  upper: DateTime!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input DeleteDocumentInputV2 {
  deletedBy: ID!
  documentId: ID!
  reason: String
}

input DeleteOneDocumentCommentInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteOneDocumentTemplateInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteOneInAppNotificationInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteOneLegalAnalysisInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteOneLegalDocumentInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteOneLegalQueryInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteOneLegalRulingInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteOneUserInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteOneUserPreferencesInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteOneUserSessionInput {
  """The id of the record to delete."""
  id: ID!
}

"""Webhook delivery status"""
enum DeliveryStatus {
  FAILED
  PENDING
  RETRYING
  SUCCESS
}

type DocumentComment {
  author: User!
  authorId: String!
  createdAt: DateTime!
  document: LegalDocument!
  documentId: String!
  id: ID!
  position: CommentPosition!
  resolutionStatus: CommentResolutionStatus!
  resolvedAt: DateTime
  resolvedBy: ID
  text: String!
  updatedAt: DateTime!
}

input DocumentCommentAggregateFilter {
  and: [DocumentCommentAggregateFilter!]
  authorId: StringFieldComparison
  createdAt: DateFieldComparison
  documentId: StringFieldComparison
  id: IDFilterComparison
  or: [DocumentCommentAggregateFilter!]
  resolutionStatus: CommentResolutionStatusFilterComparison
  resolvedBy: IDFilterComparison
  text: StringFieldComparison
  updatedAt: DateFieldComparison
}

type DocumentCommentAggregateGroupBy {
  authorId: String
  createdAt(by: GroupBy! = DAY): DateTime
  documentId: String
  id: ID
  resolutionStatus: CommentResolutionStatus
  resolvedBy: ID
  text: String
  updatedAt(by: GroupBy! = DAY): DateTime
}

type DocumentCommentAggregateResponse {
  count: DocumentCommentCountAggregate
  groupBy: DocumentCommentAggregateGroupBy
  max: DocumentCommentMaxAggregate
  min: DocumentCommentMinAggregate
}

type DocumentCommentConnection {
  """Array of edges."""
  edges: [DocumentCommentEdge!]!

  """Paging information"""
  pageInfo: PageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type DocumentCommentCountAggregate {
  authorId: Int
  createdAt: Int
  documentId: Int
  id: Int
  resolutionStatus: Int
  resolvedBy: Int
  text: Int
  updatedAt: Int
}

type DocumentCommentDeleteResponse {
  authorId: String
  createdAt: DateTime
  documentId: String
  id: ID
  position: CommentPosition
  resolutionStatus: CommentResolutionStatus
  resolvedAt: DateTime
  resolvedBy: ID
  text: String
  updatedAt: DateTime
}

type DocumentCommentEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the DocumentComment"""
  node: DocumentComment!
}

input DocumentCommentFilter {
  and: [DocumentCommentFilter!]
  authorId: StringFieldComparison
  createdAt: DateFieldComparison
  documentId: StringFieldComparison
  id: IDFilterComparison
  or: [DocumentCommentFilter!]
  resolutionStatus: CommentResolutionStatusFilterComparison
  resolvedBy: IDFilterComparison
  text: StringFieldComparison
  updatedAt: DateFieldComparison
}

type DocumentCommentMaxAggregate {
  authorId: String
  createdAt: DateTime
  documentId: String
  id: ID
  resolutionStatus: CommentResolutionStatus
  resolvedBy: ID
  text: String
  updatedAt: DateTime
}

type DocumentCommentMinAggregate {
  authorId: String
  createdAt: DateTime
  documentId: String
  id: ID
  resolutionStatus: CommentResolutionStatus
  resolvedBy: ID
  text: String
  updatedAt: DateTime
}

input DocumentCommentSort {
  direction: SortDirection!
  field: DocumentCommentSortFields!
  nulls: SortNulls
}

enum DocumentCommentSortFields {
  authorId
  createdAt
  documentId
  id
  resolutionStatus
  resolvedBy
  text
  updatedAt
}

type DocumentEditEventPayload {
  documentId: ID!
  operation: String!
  timestamp: DateTime!
  userId: ID!
  userName: String!
  version: Float!
}

type DocumentMetadata {
  claimAmount: Float
  claimCurrency: String
  defendantName: String
  plaintiffName: String
}

input DocumentMetadataInput {
  claimAmount: Float
  claimCurrency: String
  defendantName: String
  plaintiffName: String
}

type DocumentMetrics {
  completedDocuments: Int!
  draftDocuments: Int!
  failedDocuments: Int!

  """Documents currently generating"""
  generatingDocuments: Int!
  periodEnd: DateTime!
  periodStart: DateTime!

  """Success rate as percentage"""
  successRate: Float!
  totalDocuments: Int!
}

type DocumentShare {
  createdAt: DateTime!
  documentId: String!
  expiresAt: DateTime
  id: ID!
  permission: SharePermission!
  sharedByUserId: String!
  sharedWithUserId: String!
  updatedAt: DateTime!
}

"""Status of document generation"""
enum DocumentStatus {
  COMPLETED
  DRAFT
  FAILED
  GENERATING
}

type DocumentStatusChange {
  """ID of the document"""
  documentId: String!

  """Error message if status is FAILED"""
  error: String

  """Optional message describing the status change"""
  message: String

  """New status after the change"""
  newStatus: DocumentStatus!

  """Previous status before the change"""
  previousStatus: DocumentStatus!

  """ID of the session"""
  sessionId: String!

  """ISO timestamp of the status change"""
  timestamp: String!
}

input DocumentStatusFilterComparison {
  eq: DocumentStatus
  gt: DocumentStatus
  gte: DocumentStatus
  iLike: DocumentStatus
  in: [DocumentStatus!]
  is: Boolean
  isNot: Boolean
  like: DocumentStatus
  lt: DocumentStatus
  lte: DocumentStatus
  neq: DocumentStatus
  notILike: DocumentStatus
  notIn: [DocumentStatus!]
  notLike: DocumentStatus
}

"""Status of the document lifecycle"""
enum DocumentStatusV2 {
  APPROVED
  ARCHIVED
  DELETED
  DRAFT
  PENDING_REVIEW
  PUBLISHED
}

type DocumentTemplate {
  category: TemplateCategory!
  conditionalSections: JSON
  content: String!
  createdAt: DateTime!
  description: String
  id: ID!
  isActive: Boolean!
  name: String!
  polishFormattingRules: JSON
  updatedAt: DateTime!
  usageCount: Float!
  variables: JSON!
}

input DocumentTemplateAggregateFilter {
  and: [DocumentTemplateAggregateFilter!]
  category: TemplateCategoryFilterComparison
  createdAt: DateFieldComparison
  description: StringFieldComparison
  id: IDFilterComparison
  isActive: BooleanFieldComparison
  name: StringFieldComparison
  or: [DocumentTemplateAggregateFilter!]
  updatedAt: DateFieldComparison
}

type DocumentTemplateAggregateGroupBy {
  category: TemplateCategory
  createdAt(by: GroupBy! = DAY): DateTime
  description: String
  id: ID
  isActive: Boolean
  name: String
  updatedAt(by: GroupBy! = DAY): DateTime
}

type DocumentTemplateAggregateResponse {
  count: DocumentTemplateCountAggregate
  groupBy: DocumentTemplateAggregateGroupBy
  max: DocumentTemplateMaxAggregate
  min: DocumentTemplateMinAggregate
}

type DocumentTemplateConnection {
  """Array of edges."""
  edges: [DocumentTemplateEdge!]!

  """Paging information"""
  pageInfo: PageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type DocumentTemplateCountAggregate {
  category: Int
  createdAt: Int
  description: Int
  id: Int
  isActive: Int
  name: Int
  updatedAt: Int
}

type DocumentTemplateDeleteResponse {
  category: TemplateCategory
  conditionalSections: JSON
  content: String
  createdAt: DateTime
  description: String
  id: ID
  isActive: Boolean
  name: String
  polishFormattingRules: JSON
  updatedAt: DateTime
  usageCount: Float
  variables: JSON
}

type DocumentTemplateEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the DocumentTemplate"""
  node: DocumentTemplate!
}

input DocumentTemplateFilter {
  and: [DocumentTemplateFilter!]
  category: TemplateCategoryFilterComparison
  createdAt: DateFieldComparison
  description: StringFieldComparison
  id: IDFilterComparison
  isActive: BooleanFieldComparison
  name: StringFieldComparison
  or: [DocumentTemplateFilter!]
  updatedAt: DateFieldComparison
}

type DocumentTemplateMaxAggregate {
  category: TemplateCategory
  createdAt: DateTime
  description: String
  id: ID
  name: String
  updatedAt: DateTime
}

type DocumentTemplateMinAggregate {
  category: TemplateCategory
  createdAt: DateTime
  description: String
  id: ID
  name: String
  updatedAt: DateTime
}

input DocumentTemplateSort {
  direction: SortDirection!
  field: DocumentTemplateSortFields!
  nulls: SortNulls
}

enum DocumentTemplateSortFields {
  category
  createdAt
  description
  id
  isActive
  name
  updatedAt
}

"""Type of legal document"""
enum DocumentType {
  COMPLAINT
  CONTRACT
  LAWSUIT
  OTHER
}

type DocumentTypeDistribution {
  count: Int!
  documentType: String!

  """Percentage of total"""
  percentage: Float!
}

input DocumentTypeFilterComparison {
  eq: DocumentType
  gt: DocumentType
  gte: DocumentType
  iLike: DocumentType
  in: [DocumentType!]
  is: Boolean
  isNot: Boolean
  like: DocumentType
  lt: DocumentType
  lte: DocumentType
  neq: DocumentType
  notILike: DocumentType
  notIn: [DocumentType!]
  notLike: DocumentType
}

"""Type of legal document"""
enum DocumentTypeV2 {
  AGREEMENT
  CONTRACT
  COURT_RULING
  LEGAL_OPINION
  OTHER
  POLICY
  REGULATION
  STATUTE
}

type DocumentVersion {
  authorUserId: String
  changeDescription: String
  contentSnapshot: String!
  createdAt: DateTime!
  document: LegalDocument!
  documentId: String!
  id: ID!
  session: UserSession!
  sessionId: String!
  versionNumber: Float!
}

input DocumentVersionAggregateFilter {
  and: [DocumentVersionAggregateFilter!]
  authorUserId: StringFieldComparison
  createdAt: DateFieldComparison
  documentId: StringFieldComparison
  id: IDFilterComparison
  or: [DocumentVersionAggregateFilter!]
  sessionId: StringFieldComparison
  versionNumber: NumberFieldComparison
}

type DocumentVersionAggregateGroupBy {
  authorUserId: String
  createdAt(by: GroupBy! = DAY): DateTime
  documentId: String
  id: ID
  sessionId: String
  versionNumber: Float
}

type DocumentVersionAggregateResponse {
  avg: DocumentVersionAvgAggregate
  count: DocumentVersionCountAggregate
  groupBy: DocumentVersionAggregateGroupBy
  max: DocumentVersionMaxAggregate
  min: DocumentVersionMinAggregate
  sum: DocumentVersionSumAggregate
}

type DocumentVersionAvgAggregate {
  versionNumber: Float
}

type DocumentVersionConnection {
  """Array of edges."""
  edges: [DocumentVersionEdge!]!

  """Paging information"""
  pageInfo: PageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type DocumentVersionCountAggregate {
  authorUserId: Int
  createdAt: Int
  documentId: Int
  id: Int
  sessionId: Int
  versionNumber: Int
}

type DocumentVersionEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the DocumentVersion"""
  node: DocumentVersion!
}

input DocumentVersionFilter {
  and: [DocumentVersionFilter!]
  authorUserId: StringFieldComparison
  createdAt: DateFieldComparison
  documentId: StringFieldComparison
  id: IDFilterComparison
  or: [DocumentVersionFilter!]
  sessionId: StringFieldComparison
  versionNumber: NumberFieldComparison
}

type DocumentVersionMaxAggregate {
  authorUserId: String
  createdAt: DateTime
  documentId: String
  id: ID
  sessionId: String
  versionNumber: Float
}

type DocumentVersionMinAggregate {
  authorUserId: String
  createdAt: DateTime
  documentId: String
  id: ID
  sessionId: String
  versionNumber: Float
}

input DocumentVersionSort {
  direction: SortDirection!
  field: DocumentVersionSortFields!
  nulls: SortNulls
}

enum DocumentVersionSortFields {
  authorUserId
  createdAt
  documentId
  id
  sessionId
  versionNumber
}

type DocumentVersionSumAggregate {
  versionNumber: Float
}

"""Email template types available in the system"""
enum EmailTemplateType {
  DOCUMENT_COMPLETED
  DOCUMENT_FAILED
  SYSTEM_NOTIFICATION
  WELCOME
}

input EmailTemplateTypeFilterComparison {
  eq: EmailTemplateType
  gt: EmailTemplateType
  gte: EmailTemplateType
  iLike: EmailTemplateType
  in: [EmailTemplateType!]
  is: Boolean
  isNot: Boolean
  like: EmailTemplateType
  lt: EmailTemplateType
  lte: EmailTemplateType
  neq: EmailTemplateType
  notILike: EmailTemplateType
  notIn: [EmailTemplateType!]
  notLike: EmailTemplateType
}

input ExportDocumentToPdfInput {
  """ID of the document to export"""
  documentId: ID!

  """PDF export options"""
  options: PdfExportOptionsInput
}

input FilterLegalRulingsInput {
  """Filter by court name (partial match)"""
  courtName: String

  """Filter by court type"""
  courtType: CourtType

  """Filter by ruling date from (ISO 8601 date string)"""
  dateFrom: String

  """Filter by ruling date to (ISO 8601 date string)"""
  dateTo: String

  """Filter by legal area from metadata (partial match)"""
  legalArea: String

  """Maximum number of results to return (default: 20, max: 100)"""
  limit: Int = 20

  """Number of results to skip for pagination"""
  offset: Int = 0
}

input FlagDocumentForModerationInput {
  """Document ID to flag for moderation"""
  documentId: ID!

  """Reason for flagging the document"""
  reason: String
}

input GenerateDocumentInput {
  metadata: DocumentMetadataInput
  sessionId: String!
  title: String!
  type: DocumentType! = OTHER
}

input GenerateFromTemplateInput {
  sessionId: String!
  templateId: String!
  title: String!
  variables: JSON!
}

"""Group by"""
enum GroupBy {
  DAY
  MONTH
  WEEK
  YEAR
}

input IDFilterComparison {
  eq: ID
  gt: ID
  gte: ID
  iLike: ID
  in: [ID!]
  is: Boolean
  isNot: Boolean
  like: ID
  lt: ID
  lte: ID
  neq: ID
  notILike: ID
  notIn: [ID!]
  notLike: ID
}

type InAppNotification {
  actionLabel: String
  actionLink: String
  createdAt: DateTime!
  id: ID!
  message: String!
  metadata: JSON
  read: Boolean!
  type: InAppNotificationType!
  user: User!
  userId: String!
}

input InAppNotificationAggregateFilter {
  and: [InAppNotificationAggregateFilter!]
  createdAt: DateFieldComparison
  id: IDFilterComparison
  message: StringFieldComparison
  or: [InAppNotificationAggregateFilter!]
  read: BooleanFieldComparison
  type: InAppNotificationTypeFilterComparison
  userId: StringFieldComparison
}

type InAppNotificationAggregateGroupBy {
  createdAt(by: GroupBy! = DAY): DateTime
  id: ID
  message: String
  read: Boolean
  type: InAppNotificationType
  userId: String
}

type InAppNotificationAggregateResponse {
  count: InAppNotificationCountAggregate
  groupBy: InAppNotificationAggregateGroupBy
  max: InAppNotificationMaxAggregate
  min: InAppNotificationMinAggregate
}

type InAppNotificationConnection {
  """Array of edges."""
  edges: [InAppNotificationEdge!]!

  """Paging information"""
  pageInfo: PageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type InAppNotificationCountAggregate {
  createdAt: Int
  id: Int
  message: Int
  read: Int
  type: Int
  userId: Int
}

type InAppNotificationCreatedPayload {
  """Optional action label for the action link"""
  actionLabel: String

  """Optional action link for navigation"""
  actionLink: String

  """Creation timestamp"""
  createdAt: DateTime!

  """Notification message"""
  message: String!

  """Additional metadata"""
  metadata: String

  """Notification ID"""
  notificationId: ID!

  """Type of notification"""
  type: InAppNotificationType!

  """User ID who received the notification"""
  userId: ID!
}

type InAppNotificationDeleteResponse {
  actionLabel: String
  actionLink: String
  createdAt: DateTime
  id: ID
  message: String
  metadata: JSON
  read: Boolean
  type: InAppNotificationType
  userId: String
}

type InAppNotificationEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the InAppNotification"""
  node: InAppNotification!
}

input InAppNotificationFilter {
  and: [InAppNotificationFilter!]
  createdAt: DateFieldComparison
  id: IDFilterComparison
  message: StringFieldComparison
  or: [InAppNotificationFilter!]
  read: BooleanFieldComparison
  type: InAppNotificationTypeFilterComparison
  userId: StringFieldComparison
}

type InAppNotificationMaxAggregate {
  createdAt: DateTime
  id: ID
  message: String
  type: InAppNotificationType
  userId: String
}

type InAppNotificationMinAggregate {
  createdAt: DateTime
  id: ID
  message: String
  type: InAppNotificationType
  userId: String
}

input InAppNotificationSort {
  direction: SortDirection!
  field: InAppNotificationSortFields!
  nulls: SortNulls
}

enum InAppNotificationSortFields {
  createdAt
  id
  message
  read
  type
  userId
}

"""Types of in-app notifications"""
enum InAppNotificationType {
  ERROR
  INFO
  SUCCESS
  SYSTEM
  WARNING
}

input InAppNotificationTypeFilterComparison {
  eq: InAppNotificationType
  gt: InAppNotificationType
  gte: InAppNotificationType
  iLike: InAppNotificationType
  in: [InAppNotificationType!]
  is: Boolean
  isNot: Boolean
  like: InAppNotificationType
  lt: InAppNotificationType
  lte: InAppNotificationType
  neq: InAppNotificationType
  notILike: InAppNotificationType
  notIn: [InAppNotificationType!]
  notLike: InAppNotificationType
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

type LegalAnalysis {
  createdAt: DateTime!
  errorMessage: String
  id: ID!
  identifiedGrounds: [LegalGround!]
  inputDescription: String!
  metadata: AnalysisMetadata
  overallConfidenceScore: Float
  recommendations: String
  relatedDocumentLinks: [RelatedDocumentLink!]
  session: UserSession!
  sessionId: String!
  status: AnalysisStatus!
  summary: String
  title: String!
  updatedAt: DateTime!
}

input LegalAnalysisAggregateFilter {
  and: [LegalAnalysisAggregateFilter!]
  createdAt: DateFieldComparison
  id: IDFilterComparison
  or: [LegalAnalysisAggregateFilter!]
  sessionId: StringFieldComparison
  status: AnalysisStatusFilterComparison
  title: StringFieldComparison
  updatedAt: DateFieldComparison
}

type LegalAnalysisAggregateGroupBy {
  createdAt(by: GroupBy! = DAY): DateTime
  id: ID
  sessionId: String
  status: AnalysisStatus
  title: String
  updatedAt(by: GroupBy! = DAY): DateTime
}

type LegalAnalysisAggregateResponse {
  count: LegalAnalysisCountAggregate
  groupBy: LegalAnalysisAggregateGroupBy
  max: LegalAnalysisMaxAggregate
  min: LegalAnalysisMinAggregate
}

type LegalAnalysisConnection {
  """Array of edges."""
  edges: [LegalAnalysisEdge!]!

  """Paging information"""
  pageInfo: PageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type LegalAnalysisCountAggregate {
  createdAt: Int
  id: Int
  sessionId: Int
  status: Int
  title: Int
  updatedAt: Int
}

type LegalAnalysisDeleteResponse {
  createdAt: DateTime
  errorMessage: String
  id: ID
  identifiedGrounds: [LegalGround!]
  inputDescription: String
  metadata: AnalysisMetadata
  overallConfidenceScore: Float
  recommendations: String
  relatedDocumentLinks: [RelatedDocumentLink!]
  sessionId: String
  status: AnalysisStatus
  summary: String
  title: String
  updatedAt: DateTime
}

type LegalAnalysisEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the LegalAnalysis"""
  node: LegalAnalysis!
}

input LegalAnalysisFilter {
  and: [LegalAnalysisFilter!]
  createdAt: DateFieldComparison
  id: IDFilterComparison
  or: [LegalAnalysisFilter!]
  sessionId: StringFieldComparison
  status: AnalysisStatusFilterComparison
  title: StringFieldComparison
  updatedAt: DateFieldComparison
}

type LegalAnalysisMaxAggregate {
  createdAt: DateTime
  id: ID
  sessionId: String
  status: AnalysisStatus
  title: String
  updatedAt: DateTime
}

type LegalAnalysisMinAggregate {
  createdAt: DateTime
  id: ID
  sessionId: String
  status: AnalysisStatus
  title: String
  updatedAt: DateTime
}

input LegalAnalysisSort {
  direction: SortDirection!
  field: LegalAnalysisSortFields!
  nulls: SortNulls
}

enum LegalAnalysisSortFields {
  createdAt
  id
  sessionId
  status
  title
  updatedAt
}

type LegalDocument {
  contentRaw: String
  createdAt: DateTime!

  """When the document was flagged for moderation"""
  flaggedAt: DateTime
  id: ID!
  metadata: DocumentMetadata

  """When the document was moderated"""
  moderatedAt: DateTime

  """ID of the admin who moderated this document"""
  moderatedById: ID

  """Reason for moderation decision"""
  moderationReason: String

  """Moderation status of the document"""
  moderationStatus: ModerationStatus
  pdfUrl: String
  session: UserSession!
  sessionId: String!
  status: DocumentStatus!
  title: String!
  type: DocumentType!
  updatedAt: DateTime!
}

input LegalDocumentAggregateFilter {
  and: [LegalDocumentAggregateFilter!]
  createdAt: DateFieldComparison
  id: IDFilterComparison
  moderationStatus: ModerationStatusFilterComparison
  or: [LegalDocumentAggregateFilter!]
  sessionId: StringFieldComparison
  status: DocumentStatusFilterComparison
  title: StringFieldComparison
  type: DocumentTypeFilterComparison
  updatedAt: DateFieldComparison
}

type LegalDocumentAggregateGroupBy {
  createdAt(by: GroupBy! = DAY): DateTime
  id: ID
  moderationStatus: ModerationStatus
  sessionId: String
  status: DocumentStatus
  title: String
  type: DocumentType
  updatedAt(by: GroupBy! = DAY): DateTime
}

type LegalDocumentAggregateResponse {
  count: LegalDocumentCountAggregate
  groupBy: LegalDocumentAggregateGroupBy
  max: LegalDocumentMaxAggregate
  min: LegalDocumentMinAggregate
}

type LegalDocumentConnection {
  """Array of edges."""
  edges: [LegalDocumentEdge!]!

  """Paging information"""
  pageInfo: PageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type LegalDocumentCountAggregate {
  createdAt: Int
  id: Int
  moderationStatus: Int
  sessionId: Int
  status: Int
  title: Int
  type: Int
  updatedAt: Int
}

type LegalDocumentDeleteResponse {
  contentRaw: String
  createdAt: DateTime

  """When the document was flagged for moderation"""
  flaggedAt: DateTime
  id: ID
  metadata: DocumentMetadata

  """When the document was moderated"""
  moderatedAt: DateTime

  """ID of the admin who moderated this document"""
  moderatedById: ID

  """Reason for moderation decision"""
  moderationReason: String

  """Moderation status of the document"""
  moderationStatus: ModerationStatus

  """Signed URL to download the PDF version of this document"""
  pdfUrl: String
  sessionId: String
  status: DocumentStatus
  title: String
  type: DocumentType
  updatedAt: DateTime
}

type LegalDocumentEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the LegalDocument"""
  node: LegalDocument!
}

input LegalDocumentFilter {
  and: [LegalDocumentFilter!]
  createdAt: DateFieldComparison
  id: IDFilterComparison
  moderationStatus: ModerationStatusFilterComparison
  or: [LegalDocumentFilter!]
  sessionId: StringFieldComparison
  status: DocumentStatusFilterComparison
  title: StringFieldComparison
  type: DocumentTypeFilterComparison
  updatedAt: DateFieldComparison
}

type LegalDocumentMaxAggregate {
  createdAt: DateTime
  id: ID
  moderationStatus: ModerationStatus
  sessionId: String
  status: DocumentStatus
  title: String
  type: DocumentType
  updatedAt: DateTime
}

type LegalDocumentMinAggregate {
  createdAt: DateTime
  id: ID
  moderationStatus: ModerationStatus
  sessionId: String
  status: DocumentStatus
  title: String
  type: DocumentType
  updatedAt: DateTime
}

type LegalDocumentSearchResponse {
  count: Int!
  hasMore: Boolean!
  offset: Int!
  results: [LegalDocumentSearchResult!]!
  totalCount: Int!
}

type LegalDocumentSearchResult {
  contentRaw: String
  createdAt: DateTime!

  """Highlighted snippet of matching content"""
  headline: String
  id: String!
  pdfUrl: String

  """Relevance ranking score (higher is more relevant)"""
  rank: Float!
  sessionId: String!
  status: DocumentStatus!
  title: String!
  type: DocumentType!
  updatedAt: DateTime!
}

input LegalDocumentSort {
  direction: SortDirection!
  field: LegalDocumentSortFields!
  nulls: SortNulls
}

enum LegalDocumentSortFields {
  createdAt
  id
  moderationStatus
  sessionId
  status
  title
  type
  updatedAt
}

type LegalDocumentV2 {
  content: String!
  createdAt: DateTime!
  documentType: DocumentTypeV2!
  id: ID!

  """JSON metadata as string"""
  metadataJson: String
  ownerId: ID!
  status: DocumentStatusV2!
  title: String!
  updatedAt: DateTime!
  version: Float!
}

type LegalGround {
  confidenceScore: Float!
  description: String!
  legalBasis: [String!]
  name: String!
  notes: String
}

input LegalGroundInput {
  confidenceScore: Float!
  description: String!
  legalBasis: [String!]
  name: String!
  notes: String
}

type LegalQuery {
  answerMarkdown: String
  citations: [Citation!]
  createdAt: DateTime!
  id: ID!
  question: String!
  session: UserSession!
  sessionId: String!
  updatedAt: DateTime!
}

input LegalQueryAggregateFilter {
  and: [LegalQueryAggregateFilter!]
  createdAt: DateFieldComparison
  id: IDFilterComparison
  or: [LegalQueryAggregateFilter!]
  question: StringFieldComparison
  sessionId: StringFieldComparison
  updatedAt: DateFieldComparison
}

type LegalQueryAggregateGroupBy {
  createdAt(by: GroupBy! = DAY): DateTime
  id: ID
  question: String
  sessionId: String
  updatedAt(by: GroupBy! = DAY): DateTime
}

type LegalQueryAggregateResponse {
  count: LegalQueryCountAggregate
  groupBy: LegalQueryAggregateGroupBy
  max: LegalQueryMaxAggregate
  min: LegalQueryMinAggregate
}

type LegalQueryConnection {
  """Array of edges."""
  edges: [LegalQueryEdge!]!

  """Paging information"""
  pageInfo: PageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type LegalQueryCountAggregate {
  createdAt: Int
  id: Int
  question: Int
  sessionId: Int
  updatedAt: Int
}

type LegalQueryDeleteResponse {
  answerMarkdown: String
  citations: [Citation!]
  createdAt: DateTime
  id: ID
  question: String
  sessionId: String
  updatedAt: DateTime
}

type LegalQueryEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the LegalQuery"""
  node: LegalQuery!
}

input LegalQueryFilter {
  and: [LegalQueryFilter!]
  createdAt: DateFieldComparison
  id: IDFilterComparison
  or: [LegalQueryFilter!]
  question: StringFieldComparison
  sessionId: StringFieldComparison
  updatedAt: DateFieldComparison
}

type LegalQueryMaxAggregate {
  createdAt: DateTime
  id: ID
  question: String
  sessionId: String
  updatedAt: DateTime
}

type LegalQueryMinAggregate {
  createdAt: DateTime
  id: ID
  question: String
  sessionId: String
  updatedAt: DateTime
}

type LegalQuerySearchResponse {
  count: Int!
  hasMore: Boolean!
  offset: Int!
  results: [LegalQuerySearchResult!]!
  totalCount: Int!
}

type LegalQuerySearchResult {
  answerMarkdown: String
  createdAt: DateTime!

  """Highlighted snippet of matching content"""
  headline: String
  id: String!
  question: String!

  """Relevance ranking score (higher is more relevant)"""
  rank: Float!
  sessionId: String!
  updatedAt: DateTime!
}

input LegalQuerySort {
  direction: SortDirection!
  field: LegalQuerySortFields!
  nulls: SortNulls
}

enum LegalQuerySortFields {
  createdAt
  id
  question
  sessionId
  updatedAt
}

type LegalRuling {
  courtName: String!
  courtType: CourtType!
  createdAt: DateTime!
  fullText: String
  id: ID!
  metadata: RulingMetadata
  rulingDate: DateTime!
  signature: String!
  summary: String
  updatedAt: DateTime!
}

input LegalRulingAggregateFilter {
  and: [LegalRulingAggregateFilter!]
  courtName: StringFieldComparison
  courtType: CourtTypeFilterComparison
  createdAt: DateFieldComparison
  id: IDFilterComparison
  or: [LegalRulingAggregateFilter!]
  rulingDate: DateFieldComparison
  signature: StringFieldComparison
  updatedAt: DateFieldComparison
}

type LegalRulingAggregateGroupBy {
  courtName: String
  courtType: CourtType
  createdAt(by: GroupBy! = DAY): DateTime
  id: ID
  rulingDate(by: GroupBy! = DAY): DateTime
  signature: String
  updatedAt(by: GroupBy! = DAY): DateTime
}

type LegalRulingAggregateResponse {
  count: LegalRulingCountAggregate
  groupBy: LegalRulingAggregateGroupBy
  max: LegalRulingMaxAggregate
  min: LegalRulingMinAggregate
}

type LegalRulingConnection {
  """Array of edges."""
  edges: [LegalRulingEdge!]!

  """Paging information"""
  pageInfo: PageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type LegalRulingCountAggregate {
  courtName: Int
  courtType: Int
  createdAt: Int
  id: Int
  rulingDate: Int
  signature: Int
  updatedAt: Int
}

type LegalRulingDeleteResponse {
  courtName: String
  courtType: CourtType
  createdAt: DateTime
  fullText: String
  id: ID
  metadata: RulingMetadata
  rulingDate: DateTime
  signature: String
  summary: String
  updatedAt: DateTime
}

type LegalRulingEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the LegalRuling"""
  node: LegalRuling!
}

input LegalRulingFilter {
  and: [LegalRulingFilter!]
  courtName: StringFieldComparison
  courtType: CourtTypeFilterComparison
  createdAt: DateFieldComparison
  id: IDFilterComparison
  or: [LegalRulingFilter!]
  rulingDate: DateFieldComparison
  signature: StringFieldComparison
  updatedAt: DateFieldComparison
}

type LegalRulingMaxAggregate {
  courtName: String
  courtType: CourtType
  createdAt: DateTime
  id: ID
  rulingDate: DateTime
  signature: String
  updatedAt: DateTime
}

type LegalRulingMinAggregate {
  courtName: String
  courtType: CourtType
  createdAt: DateTime
  id: ID
  rulingDate: DateTime
  signature: String
  updatedAt: DateTime
}

type LegalRulingSearchResponse {
  """Number of results returned"""
  count: Int!

  """Whether there are more results"""
  hasMore: Boolean!

  """Current offset"""
  offset: Int!

  """Search results with relevance ranking"""
  results: [LegalRulingSearchResult!]!

  """Total number of matching results (for pagination)"""
  totalCount: Int!
}

type LegalRulingSearchResult {
  """Highlighted snippet of matching content"""
  headline: String

  """Relevance score (higher is better)"""
  rank: Float!

  """The matching legal ruling"""
  ruling: LegalRuling!
}

input LegalRulingSort {
  direction: SortDirection!
  field: LegalRulingSortFields!
  nulls: SortNulls
}

enum LegalRulingSortFields {
  courtName
  courtType
  createdAt
  id
  rulingDate
  signature
  updatedAt
}

input LoginInput {
  """User password"""
  password: String!

  """Username or email address"""
  username: String!
}

type ModerationActionResult {
  """Action performed"""
  action: String!

  """Document ID"""
  documentId: ID!

  """Reason for the action"""
  reason: String

  """Whether user was notified"""
  userNotified: Boolean!
}

"""Moderation status of document"""
enum ModerationStatus {
  APPROVED
  PENDING
  REJECTED
}

input ModerationStatusFilterComparison {
  eq: ModerationStatus
  gt: ModerationStatus
  gte: ModerationStatus
  iLike: ModerationStatus
  in: [ModerationStatus!]
  is: Boolean
  isNot: Boolean
  like: ModerationStatus
  lt: ModerationStatus
  lte: ModerationStatus
  neq: ModerationStatus
  notILike: ModerationStatus
  notIn: [ModerationStatus!]
  notLike: ModerationStatus
}

type Mutation {
  """Accept the legal disclaimer for the current user"""
  acceptDisclaimer: AuthUser!

  """Activate a user account (admin only)"""
  activateUser(input: ActivateUserInput!): User!

  """Activate a webhook"""
  activateWebhook(id: String!): Webhook!

  """Add a citation to an existing legal query"""
  addCitationToQuery(citation: CreateCitationInput!, queryId: ID!): LegalQuery!

  """Add AI-generated answer to a legal query"""
  answerLegalQuery(id: ID!, input: AnswerLegalQueryInput!): LegalQuery!

  """Approve a document after moderation review"""
  approveDocument(input: ApproveDocumentInput!): ModerationActionResult!

  """Ask a legal question and get AI answer synchronously"""
  askLegalQuestion(input: AskLegalQuestionInput!): LegalQuery!
  bulkUpsertSystemSettings(input: BulkUpdateSettingsInput!): [SystemSetting!]!

  """Cancel the current user subscription"""
  cancelMySubscription(input: CancelSubscriptionInput!): UserSubscription!

  """Change password for the current user"""
  changePassword(input: ChangePasswordInput!): Boolean!

  """Upgrade or downgrade the current user subscription"""
  changeSubscriptionPlan(newPlanId: String!): UserSubscription!

  """Change a user role (admin only)"""
  changeUserRole(input: ChangeUserRoleInput!): User!

  """
  Analyze a case description using AI and identify applicable legal grounds
  """
  classifyCase(input: ClassifyCaseInput!): LegalAnalysis!

  """Create a new API key. The raw key is only shown once."""
  createApiKey(input: CreateApiKeyInput!): CreateApiKeyResponse!
  createBackup(input: CreateBackupInput): Backup!
  createDocumentTemplate(input: CreateTemplateInput!): DocumentTemplate!
  createDocumentV2(input: CreateLegalDocumentInputV2!): LegalDocumentV2!

  """Create a new subscription for the current user"""
  createMySubscription(input: CreateUserSubscriptionInput!): UserSubscription!
  createOneDocumentComment(input: CreateOneDocumentCommentInput!): DocumentComment!
  createOneDocumentTemplate(input: CreateOneDocumentTemplateInput!): DocumentTemplate!
  createOneDocumentVersion(input: CreateOneDocumentVersionInput!): DocumentVersion!
  createOneInAppNotification(input: CreateOneInAppNotificationInput!): InAppNotification!
  createOneLegalAnalysis(input: CreateOneLegalAnalysisInput!): LegalAnalysis!
  createOneLegalDocument(input: CreateOneLegalDocumentInput!): LegalDocument!
  createOneLegalQuery(input: CreateOneLegalQueryInput!): LegalQuery!
  createOneLegalRuling(input: CreateOneLegalRulingInput!): LegalRuling!
  createOneNotification(input: CreateOneNotificationInput!): Notification!
  createOneUser(input: CreateOneUserInput!): User!
  createOneUserPreference(input: CreateOneUserPreferencesInput!): UserPreferences!

  """Create a new subscription plan"""
  createSubscriptionPlan(input: CreateSubscriptionPlanInput!): SubscriptionPlan!
  createUsageRecord(input: CreateAiUsageRecordInput!): AiUsageRecord!

  """Create a new webhook. The secret is only shown once."""
  createWebhook(input: CreateWebhookInput!): CreateWebhookResponse!

  """Deactivate a webhook (temporary pause)"""
  deactivateWebhook(id: String!): Webhook!

  """Delete an API key permanently. This action cannot be undone."""
  deleteApiKey(id: String!): Boolean!
  deleteBackup(id: ID!): Boolean!
  deleteDocument(id: ID!): Boolean! @deprecated(reason: "Use deleteOneLegalDocument instead")
  deleteDocumentTemplate(id: ID!): Boolean!
  deleteDocumentV2(input: DeleteDocumentInputV2!): Boolean!

  """Delete a legal query (deprecated)"""
  deleteLegalQuery(id: ID!): Boolean! @deprecated(reason: "Use deleteOneLegalQuery instead")
  deleteOneDocumentComment(input: DeleteOneDocumentCommentInput!): DocumentCommentDeleteResponse!
  deleteOneDocumentTemplate(input: DeleteOneDocumentTemplateInput!): DocumentTemplateDeleteResponse!
  deleteOneInAppNotification(input: DeleteOneInAppNotificationInput!): InAppNotificationDeleteResponse!
  deleteOneLegalAnalysis(input: DeleteOneLegalAnalysisInput!): LegalAnalysisDeleteResponse!
  deleteOneLegalDocument(input: DeleteOneLegalDocumentInput!): LegalDocumentDeleteResponse!
  deleteOneLegalQuery(input: DeleteOneLegalQueryInput!): LegalQueryDeleteResponse!
  deleteOneLegalRuling(input: DeleteOneLegalRulingInput!): LegalRulingDeleteResponse!
  deleteOneUser(input: DeleteOneUserInput!): UserDeleteResponse!
  deleteOneUserPreference(input: DeleteOneUserPreferencesInput!): UserPreferencesDeleteResponse!
  deleteOneUserSession(input: DeleteOneUserSessionInput!): UserSessionDeleteResponse!

  """Delete a subscription plan"""
  deleteSubscriptionPlan(id: String!): Boolean!
  deleteSystemSetting(key: String!): Boolean!

  """Delete a webhook permanently. This action cannot be undone."""
  deleteWebhook(id: String!): Boolean!

  """Disable a webhook"""
  disableWebhook(id: String!): Webhook!

  """Queue a document for PDF export"""
  exportDocumentToPdf(input: ExportDocumentToPdfInput!): PdfExportJob!

  """Export a document to PDF and wait for the result"""
  exportDocumentToPdfSync(input: ExportDocumentToPdfInput!): PdfExportResult!

  """Flag a document for moderation review"""
  flagDocumentForModeration(input: FlagDocumentForModerationInput!): ModerationActionResult!
  generateDocument(input: GenerateDocumentInput!): LegalDocument!
  generateDocumentFromTemplate(input: GenerateFromTemplateInput!): LegalDocument!

  """Authenticate user with username/email and password"""
  login(input: LoginInput!): AuthPayload!

  """Mark all notifications as read for a user"""
  markAllNotificationsAsRead(userId: String!): Int!

  """Mark a notification as read"""
  markNotificationAsRead(notificationId: String!, userId: String!): String!
  publishDocumentV2(input: PublishDocumentInputV2!): LegalDocumentV2!

  """Record usage for quota tracking"""
  recordUsage(amount: Float, quotaKey: String!): Boolean!

  """Refresh access token using a valid refresh token"""
  refreshToken(input: RefreshTokenInput!): RefreshTokenPayload!

  """Register a new user account"""
  register(input: RegisterInput!): AuthPayload!

  """Reject a document after moderation review"""
  rejectDocument(input: RejectDocumentInput!): ModerationActionResult!

  """
  Render a template with variable substitution without creating a document
  """
  renderTemplate(input: RenderTemplateInput!): String!
  resetMyPreferences: UserPreferences!

  """Reset a user password (admin only)"""
  resetUserPassword(input: ResetUserPasswordInput!): User!
  restoreBackup(input: RestoreBackupInput!): Boolean!

  """Resume a subscription that was scheduled for cancellation"""
  resumeMySubscription: UserSubscription!

  """Revoke an API key. This action cannot be undone."""
  revokeApiKey(id: String!): ApiKey!

  """Revoke a document share"""
  revokeDocumentShare(shareId: ID!): Boolean!

  """
  Rollback a document to a previous version. Creates a new version with the old content.
  """
  rollbackDocumentToVersion(authorUserId: ID, documentId: ID!, sessionId: ID!, versionNumber: Float!): LegalDocument!

  """Rotate webhook secret. The old secret will no longer work."""
  rotateWebhookSecret(id: String!): String!
  seedSystemSettings: Boolean!

  """Send bulk notifications to multiple users"""
  sendBulkNotifications(input: BulkSendNotificationInput!): BulkSendNotificationResponse!

  """Send a notification to a user across specified channels"""
  sendNotification(input: SendNotificationInput!): SendNotificationResponse!

  """Share a document with a user"""
  shareDocument(input: ShareDocumentInput!): DocumentShare!

  """Submit a new legal query for AI processing"""
  submitLegalQuery(input: SubmitLegalQueryInput!): LegalQuery!

  """Suspend a user account (admin only)"""
  suspendUser(input: SuspendUserInput!): User!

  """Test a webhook by sending a test event"""
  testWebhook(input: TestWebhookInput!): TestWebhookResponse!

  """Update an existing API key (name, scopes, rate limit, expiration)"""
  updateApiKey(id: String!, input: UpdateApiKeyInput!): ApiKey!
  updateDocument(id: ID!, input: UpdateDocumentInput!): LegalDocument!

  """Update the permission level of a document share"""
  updateDocumentSharePermission(input: UpdateSharePermissionInput!): DocumentShare!
  updateDocumentTemplate(id: ID!, input: UpdateTemplateInput!): DocumentTemplate!
  updateDocumentTitleV2(input: UpdateDocumentTitleInputV2!): LegalDocumentV2!
  updateMyPreferences(input: UpdateUserPreferencesInput!): UserPreferences!

  """Update notification preferences for a user"""
  updateNotificationPreferences(input: NotificationDeliveryPreferencesInput!): String!
  updateOneDocumentComment(input: UpdateOneDocumentCommentInput!): DocumentComment!
  updateOneDocumentTemplate(input: UpdateOneDocumentTemplateInput!): DocumentTemplate!
  updateOneDocumentVersion(input: UpdateOneDocumentVersionInput!): DocumentVersion!
  updateOneInAppNotification(input: UpdateOneInAppNotificationInput!): InAppNotification!
  updateOneLegalAnalysis(input: UpdateOneLegalAnalysisInput!): LegalAnalysis!
  updateOneLegalDocument(input: UpdateOneLegalDocumentInput!): LegalDocument!
  updateOneLegalQuery(input: UpdateOneLegalQueryInput!): LegalQuery!
  updateOneLegalRuling(input: UpdateOneLegalRulingInput!): LegalRuling!
  updateOneNotification(input: UpdateOneNotificationInput!): Notification!
  updateOneUser(input: UpdateOneUserInput!): User!
  updateOneUserPreference(input: UpdateOneUserPreferencesInput!): UserPreferences!

  """Update profile information for the current user"""
  updateProfile(input: UpdateProfileInput!): AuthUser!

  """Update an existing subscription plan"""
  updateSubscriptionPlan(id: String!, input: UpdateSubscriptionPlanInput!): SubscriptionPlan!

  """Update an existing webhook (name, URL, events, headers, status)"""
  updateWebhook(id: String!, input: UpdateWebhookInput!): Webhook!
  upsertSystemSetting(input: SystemSettingInput!): SystemSetting!
}

type Notification {
  createdAt: DateTime!
  errorMessage: String
  id: ID!
  messageId: String
  metadata: String
  recipientEmail: String!
  sentAt: DateTime
  status: NotificationStatus!
  subject: String!
  template: EmailTemplateType!
  templateData: String
  updatedAt: DateTime!
  userId: String
}

input NotificationAggregateFilter {
  and: [NotificationAggregateFilter!]
  createdAt: DateFieldComparison
  errorMessage: StringFieldComparison
  id: IDFilterComparison
  messageId: StringFieldComparison
  or: [NotificationAggregateFilter!]
  recipientEmail: StringFieldComparison
  sentAt: DateFieldComparison
  status: NotificationStatusFilterComparison
  subject: StringFieldComparison
  template: EmailTemplateTypeFilterComparison
  updatedAt: DateFieldComparison
  userId: StringFieldComparison
}

type NotificationAggregateGroupBy {
  createdAt(by: GroupBy! = DAY): DateTime
  errorMessage: String
  id: ID
  messageId: String
  recipientEmail: String
  sentAt(by: GroupBy! = DAY): DateTime
  status: NotificationStatus
  subject: String
  template: EmailTemplateType
  updatedAt(by: GroupBy! = DAY): DateTime
  userId: String
}

type NotificationAggregateResponse {
  count: NotificationCountAggregate
  groupBy: NotificationAggregateGroupBy
  max: NotificationMaxAggregate
  min: NotificationMinAggregate
}

"""Notification channel types"""
enum NotificationChannel {
  BOTH
  EMAIL
  IN_APP
}

type NotificationChannels {
  email: Boolean!
  inApp: Boolean!
  push: Boolean!
}

input NotificationChannelsInput {
  email: Boolean
  inApp: Boolean
  push: Boolean
}

type NotificationConnection {
  """Array of edges."""
  edges: [NotificationEdge!]!

  """Paging information"""
  pageInfo: PageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type NotificationCountAggregate {
  createdAt: Int
  errorMessage: Int
  id: Int
  messageId: Int
  recipientEmail: Int
  sentAt: Int
  status: Int
  subject: Int
  template: Int
  updatedAt: Int
  userId: Int
}

type NotificationDeliveryPreferences {
  """Enable email notifications"""
  emailEnabled: Boolean!

  """Notification types to exclude from email"""
  excludeEmailTypes: [NotificationTemplateType!]

  """Notification types to exclude from in-app"""
  excludeInAppTypes: [NotificationTemplateType!]

  """Enable in-app notifications"""
  inAppEnabled: Boolean!

  """User ID"""
  userId: String!
}

input NotificationDeliveryPreferencesInput {
  """Enable email notifications"""
  emailEnabled: Boolean = true

  """Notification types to exclude from email"""
  excludeEmailTypes: [NotificationTemplateType!]

  """Notification types to exclude from in-app"""
  excludeInAppTypes: [NotificationTemplateType!]

  """Enable in-app notifications"""
  inAppEnabled: Boolean = true

  """User ID"""
  userId: String!
}

type NotificationEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the Notification"""
  node: Notification!
}

input NotificationFilter {
  and: [NotificationFilter!]
  createdAt: DateFieldComparison
  errorMessage: StringFieldComparison
  id: IDFilterComparison
  messageId: StringFieldComparison
  or: [NotificationFilter!]
  recipientEmail: StringFieldComparison
  sentAt: DateFieldComparison
  status: NotificationStatusFilterComparison
  subject: StringFieldComparison
  template: EmailTemplateTypeFilterComparison
  updatedAt: DateFieldComparison
  userId: StringFieldComparison
}

type NotificationMaxAggregate {
  createdAt: DateTime
  errorMessage: String
  id: ID
  messageId: String
  recipientEmail: String
  sentAt: DateTime
  status: NotificationStatus
  subject: String
  template: EmailTemplateType
  updatedAt: DateTime
  userId: String
}

type NotificationMinAggregate {
  createdAt: DateTime
  errorMessage: String
  id: ID
  messageId: String
  recipientEmail: String
  sentAt: DateTime
  status: NotificationStatus
  subject: String
  template: EmailTemplateType
  updatedAt: DateTime
  userId: String
}

type NotificationPreferences {
  channels: NotificationChannels!
  documentUpdates: Boolean!
  marketingEmails: Boolean!
  queryResponses: Boolean!
  systemAlerts: Boolean!
}

input NotificationPreferencesInput {
  channels: NotificationChannelsInput
  documentUpdates: Boolean
  marketingEmails: Boolean
  queryResponses: Boolean
  systemAlerts: Boolean
}

"""Priority levels for notifications"""
enum NotificationPriority {
  HIGH
  LOW
  NORMAL
  URGENT
}

input NotificationSort {
  direction: SortDirection!
  field: NotificationSortFields!
  nulls: SortNulls
}

enum NotificationSortFields {
  createdAt
  errorMessage
  id
  messageId
  recipientEmail
  sentAt
  status
  subject
  template
  updatedAt
  userId
}

"""Status of email notifications"""
enum NotificationStatus {
  BOUNCED
  FAILED
  PENDING
  QUEUED
  SENT
}

input NotificationStatusFilterComparison {
  eq: NotificationStatus
  gt: NotificationStatus
  gte: NotificationStatus
  iLike: NotificationStatus
  in: [NotificationStatus!]
  is: Boolean
  isNot: Boolean
  like: NotificationStatus
  lt: NotificationStatus
  lte: NotificationStatus
  neq: NotificationStatus
  notILike: NotificationStatus
  notIn: [NotificationStatus!]
  notLike: NotificationStatus
}

"""Notification template types"""
enum NotificationTemplateType {
  DOCUMENT_COMPLETED
  DOCUMENT_FAILED
  DOCUMENT_SHARED
  EMAIL_VERIFICATION
  PASSWORD_CHANGED
  PASSWORD_RESET
  QUERY_COMPLETED
  QUERY_FAILED
  RULING_INDEXED
  RULING_SEARCH_READY
  SECURITY_ALERT
  SYSTEM_MAINTENANCE
  SYSTEM_UPDATE
  WELCOME
}

input NumberFieldComparison {
  between: NumberFieldComparisonBetween
  eq: Float
  gt: Float
  gte: Float
  in: [Float!]
  is: Boolean
  isNot: Boolean
  lt: Float
  lte: Float
  neq: Float
  notBetween: NumberFieldComparisonBetween
  notIn: [Float!]
}

input NumberFieldComparisonBetween {
  lower: Float!
  upper: Float!
}

type OperationBreakdown {
  cost: Float!
  operationType: AiOperationType!
  requestCount: Int!
  tokenCount: Int!
}

type PageInfo {
  """The cursor of the last returned record."""
  endCursor: ConnectionCursor

  """true if paging forward and there are more records."""
  hasNextPage: Boolean

  """true if paging backwards and there are more records."""
  hasPreviousPage: Boolean

  """The cursor of the first returned record."""
  startCursor: ConnectionCursor
}

type PaymentHistoryItem {
  amount: String!
  createdAt: String!
  currency: String!
  description: String
  id: ID!
  invoiceId: String
  method: PaymentMethod!
  refundAmount: String
  refundedAt: String
  status: PaymentStatus!
}

"""Payment method"""
enum PaymentMethod {
  BANK_TRANSFER
  CREDIT_CARD
  DEBIT_CARD
  OTHER
  PAYPAL
}

type PaymentMethodInfo {
  brand: String!
  expiryMonth: String!
  expiryYear: String!
  id: String!
  isDefault: Boolean!
  last4: String!
}

"""Payment status"""
enum PaymentStatus {
  COMPLETED
  FAILED
  PARTIALLY_REFUNDED
  PENDING
  REFUNDED
}

type PdfExportJob {
  """Document ID being exported"""
  documentId: ID!

  """Unique job ID for tracking"""
  jobId: ID!

  """Message describing current state"""
  message: String!

  """Current status of the job"""
  status: String!
}

input PdfExportOptionsInput {
  """Page format (default: A4)"""
  format: PdfPageFormat = A4

  """Include footer with page numbers"""
  includeFooter: Boolean = true

  """Include header with document title and date"""
  includeHeader: Boolean = true

  """Include table of contents"""
  includeTableOfContents: Boolean = false

  """Language for formatting (default: "pl" for Polish)"""
  language: String = "pl"

  """Watermark text (e.g., "DRAFT")"""
  watermark: String
}

type PdfExportResult {
  """Document ID that was exported"""
  documentId: ID!

  """Size of the PDF file in bytes"""
  fileSizeBytes: Float!

  """Generated filename for the PDF"""
  filename: String!

  """Time taken to generate the PDF in milliseconds"""
  generationTimeMs: Float!

  """Number of pages in the PDF"""
  pageCount: Float!

  """Base64-encoded PDF content"""
  pdfBase64: String!
}

type PdfExportStatus {
  """Error message if job failed"""
  error: String

  """Job ID"""
  jobId: ID!

  """Job progress (0-100)"""
  progress: Float

  """Result if job is completed"""
  result: PdfExportResult

  """Current job status"""
  status: String!
}

"""Page format for PDF export"""
enum PdfPageFormat {
  A4
  LEGAL
  LETTER
}

"""Subscription plan tiers"""
enum PlanTier {
  BASIC
  ENTERPRISE
  FREE
  PROFESSIONAL
}

input PolishFormattingRulesInput {
  addressFormat: String
  currencyFormat: String
  dateFormat: String
  legalCitations: Boolean
  numberFormat: String
}

input PublishDocumentInputV2 {
  documentId: ID!
  publishedBy: ID!
}

type Query {
  """
  Advanced search with boolean operators (AND, OR, NOT) and field-specific search
  """
  advancedSearchLegalRulings(input: AdvancedSearchLegalRulingsInput!): AdvancedLegalRulingSearchResponse!

  """
  Search legal rulings across multiple sources (LOCAL, SAOS, ISAP) with relevance ranking
  """
  aggregatedSearchLegalRulings(input: AggregatedSearchLegalRulingsInput!): AggregatedLegalRulingSearchResponse!
  aiUsageMetrics(input: DashboardAnalyticsInput): AiUsageMetrics!
  analyticsDashboard(input: DashboardAnalyticsInput): AnalyticsDashboard!
  auditLog(
    """The id of the record to find."""
    id: ID!
  ): AuditLog!
  auditLogAggregate(
    """Filter to find records to aggregate on"""
    filter: AuditLogAggregateFilter
  ): [AuditLogAggregateResponse!]!
  auditLogs(
    """Specify to filter the records returned."""
    filter: AuditLogFilter! = {}

    """Limit or page results."""
    paging: CursorPaging! = {first: 10}

    """Specify to sort results."""
    sorting: [AuditLogSort!]! = []
  ): AuditLogConnection!
  backup(id: ID!): Backup
  backupStats: BackupStats!
  backups(limit: Float = 50, offset: Float = 0): [Backup!]!

  """Check if the current user can access a specific feature"""
  canAccessFeature(featureKey: String!): Boolean!

  """Check the current user quota for a specific resource"""
  checkQuota(input: CheckQuotaInput!): CheckQuotaResponse!

  """Count legal rulings matching filter criteria"""
  countLegalRulings(input: FilterLegalRulingsInput): Int!
  documentComment(
    """The id of the record to find."""
    id: ID!
  ): DocumentComment!
  documentCommentAggregate(
    """Filter to find records to aggregate on"""
    filter: DocumentCommentAggregateFilter
  ): [DocumentCommentAggregateResponse!]!
  documentComments(
    """Specify to filter the records returned."""
    filter: DocumentCommentFilter! = {}

    """Limit or page results."""
    paging: CursorPaging! = {first: 10}

    """Specify to sort results."""
    sorting: [DocumentCommentSort!]! = []
  ): DocumentCommentConnection!

  """Get the latest version of a document"""
  documentLatestVersion(documentId: ID!): DocumentVersion
  documentMetrics(input: DashboardAnalyticsInput): DocumentMetrics!

  """Get all shares for a document"""
  documentShares(documentId: ID!): [DocumentShare!]!
  documentTemplate(
    """The id of the record to find."""
    id: ID!
  ): DocumentTemplate!
  documentTemplateAggregate(
    """Filter to find records to aggregate on"""
    filter: DocumentTemplateAggregateFilter
  ): [DocumentTemplateAggregateResponse!]!
  documentTemplates(
    """Specify to filter the records returned."""
    filter: DocumentTemplateFilter! = {}

    """Limit or page results."""
    paging: CursorPaging! = {first: 10}

    """Specify to sort results."""
    sorting: [DocumentTemplateSort!]! = []
  ): DocumentTemplateConnection!
  documentV2(id: ID!): LegalDocumentV2
  documentVersion(
    """The id of the record to find."""
    id: ID!
  ): DocumentVersion!
  documentVersionAggregate(
    """Filter to find records to aggregate on"""
    filter: DocumentVersionAggregateFilter
  ): [DocumentVersionAggregateResponse!]!

  """Get a specific version of a document"""
  documentVersionByNumber(documentId: ID!, versionNumber: Float!): DocumentVersion!

  """Count total versions for a document"""
  documentVersionCount(documentId: ID!): Float!

  """Get all versions for a document, ordered by version number descending"""
  documentVersionHistory(documentId: ID!): [DocumentVersion!]!
  documentVersions(
    """Specify to filter the records returned."""
    filter: DocumentVersionFilter! = {}

    """Limit or page results."""
    paging: CursorPaging! = {first: 10}

    """Specify to sort results."""
    sorting: [DocumentVersionSort!]! = []
  ): DocumentVersionConnection!
  documentsByOwnerV2(ownerId: ID!, status: DocumentStatusV2): [LegalDocumentV2!]!
  documentsBySession(sessionId: String!): [LegalDocument!]!

  """Get all documents shared with the current user"""
  documentsSharedWithMe(permission: SharePermission): [DocumentShare!]!

  """Filter legal rulings by multiple criteria"""
  filterLegalRulings(input: FilterLegalRulingsInput!): [LegalRuling!]!
  inAppNotification(
    """The id of the record to find."""
    id: ID!
  ): InAppNotification!
  inAppNotificationAggregate(
    """Filter to find records to aggregate on"""
    filter: InAppNotificationAggregateFilter
  ): [InAppNotificationAggregateResponse!]!
  inAppNotifications(
    """Specify to filter the records returned."""
    filter: InAppNotificationFilter! = {}

    """Limit or page results."""
    paging: CursorPaging! = {first: 10}

    """Specify to sort results."""
    sorting: [InAppNotificationSort!]! = []
  ): InAppNotificationConnection!
  legalAnalyses(
    """Specify to filter the records returned."""
    filter: LegalAnalysisFilter! = {}

    """Limit or page results."""
    paging: CursorPaging! = {first: 10}

    """Specify to sort results."""
    sorting: [LegalAnalysisSort!]! = []
  ): LegalAnalysisConnection!
  legalAnalysis(
    """The id of the record to find."""
    id: ID!
  ): LegalAnalysis!
  legalAnalysisAggregate(
    """Filter to find records to aggregate on"""
    filter: LegalAnalysisAggregateFilter
  ): [LegalAnalysisAggregateResponse!]!
  legalDocument(
    """The id of the record to find."""
    id: ID!
  ): LegalDocument!
  legalDocumentAggregate(
    """Filter to find records to aggregate on"""
    filter: LegalDocumentAggregateFilter
  ): [LegalDocumentAggregateResponse!]!
  legalDocuments(
    """Specify to filter the records returned."""
    filter: LegalDocumentFilter! = {}

    """Limit or page results."""
    paging: CursorPaging! = {first: 10}

    """Specify to sort results."""
    sorting: [LegalDocumentSort!]! = []
  ): LegalDocumentConnection!
  legalQueries(
    """Specify to filter the records returned."""
    filter: LegalQueryFilter! = {}

    """Limit or page results."""
    paging: CursorPaging! = {first: 10}

    """Specify to sort results."""
    sorting: [LegalQuerySort!]! = []
  ): LegalQueryConnection!
  legalQuery(
    """The id of the record to find."""
    id: ID!
  ): LegalQuery!
  legalQueryAggregate(
    """Filter to find records to aggregate on"""
    filter: LegalQueryAggregateFilter
  ): [LegalQueryAggregateResponse!]!
  legalRuling(
    """The id of the record to find."""
    id: ID!
  ): LegalRuling!
  legalRulingAggregate(
    """Filter to find records to aggregate on"""
    filter: LegalRulingAggregateFilter
  ): [LegalRulingAggregateResponse!]!

  """Find a legal ruling by its unique case signature"""
  legalRulingBySignature(signature: String!): LegalRuling
  legalRulings(
    """Specify to filter the records returned."""
    filter: LegalRulingFilter! = {}

    """Limit or page results."""
    paging: CursorPaging! = {first: 10}

    """Specify to sort results."""
    sorting: [LegalRulingSort!]! = []
  ): LegalRulingConnection!

  """Get legal rulings filtered by court type"""
  legalRulingsByCourtType(courtType: CourtType!, limit: Int = 20): [LegalRuling!]!

  """
  Get legal rulings from higher courts (Supreme, Appellate, Constitutional)
  """
  legalRulingsFromHigherCourts(limit: Int = 20): [LegalRuling!]!

  """Get current authenticated user information"""
  me: AuthUser

  """Get all API keys for the current user"""
  myApiKeys: [ApiKey!]!

  """
  Get billing information including subscription status and payment history
  """
  myBillingInfo: BillingInfo
  myDailyUsage(endDate: DateTime, startDate: DateTime): DailyUsageResponse!

  """Get payment history for the current user"""
  myPaymentHistory: [PaymentHistoryItem!]!
  myPreferences: UserPreferences!

  """Get the current user subscription"""
  mySubscription: UserSubscription
  myTotalCost(endDate: DateTime, startDate: DateTime): Float!
  myUsageRecords(endDate: DateTime, limit: Float = 100, offset: Float = 0, operationType: AiOperationType, startDate: DateTime): [AiUsageRecord!]!

  """Get usage statistics for the current user subscription"""
  myUsageStats: SubscriptionUsageStats

  """Get all webhooks for the current user"""
  myWebhooks(status: String): [Webhook!]!
  notification(
    """The id of the record to find."""
    id: ID!
  ): Notification!
  notificationAggregate(
    """Filter to find records to aggregate on"""
    filter: NotificationAggregateFilter
  ): [NotificationAggregateResponse!]!

  """Get notification preferences for a user"""
  notificationPreferences(userId: String!): NotificationDeliveryPreferences!
  notifications(
    """Specify to filter the records returned."""
    filter: NotificationFilter! = {}

    """Limit or page results."""
    paging: CursorPaging! = {first: 10}

    """Specify to sort results."""
    sorting: [NotificationSort!]! = []
  ): NotificationConnection!

  """Get the status of a PDF export job"""
  pdfExportStatus(jobId: ID!): PdfExportStatus!

  """Get all documents pending moderation review"""
  pendingModerationDocuments: [LegalDocument!]!

  """Get legal queries that are waiting for AI answers"""
  pendingQueries(limit: Float): [LegalQuery!]!
  publicSystemSettings: [SystemSetting!]!

  """Get all legal queries for a specific session"""
  queriesBySession(sessionId: String!): [LegalQuery!]!
  queryMetrics(input: DashboardAnalyticsInput): QueryMetrics!

  """Get recent notifications for a user"""
  recentNotifications(limit: Int, unreadOnly: Boolean, userId: String!): [InAppNotification!]!

  """Full-text search across documents with relevance ranking"""
  searchLegalDocuments(input: SearchLegalDocumentsInput!): LegalDocumentSearchResponse!

  """Full-text search across queries with relevance ranking"""
  searchLegalQueries(input: SearchLegalQueriesInput!): LegalQuerySearchResponse!

  """Full-text search for legal rulings with relevance ranking"""
  searchLegalRulings(input: SearchLegalRulingsInput!): LegalRulingSearchResponse!

  """Get a subscription plan by ID"""
  subscriptionPlan(id: String!): SubscriptionPlan

  """Get all active subscription plans ordered by price"""
  subscriptionPlans: [SubscriptionPlan!]!
  systemHealthMetrics(input: DashboardAnalyticsInput): SystemHealthMetrics!
  systemSetting(key: String!): SystemSetting
  systemSettings: [SystemSetting!]!
  systemSettingsByCategory(category: SettingCategory!): [SystemSetting!]!
  topUsersByUsage(by: String = "tokens", endDate: DateTime, limit: Float = 10, startDate: DateTime): String!

  """Get count of unread notifications for a user"""
  unreadNotificationCount(userId: String!): Int!
  usageStats(query: UsageStatsQueryInput!): UsageStatsResponse!
  user(
    """The id of the record to find."""
    id: ID!
  ): User!
  userAggregate(
    """Filter to find records to aggregate on"""
    filter: UserAggregateFilter
  ): [UserAggregateResponse!]!
  userGrowthMetrics(input: DashboardAnalyticsInput): UserGrowthMetrics!
  userPreference(
    """The id of the record to find."""
    id: ID!
  ): UserPreferences!
  userPreferences(
    """Specify to filter the records returned."""
    filter: UserPreferencesFilter! = {}

    """Limit or page results."""
    paging: CursorPaging! = {first: 10}

    """Specify to sort results."""
    sorting: [UserPreferencesSort!]! = []
  ): UserPreferencesConnection!
  userPreferencesAggregate(
    """Filter to find records to aggregate on"""
    filter: UserPreferencesAggregateFilter
  ): [UserPreferencesAggregateResponse!]!
  userSession(
    """The id of the record to find."""
    id: ID!
  ): UserSession!
  userSessionAggregate(
    """Filter to find records to aggregate on"""
    filter: UserSessionAggregateFilter
  ): [UserSessionAggregateResponse!]!
  userSessions(
    """Specify to filter the records returned."""
    filter: UserSessionFilter! = {}

    """Limit or page results."""
    paging: CursorPaging! = {first: 10}

    """Specify to sort results."""
    sorting: [UserSessionSort!]! = []
  ): UserSessionConnection!
  userUsageRecords(endDate: DateTime, limit: Float = 100, offset: Float = 0, operationType: AiOperationType, startDate: DateTime, userId: String!): [AiUsageRecord!]!
  users(
    """Specify to filter the records returned."""
    filter: UserFilter! = {}

    """Limit or page results."""
    paging: CursorPaging! = {first: 10}

    """Specify to sort results."""
    sorting: [UserSort!]! = []
  ): UserConnection!

  """Validate an API key and check if it has the required scopes"""
  validateApiKey(input: ValidateApiKeyInput!): ValidateApiKeyResponse!

  """Get a webhook by ID"""
  webhook(id: String!): Webhook!

  """Get recent deliveries for a webhook"""
  webhookDeliveries(limit: Float = 50, webhookId: String!): [WebhookDelivery!]!

  """Get webhook statistics for the current user"""
  webhookStats: WebhookStats!
}

type QueryMetrics {
  """Average citations per query"""
  avgCitationsPerQuery: Float!

  """Average queries per user"""
  avgQueriesPerUser: Float!
  periodEnd: DateTime!
  periodStart: DateTime!

  """Total citations across all queries"""
  totalCitations: Int!
  totalQueries: Int!
  uniqueUsers: Int!
}

input RefreshTokenInput {
  """Refresh token"""
  refreshToken: String!
}

type RefreshTokenPayload {
  """New JWT access token"""
  accessToken: String!

  """New JWT refresh token"""
  refreshToken: String!
}

input RegisterInput {
  """Email address"""
  email: String!

  """First name"""
  firstName: String

  """Last name"""
  lastName: String

  """User password"""
  password: String!

  """Optional username"""
  username: String
}

input RejectDocumentInput {
  """Document ID to reject"""
  documentId: ID!

  """Reason for rejection (required)"""
  reason: String!
}

type RelatedDocumentLink {
  description: String
  documentId: String!
  relationshipType: String!
  relevanceScore: Float
}

input RelatedDocumentLinkInput {
  description: String
  documentId: String!
  relationshipType: String!
  relevanceScore: Float
}

input RenderTemplateInput {
  templateId: String!
  variables: JSON!
}

input ResetUserPasswordInput {
  newPassword: String!
  userId: ID!
}

input RestoreBackupInput {
  """Create a new database instead of overwriting"""
  createNewDatabase: Boolean
  id: ID!

  """New database name if createNewDatabase is true"""
  newDatabaseName: String

  """Target database name (defaults to current)"""
  targetDatabase: String
}

type RulingMetadata {
  keywords: [String!]
  legalArea: String
  relatedCases: [String!]
  sourceReference: String
}

"""Specific fields to search in"""
enum SearchField {
  ALL
  COURT_NAME
  FULL_TEXT
  KEYWORDS
  LEGAL_AREA
  SIGNATURE
  SUMMARY
}

input SearchLegalDocumentsInput {
  """End date for date range filter (ISO 8601 format)"""
  endDate: String

  """Maximum number of results to return"""
  limit: Int

  """Number of results to skip for pagination"""
  offset: Int

  """Search query for full-text search across title and content"""
  query: String!

  """Filter by session ID"""
  sessionId: String

  """Start date for date range filter (ISO 8601 format)"""
  startDate: String

  """Filter by document status"""
  status: DocumentStatus

  """Filter by document type"""
  type: DocumentType
}

input SearchLegalQueriesInput {
  """End date for date range filter (ISO 8601 format)"""
  endDate: String

  """Maximum number of results to return"""
  limit: Int

  """Number of results to skip for pagination"""
  offset: Int

  """Search query for full-text search across questions and answers"""
  query: String!

  """Filter by session ID"""
  sessionId: String

  """Start date for date range filter (ISO 8601 format)"""
  startDate: String
}

input SearchLegalRulingsInput {
  """Filter by court type"""
  courtType: CourtType

  """Filter by ruling date from (ISO 8601 date string)"""
  dateFrom: String

  """Filter by ruling date to (ISO 8601 date string)"""
  dateTo: String

  """Maximum number of results to return (default: 20, max: 100)"""
  limit: Int = 20

  """Number of results to skip for pagination"""
  offset: Int = 0

  """Search query text"""
  query: String!
}

"""Source of the search result (LOCAL, SAOS, or ISAP)"""
enum SearchSource {
  ISAP
  LOCAL
  SAOS
}

input SendNotificationInput {
  """Optional action label for the action link button"""
  actionLabel: String

  """Optional action link for navigation"""
  actionLink: String

  """Channel to send notification through"""
  channel: NotificationChannel = BOTH

  """Optional custom message for in-app notification"""
  customMessage: String

  """Type of in-app notification for UI styling"""
  inAppType: InAppNotificationType

  """Additional metadata for tracking"""
  metadata: String

  """Priority level of the notification"""
  priority: NotificationPriority = NORMAL

  """Data for template rendering (JSON string)"""
  templateData: String

  """Type of notification template to use"""
  templateType: NotificationTemplateType!

  """User email address"""
  userEmail: String!

  """User ID to receive the notification"""
  userId: String!
}

type SendNotificationResponse {
  """Whether the email notification was sent"""
  emailSent: Boolean!

  """Whether the in-app notification was created"""
  inAppCreated: Boolean!

  """ID of the created in-app notification"""
  notificationId: String
}

"""Mode of operation for a user session"""
enum SessionMode {
  LAWYER
  SIMPLE
}

input SessionModeFilterComparison {
  eq: SessionMode
  gt: SessionMode
  gte: SessionMode
  iLike: SessionMode
  in: [SessionMode!]
  is: Boolean
  isNot: Boolean
  like: SessionMode
  lt: SessionMode
  lte: SessionMode
  neq: SessionMode
  notILike: SessionMode
  notIn: [SessionMode!]
  notLike: SessionMode
}

"""System setting categories"""
enum SettingCategory {
  AI
  FEATURE_FLAGS
  GENERAL
  MAINTENANCE
}

"""System setting value types"""
enum SettingValueType {
  BOOLEAN
  JSON
  NUMBER
  STRING
}

input ShareDocumentInput {
  """ID of the document to share"""
  documentId: ID!

  """Optional expiration date for the share (ISO 8601 format)"""
  expiresAt: String

  """Permission level to grant"""
  permission: SharePermission! = VIEW

  """ID of the user to share the document with"""
  sharedWithUserId: ID!
}

"""Permission level for document sharing"""
enum SharePermission {
  ADMIN
  COMMENT
  EDIT
  VIEW
}

"""Sort Directions"""
enum SortDirection {
  ASC
  DESC
}

"""Sort Nulls Options"""
enum SortNulls {
  NULLS_FIRST
  NULLS_LAST
}

input StringFieldComparison {
  eq: String
  gt: String
  gte: String
  iLike: String
  in: [String!]
  is: Boolean
  isNot: Boolean
  like: String
  lt: String
  lte: String
  neq: String
  notILike: String
  notIn: [String!]
  notLike: String
}

input SubmitLegalQueryInput {
  """The legal question to be answered by the AI"""
  question: String!

  """Session ID for the user submitting the query"""
  sessionId: String!
}

type Subscription {
  """Subscribe to cursor position updates for a document"""
  cursorUpdated(
    """Document ID to receive cursor updates for"""
    documentId: String!
  ): CursorEventPayload!

  """Subscribe to document edits for real-time collaboration"""
  documentEdited(
    """Document ID to receive edit updates for"""
    documentId: String!
  ): DocumentEditEventPayload!

  """Subscribe to document status changes"""
  documentStatusChanged(
    """Filter by document ID"""
    documentId: String

    """Filter by session ID"""
    sessionId: String
  ): DocumentStatusChange!

  """Subscribe to new in-app notifications"""
  inAppNotificationCreated(
    """Filter by user ID"""
    userId: String
  ): InAppNotificationCreatedPayload!

  """Subscribe to user joined events for a document"""
  userJoinedDocument(
    """Document ID to receive user joined events for"""
    documentId: String!
  ): UserJoinedEventPayload!

  """Subscribe to user left events for a document"""
  userLeftDocument(
    """Document ID to receive user left events for"""
    documentId: String!
  ): UserLeftEventPayload!
}

type SubscriptionPlan {
  billingInterval: BillingInterval!
  createdAt: DateTime!
  description: String
  displayOrder: Float!
  features: String!
  id: ID!
  isActive: Boolean!
  maxUsers: Int
  name: String!
  price: Float!
  stripePriceId: String
  stripeYearlyPriceId: String
  tier: PlanTier!
  trialDays: Float!
  updatedAt: DateTime!
  yearlyDiscount: Float!
}

"""Subscription status"""
enum SubscriptionStatus {
  ACTIVE
  CANCELED
  EXPIRED
  PAST_DUE
  TRIALING
}

type SubscriptionUsageStats {
  daysRemaining: Int!
  periodEnd: String!
  periodStart: String!
  planTier: PlanTier!
  subscriptionId: ID!
  usage: String!
}

input SuspendUserInput {
  reason: String!
  userId: ID!
}

type SystemHealthMetrics {
  """Active user sessions (placeholder)"""
  activeSessions: Int!

  """Average AI response time in ms (placeholder)"""
  avgResponseTime: Float!

  """Document generation success rate"""
  documentSuccessRate: Float!
  timestamp: DateTime!
}

type SystemSetting {
  category: SettingCategory!
  createdAt: DateTime!
  description: String
  id: ID!
  key: String!
  metadata: String
  updatedAt: DateTime!
  value: String
  valueType: SettingValueType!
}

input SystemSettingInput {
  category: SettingCategory
  description: String
  key: String!
  metadata: String
  value: String
  valueType: SettingValueType
}

"""Category of legal document template"""
enum TemplateCategory {
  COMPLAINT
  CONTRACT
  LAWSUIT
  LETTER
  MOTION
  OTHER
}

input TemplateCategoryFilterComparison {
  eq: TemplateCategory
  gt: TemplateCategory
  gte: TemplateCategory
  iLike: TemplateCategory
  in: [TemplateCategory!]
  is: Boolean
  isNot: Boolean
  like: TemplateCategory
  lt: TemplateCategory
  lte: TemplateCategory
  neq: TemplateCategory
  notILike: TemplateCategory
  notIn: [TemplateCategory!]
  notLike: TemplateCategory
}

input TemplateVariableInput {
  defaultValue: String
  description: String
  label: String!
  name: String!
  required: Boolean!
  type: String!
  validation: JSON
}

input TestWebhookInput {
  event: String = "test.event"
  payload: String
  webhookId: String!
}

type TestWebhookResponse {
  durationMs: Int!
  error: String
  response: String
  statusCode: Int
  success: Boolean!
}

"""Available theme options for the UI"""
enum ThemePreference {
  DARK
  LIGHT
  SYSTEM
}

input ThemePreferenceFilterComparison {
  eq: ThemePreference
  gt: ThemePreference
  gte: ThemePreference
  iLike: ThemePreference
  in: [ThemePreference!]
  is: Boolean
  isNot: Boolean
  like: ThemePreference
  lt: ThemePreference
  lte: ThemePreference
  neq: ThemePreference
  notILike: ThemePreference
  notIn: [ThemePreference!]
  notLike: ThemePreference
}

"""
`Date` type as integer. Type represents date and time as number of milliseconds from start of UNIX epoch.
"""
scalar Timestamp

input UpdateApiKeyInput {
  description: String
  expiresAt: String
  name: String
  rateLimitPerMinute: Int
  scopes: [ApiKeyScope!]
}

input UpdateDocumentCommentInput {
  position: CreateCommentPositionInput
  resolutionStatus: CommentResolutionStatus

  """
  ID of the user who resolved the comment (required when marking as resolved)
  """
  resolvedBy: String
  text: String
}

input UpdateDocumentInput {
  metadata: DocumentMetadataInput
  title: String
}

input UpdateDocumentTemplateInput {
  category: TemplateCategory
  conditionalSections: [ConditionalSectionInput!]
  content: String
  description: String
  isActive: String
  name: String
  polishFormattingRules: PolishFormattingRulesInput
  variables: [TemplateVariableInput!]
}

input UpdateDocumentTitleInputV2 {
  documentId: ID!
  title: String!
  updatedBy: ID!
}

input UpdateDocumentVersionInput {
  changeDescription: String
}

input UpdateInAppNotificationInput {
  """Optional action label for the action link button"""
  actionLabel: String

  """Optional action link for navigation"""
  actionLink: String

  """The notification message content"""
  message: String

  """Additional metadata for extensibility (JSON string)"""
  metadata: String

  """Read status"""
  read: Boolean

  """Type of notification for UI styling"""
  type: String
}

input UpdateLegalAnalysisInput {
  identifiedGrounds: [LegalGroundInput!]
  inputDescription: String
  metadata: AnalysisMetadataInput
  overallConfidenceScore: Float
  recommendations: String
  relatedDocumentLinks: [RelatedDocumentLinkInput!]
  summary: String
  title: String
}

input UpdateLegalDocumentInput {
  contentRaw: String
  metadata: CreateDocumentMetadataInput

  """Signed URL to download the PDF version of this document"""
  pdfUrl: String
  title: String
  type: DocumentType
}

input UpdateLegalQueryInput {
  answerMarkdown: String
  citations: [CreateCitationInput!]
  question: String
}

input UpdateLegalRulingInput {
  courtName: String
  courtType: CourtType
  fullText: String
  metadata: CreateRulingMetadataInput
  rulingDate: String
  signature: String
  summary: String
}

input UpdateNotificationInput {
  """Error message if sending failed"""
  errorMessage: String

  """SendGrid message ID"""
  messageId: String

  """Additional metadata (JSON string)"""
  metadata: String

  """Recipient email address"""
  recipientEmail: String

  """Timestamp when email was sent"""
  sentAt: String

  """Notification status"""
  status: NotificationStatus

  """Email subject line"""
  subject: String

  """Email template type"""
  template: EmailTemplateType

  """Template data for rendering (JSON string)"""
  templateData: String

  """User ID"""
  userId: String
}

input UpdateOneDocumentCommentInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateDocumentCommentInput!
}

input UpdateOneDocumentTemplateInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateDocumentTemplateInput!
}

input UpdateOneDocumentVersionInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateDocumentVersionInput!
}

input UpdateOneInAppNotificationInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateInAppNotificationInput!
}

input UpdateOneLegalAnalysisInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateLegalAnalysisInput!
}

input UpdateOneLegalDocumentInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateLegalDocumentInput!
}

input UpdateOneLegalQueryInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateLegalQueryInput!
}

input UpdateOneLegalRulingInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateLegalRulingInput!
}

input UpdateOneNotificationInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateNotificationInput!
}

input UpdateOneUserInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateUserInput!
}

input UpdateOneUserPreferencesInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateUserPreferencesInput!
}

input UpdateProfileInput {
  """Email address"""
  email: String

  """First name"""
  firstName: String

  """Last name"""
  lastName: String

  """Username"""
  username: String
}

input UpdateSharePermissionInput {
  """New permission level"""
  permission: SharePermission!

  """ID of the share to update"""
  shareId: ID!
}

input UpdateSubscriptionPlanInput {
  billingInterval: BillingInterval
  description: String
  displayOrder: Int
  features: String
  isActive: Boolean
  maxUsers: Int
  name: String
  price: Int
  stripePriceId: String
  stripeYearlyPriceId: String
  trialDays: Int
  yearlyDiscount: Int
}

input UpdateTemplateInput {
  category: TemplateCategory
  conditionalSections: JSON
  content: String
  description: String
  isActive: Boolean
  name: String
  polishFormattingRules: JSON
  variables: JSON
}

input UpdateUserInput {
  disclaimerAccepted: Boolean
  email: String
  firstName: String
  isActive: Boolean
  lastName: String
  username: String
}

input UpdateUserPreferencesInput {
  aiModel: AiModelType
  dateFormat: String
  emailNotifications: Boolean
  inAppNotifications: Boolean
  locale: String
  notificationPreferences: NotificationPreferencesInput
  theme: ThemePreference
  timezone: String
}

input UpdateWebhookInput {
  description: String
  events: [WebhookEvent!]
  headers: String
  maxRetries: Int
  name: String
  status: WebhookStatus
  timeoutMs: Int
  url: String
}

input UsageStatsQueryInput {
  endDate: DateTime
  operationType: AiOperationType
  startDate: DateTime
  userId: ID
}

type UsageStatsResponse {
  breakdownByOperation: [OperationBreakdown!]
  operationCount: Int!
  periodEnd: DateTime!
  periodStart: DateTime!
  totalCost: Float!
  totalRequests: Int!
  totalTokens: Int!
}

type User {
  createdAt: DateTime!
  disclaimerAccepted: Boolean!
  disclaimerAcceptedAt: DateTime
  email: String!
  firstName: String
  id: ID!
  isActive: Boolean!
  lastName: String
  role: String!
  sessions: UserSession
  stripeCustomerId: String
  updatedAt: DateTime!
  username: String
}

input UserAggregateFilter {
  and: [UserAggregateFilter!]
  createdAt: DateFieldComparison
  email: StringFieldComparison
  id: IDFilterComparison
  isActive: BooleanFieldComparison
  or: [UserAggregateFilter!]
  role: StringFieldComparison
  updatedAt: DateFieldComparison
}

type UserAggregateGroupBy {
  createdAt(by: GroupBy! = DAY): DateTime
  email: String
  id: ID
  isActive: Boolean
  role: String
  updatedAt(by: GroupBy! = DAY): DateTime
}

type UserAggregateResponse {
  count: UserCountAggregate
  groupBy: UserAggregateGroupBy
  max: UserMaxAggregate
  min: UserMinAggregate
}

type UserConnection {
  """Array of edges."""
  edges: [UserEdge!]!

  """Paging information"""
  pageInfo: PageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type UserCountAggregate {
  createdAt: Int
  email: Int
  id: Int
  isActive: Int
  role: Int
  updatedAt: Int
}

type UserDeleteResponse {
  createdAt: DateTime
  disclaimerAccepted: Boolean
  disclaimerAcceptedAt: DateTime
  email: String
  firstName: String
  id: ID
  isActive: Boolean
  lastName: String
  role: String
  stripeCustomerId: String
  updatedAt: DateTime
  username: String
}

type UserEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the User"""
  node: User!
}

input UserFilter {
  and: [UserFilter!]
  createdAt: DateFieldComparison
  email: StringFieldComparison
  id: IDFilterComparison
  isActive: BooleanFieldComparison
  or: [UserFilter!]
  role: StringFieldComparison
  updatedAt: DateFieldComparison
}

type UserGrowthMetrics {
  activeUsers: Int!
  adminUsers: Int!

  """Growth rate as percentage"""
  growthRate: Float!
  newUsers: Int!
  periodEnd: DateTime!
  periodStart: DateTime!
  totalUsers: Int!
}

type UserJoinedEventPayload {
  color: String
  documentId: ID!
  timestamp: DateTime!
  userId: ID!
  userName: String!
}

type UserLeftEventPayload {
  documentId: ID!
  timestamp: DateTime!
  userId: ID!
  userName: String!
}

type UserMaxAggregate {
  createdAt: DateTime
  email: String
  id: ID
  role: String
  updatedAt: DateTime
}

type UserMinAggregate {
  createdAt: DateTime
  email: String
  id: ID
  role: String
  updatedAt: DateTime
}

type UserPreferences {
  aiModel: AiModelType!
  createdAt: DateTime!
  dateFormat: String
  emailNotifications: Boolean!
  getNotificationPreferences: NotificationPreferences!
  id: ID!
  inAppNotifications: Boolean!
  locale: String!
  theme: ThemePreference!
  timezone: String
  updatedAt: DateTime!
  user: User!
  userId: String!
}

input UserPreferencesAggregateFilter {
  aiModel: AiModelTypeFilterComparison
  and: [UserPreferencesAggregateFilter!]
  createdAt: DateFieldComparison
  emailNotifications: BooleanFieldComparison
  id: IDFilterComparison
  inAppNotifications: BooleanFieldComparison
  locale: StringFieldComparison
  or: [UserPreferencesAggregateFilter!]
  theme: ThemePreferenceFilterComparison
  updatedAt: DateFieldComparison
  userId: StringFieldComparison
}

type UserPreferencesAggregateGroupBy {
  aiModel: AiModelType
  createdAt(by: GroupBy! = DAY): DateTime
  emailNotifications: Boolean
  id: ID
  inAppNotifications: Boolean
  locale: String
  theme: ThemePreference
  updatedAt(by: GroupBy! = DAY): DateTime
  userId: String
}

type UserPreferencesAggregateResponse {
  count: UserPreferencesCountAggregate
  groupBy: UserPreferencesAggregateGroupBy
  max: UserPreferencesMaxAggregate
  min: UserPreferencesMinAggregate
}

type UserPreferencesConnection {
  """Array of edges."""
  edges: [UserPreferencesEdge!]!

  """Paging information"""
  pageInfo: PageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type UserPreferencesCountAggregate {
  aiModel: Int
  createdAt: Int
  emailNotifications: Int
  id: Int
  inAppNotifications: Int
  locale: Int
  theme: Int
  updatedAt: Int
  userId: Int
}

type UserPreferencesDeleteResponse {
  aiModel: AiModelType
  createdAt: DateTime
  dateFormat: String
  emailNotifications: Boolean
  getNotificationPreferences: NotificationPreferences
  id: ID
  inAppNotifications: Boolean
  locale: String
  theme: ThemePreference
  timezone: String
  updatedAt: DateTime
  userId: String
}

type UserPreferencesEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the UserPreferences"""
  node: UserPreferences!
}

input UserPreferencesFilter {
  aiModel: AiModelTypeFilterComparison
  and: [UserPreferencesFilter!]
  createdAt: DateFieldComparison
  emailNotifications: BooleanFieldComparison
  id: IDFilterComparison
  inAppNotifications: BooleanFieldComparison
  locale: StringFieldComparison
  or: [UserPreferencesFilter!]
  theme: ThemePreferenceFilterComparison
  updatedAt: DateFieldComparison
  userId: StringFieldComparison
}

type UserPreferencesMaxAggregate {
  aiModel: AiModelType
  createdAt: DateTime
  id: ID
  locale: String
  theme: ThemePreference
  updatedAt: DateTime
  userId: String
}

type UserPreferencesMinAggregate {
  aiModel: AiModelType
  createdAt: DateTime
  id: ID
  locale: String
  theme: ThemePreference
  updatedAt: DateTime
  userId: String
}

input UserPreferencesSort {
  direction: SortDirection!
  field: UserPreferencesSortFields!
  nulls: SortNulls
}

enum UserPreferencesSortFields {
  aiModel
  createdAt
  emailNotifications
  id
  inAppNotifications
  locale
  theme
  updatedAt
  userId
}

type UserSession {
  createdAt: DateTime!
  endedAt: DateTime
  id: ID!
  mode: SessionMode!
  startedAt: DateTime
  updatedAt: DateTime!
  user: User!
  userId: String!
}

input UserSessionAggregateFilter {
  and: [UserSessionAggregateFilter!]
  createdAt: DateFieldComparison
  id: IDFilterComparison
  mode: SessionModeFilterComparison
  or: [UserSessionAggregateFilter!]
  updatedAt: DateFieldComparison
  userId: StringFieldComparison
}

type UserSessionAggregateGroupBy {
  createdAt(by: GroupBy! = DAY): DateTime
  id: ID
  mode: SessionMode
  updatedAt(by: GroupBy! = DAY): DateTime
  userId: String
}

type UserSessionAggregateResponse {
  count: UserSessionCountAggregate
  groupBy: UserSessionAggregateGroupBy
  max: UserSessionMaxAggregate
  min: UserSessionMinAggregate
}

type UserSessionConnection {
  """Array of edges."""
  edges: [UserSessionEdge!]!

  """Paging information"""
  pageInfo: PageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type UserSessionCountAggregate {
  createdAt: Int
  id: Int
  mode: Int
  updatedAt: Int
  userId: Int
}

type UserSessionDeleteResponse {
  createdAt: DateTime
  endedAt: DateTime
  id: ID
  mode: SessionMode
  startedAt: DateTime
  updatedAt: DateTime
  userId: String
}

type UserSessionEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the UserSession"""
  node: UserSession!
}

input UserSessionFilter {
  and: [UserSessionFilter!]
  createdAt: DateFieldComparison
  id: IDFilterComparison
  mode: SessionModeFilterComparison
  or: [UserSessionFilter!]
  updatedAt: DateFieldComparison
  userId: StringFieldComparison
}

type UserSessionMaxAggregate {
  createdAt: DateTime
  id: ID
  mode: SessionMode
  updatedAt: DateTime
  userId: String
}

type UserSessionMinAggregate {
  createdAt: DateTime
  id: ID
  mode: SessionMode
  updatedAt: DateTime
  userId: String
}

input UserSessionSort {
  direction: SortDirection!
  field: UserSessionSortFields!
  nulls: SortNulls
}

enum UserSessionSortFields {
  createdAt
  id
  mode
  updatedAt
  userId
}

input UserSort {
  direction: SortDirection!
  field: UserSortFields!
  nulls: SortNulls
}

enum UserSortFields {
  createdAt
  email
  id
  isActive
  role
  updatedAt
}

type UserSubscription {
  cancelAtPeriodEnd: Boolean!
  canceledAt: DateTime
  createdAt: DateTime!
  currentPeriodEnd: DateTime!
  currentPeriodStart: DateTime!
  id: ID!
  lastPaymentAmount: Int
  lastPaymentAt: DateTime
  planId: String!
  startDate: DateTime!
  status: SubscriptionStatus!
  stripeCustomerId: String
  stripeSubscriptionId: String
  trialEndDate: DateTime
  updatedAt: DateTime!
  usage: String!
  userId: String!
}

input ValidateApiKeyInput {
  rawKey: String!
  requiredScopes: [ApiKeyScope!]
}

type ValidateApiKeyResponse {
  apiKeyId: ID
  isValid: Boolean!
  message: String
  scopes: [ApiKeyScope!]
  status: ApiKeyStatus
  userId: ID
}

type Webhook {
  createdAt: DateTime!
  description: String
  events: [WebhookEvent!]!
  failureCount: Float!
  headers: String
  id: ID!
  lastDeliveryAt: DateTime
  lastSuccessAt: DateTime
  maxRetries: Float!
  name: String!
  status: WebhookStatus!
  successCount: Float!
  timeoutMs: Float!
  updatedAt: DateTime!
  url: String!
  userId: String!
}

type WebhookDelivery {
  attemptCount: Int!
  createdAt: DateTime!
  durationMs: Int
  errorMessage: String
  event: String!
  httpResponseCode: Int
  id: ID!
  jobId: String
  nextRetryAt: DateTime
  payload: String!
  responseBody: String
  status: DeliveryStatus!
  webhookId: String!
}

"""Events that can be subscribed to"""
enum WebhookEvent {
  DOCUMENT_CREATED
  DOCUMENT_DELETED
  DOCUMENT_EXPORTED
  DOCUMENT_GENERATION_COMPLETED
  DOCUMENT_UPDATED
  QUERY_ANSWERED
  QUERY_ASKED
  SUBSCRIPTION_CANCELLED
  SUBSCRIPTION_CREATED
  SUBSCRIPTION_UPGRADED
  USER_CREATED
  USER_UPDATED
}

type WebhookStats {
  activeWebhooks: Int!
  failedDeliveries: Int!
  pendingDeliveries: Int!
  successfulDeliveries: Int!
  totalDeliveries: Int!
  totalWebhooks: Int!
}

"""Webhook status"""
enum WebhookStatus {
  ACTIVE
  DISABLED
  INACTIVE
}