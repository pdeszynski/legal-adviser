import {
  Resolver,
  Mutation,
  Args,
  Context,
  InputType,
  Field,
  ID,
} from '@nestjs/graphql';
import { UseGuards } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { DemoRequestOrmEntity } from '../../infrastructure/persistence/entities/demo-request.orm-entity';
import { GqlAuthGuard } from '../auth/guards/gql-auth.guard';
import { RoleGuard, RequireAdmin } from '../auth/guards/role.guard';
import { DemoRequestStatusEnum } from '../../domain/demo-request/value-objects';

/**
 * Input for updating demo request status
 */
@InputType()
class UpdateDemoRequestStatusInput {
  @Field(() => ID)
  demoRequestId: string;

  @Field(() => String)
  status: DemoRequestStatusEnum;
}

/**
 * Input for scheduling a demo
 */
@InputType()
class ScheduleDemoInput {
  @Field(() => ID)
  demoRequestId: string;

  @Field(() => Date)
  scheduledTime: Date;
}

/**
 * Demo Requests Admin Resolver
 *
 * Provides admin-only operations for demo request management:
 * - Update demo request status
 * - Schedule demo time
 * - Sync status to HubSpot
 *
 * Note: Queries (demoRequests, demoRequest) are auto-generated by nestjs-query
 * via the @ObjectType decorator on DemoRequestOrmEntity.
 *
 * Admin-only operations (this resolver):
 * - updateDemoRequestStatus: Change demo request status
 * - scheduleDemo: Schedule a demo time
 */
@Resolver(() => DemoRequestOrmEntity)
export class DemoRequestsAdminResolver {
  constructor(
    @InjectRepository(DemoRequestOrmEntity)
    private readonly repository: Repository<DemoRequestOrmEntity>,
  ) {}

  /**
   * Mutation: Update demo request status
   *
   * Updates the status of a demo request in the sales pipeline.
   * Requires authentication and admin role.
   */
  @Mutation(() => DemoRequestOrmEntity, {
    name: 'updateDemoRequestStatus',
    description: 'Update demo request status (admin only)',
  })
  @UseGuards(GqlAuthGuard, RoleGuard)
  @RequireAdmin()
  async updateDemoRequestStatus(
    @Args('input') input: UpdateDemoRequestStatusInput,
    @Context() context: { req: { user: { id: string } } },
  ): Promise<DemoRequestOrmEntity> {
    const demoRequest = await this.repository.findOne({
      where: { id: input.demoRequestId },
    });

    if (!demoRequest) {
      throw new Error('Demo request not found');
    }

    demoRequest.status = input.status;

    // Set contactedAt when moving to CONTACTED
    if (
      input.status === DemoRequestStatusEnum.CONTACTED &&
      !demoRequest.contactedAt
    ) {
      demoRequest.contactedAt = new Date();
    }

    return this.repository.save(demoRequest);
  }

  /**
   * Mutation: Schedule a demo
   *
   * Sets the scheduled demo time and updates status to SCHEDULED.
   * Requires authentication and admin role.
   */
  @Mutation(() => DemoRequestOrmEntity, {
    name: 'scheduleDemo',
    description: 'Schedule a demo time (admin only)',
  })
  @UseGuards(GqlAuthGuard, RoleGuard)
  @RequireAdmin()
  async scheduleDemo(
    @Args('input') input: ScheduleDemoInput,
    @Context() context: { req: { user: { id: string } } },
  ): Promise<DemoRequestOrmEntity> {
    const demoRequest = await this.repository.findOne({
      where: { id: input.demoRequestId },
    });

    if (!demoRequest) {
      throw new Error('Demo request not found');
    }

    demoRequest.preferredDemoTime = input.scheduledTime;
    demoRequest.status = DemoRequestStatusEnum.SCHEDULED;

    // Store scheduled time in metadata
    const metadata = (demoRequest.metadata || {}) as Record<string, unknown>;
    metadata.scheduledAt = new Date().toISOString();
    demoRequest.metadata = metadata;

    return this.repository.save(demoRequest);
  }
}
