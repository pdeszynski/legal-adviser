import { Injectable, Logger } from '@nestjs/common';
import * as fs from 'node:fs';
import * as path from 'node:path';

/**
 * Persisted query manifest format
 */
interface PersistedQueryManifest {
  format: string;
  version: number;
  operations: Record<
    string,
    {
      type: string;
      name: string;
      body: string;
    }
  >;
}

/**
 * Persisted Queries Service
 *
 * Manages persisted query lookup and validation.
 * Loads the persisted query manifest generated by GraphQL Codegen
 * and provides methods to look up queries by their hash.
 *
 * This service enables:
 * - Automatic Persisted Queries (APQ) support
 * - Reduced bandwidth by sending query hashes instead of full queries
 * - Enhanced security by only allowing pre-registered queries
 */
@Injectable()
export class PersistedQueriesService {
  private readonly logger = new Logger(PersistedQueriesService.name);
  private manifest: PersistedQueryManifest | null = null;
  private readonly manifestPath: string;

  constructor() {
    // Path to the persisted query manifest generated by GraphQL Codegen
    this.manifestPath = path.join(
      process.cwd(),
      'src',
      'generated',
      'persisted-queries',
      'server.json',
    );

    this.loadManifest();
  }

  /**
   * Load the persisted query manifest from disk
   * Called during service initialization
   */
  private loadManifest(): void {
    try {
      if (fs.existsSync(this.manifestPath)) {
        const manifestContent = fs.readFileSync(this.manifestPath, 'utf-8');
        this.manifest = JSON.parse(manifestContent) as PersistedQueryManifest;
        this.logger.log(
          `Loaded ${this.manifest ? Object.keys(this.manifest.operations).length : 0} persisted queries from manifest`,
        );
      } else {
        this.logger.warn(
          `Persisted query manifest not found at ${this.manifestPath}. Persisted queries will not be available until codegen is run.`,
        );
      }
    } catch (error) {
      this.logger.error(
        `Failed to load persisted query manifest: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Reload the manifest from disk
   * Useful for development or when the manifest is updated
   */
  reloadManifest(): void {
    this.manifest = null;
    this.loadManifest();
  }

  /**
   * Get the full query document by its hash
   *
   * @param hash - The SHA256 hash of the query (with or without "sha256:" prefix)
   * @returns The query document string, or null if not found
   */
  getQuery(hash: string): string | null {
    if (!this.manifest) {
      return null;
    }

    // Normalize hash to include prefix if missing
    const normalizedHash = hash.startsWith('sha256:') ? hash : `sha256:${hash}`;

    const operation = this.manifest.operations[normalizedHash];
    return operation?.body ?? null;
  }

  /**
   * Check if a query hash exists in the manifest
   *
   * @param hash - The SHA256 hash of the query (with or without "sha256:" prefix)
   * @returns True if the query is registered, false otherwise
   */
  hasQuery(hash: string): boolean {
    if (!this.manifest) {
      return false;
    }

    const normalizedHash = hash.startsWith('sha256:') ? hash : `sha256:${hash}`;
    return normalizedHash in this.manifest.operations;
  }

  /**
   * Get all registered query hashes
   *
   * @returns Array of all registered query hashes
   */
  getAllHashes(): string[] {
    if (!this.manifest) {
      return [];
    }

    return Object.keys(this.manifest.operations);
  }

  /**
   * Get operation metadata by hash
   *
   * @param hash - The SHA256 hash of the query (with or without "sha256:" prefix)
   * @returns Operation metadata (type, name, body), or null if not found
   */
  getOperation(
    hash: string,
  ): PersistedQueryManifest['operations'][string] | null {
    if (!this.manifest) {
      return null;
    }

    const normalizedHash = hash.startsWith('sha256:') ? hash : `sha256:${hash}`;
    return this.manifest.operations[normalizedHash] ?? null;
  }

  /**
   * Check if the manifest is loaded
   *
   * @returns True if manifest is loaded, false otherwise
   */
  isLoaded(): boolean {
    return this.manifest !== null;
  }
}
