import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  ManyToOne,
  JoinColumn,
  CreateDateColumn,
  UpdateDateColumn,
} from 'typeorm';
import { UserSession } from '../../users/entities/user-session.entity';

/**
 * Document Type Enum
 *
 * Defines the type of legal document:
 * - LAWSUIT: Court lawsuit document
 * - COMPLAINT: Legal complaint document
 * - CONTRACT: Contract or agreement document
 * - OTHER: Other legal document types
 */
export enum DocumentType {
  LAWSUIT = 'LAWSUIT',
  COMPLAINT = 'COMPLAINT',
  CONTRACT = 'CONTRACT',
  OTHER = 'OTHER',
}

/**
 * Document Status Enum
 *
 * Defines the generation/processing status of a document:
 * - DRAFT: Initial draft, not yet processed by AI
 * - GENERATING: Currently being generated by AI
 * - COMPLETED: Successfully generated and ready
 * - FAILED: Generation failed
 */
export enum DocumentStatus {
  DRAFT = 'DRAFT',
  GENERATING = 'GENERATING',
  COMPLETED = 'COMPLETED',
  FAILED = 'FAILED',
}

/**
 * Document Metadata Interface
 *
 * Context variables used during document generation
 * (e.g., defendant name, claim amount, dates)
 */
export interface DocumentMetadata {
  /** Name of the defendant (if applicable) */
  defendantName?: string;
  /** Name of the plaintiff (if applicable) */
  plaintiffName?: string;
  /** Monetary claim amount (if applicable) */
  claimAmount?: number;
  /** Currency for claim amount */
  claimCurrency?: string;
  /** Additional context variables */
  [key: string]: unknown;
}

/**
 * LegalDocument Entity
 *
 * Represents a legal document generated or managed by the system.
 * Documents are created within user sessions and processed by the AI engine.
 *
 * Aggregate Root: LegalDocument
 * Invariants:
 *   - A document cannot be marked `COMPLETED` without content
 *   - content_raw must be a valid string
 */
@Entity('legal_documents')
export class LegalDocument {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ type: 'uuid' })
  sessionId: string;

  @ManyToOne(() => UserSession, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'sessionId' })
  session: UserSession;

  @Column({ type: 'varchar', length: 500 })
  title: string;

  @Column({
    type: 'enum',
    enum: DocumentType,
    default: DocumentType.OTHER,
  })
  type: DocumentType;

  @Column({
    type: 'enum',
    enum: DocumentStatus,
    default: DocumentStatus.DRAFT,
  })
  status: DocumentStatus;

  /**
   * Raw content of the document (Markdown or structured text)
   * This field stores the AI-generated content
   */
  @Column({ type: 'text', nullable: true })
  contentRaw: string | null;

  /**
   * Metadata containing context variables used during generation
   * Stored as JSON (e.g., defendant name, claim amount)
   */
  @Column({ type: 'jsonb', nullable: true })
  metadata: DocumentMetadata | null;

  @CreateDateColumn({ type: 'timestamp' })
  createdAt: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  updatedAt: Date;

  /**
   * Check if the document can be marked as completed
   * A document requires content to be completed
   */
  canComplete(): boolean {
    return this.contentRaw !== null && this.contentRaw.trim().length > 0;
  }

  /**
   * Mark the document as completed
   * @throws Error if document has no content
   */
  markCompleted(): void {
    if (!this.canComplete()) {
      throw new Error('Cannot complete document without content');
    }
    this.status = DocumentStatus.COMPLETED;
  }

  /**
   * Mark the document as generating (AI processing in progress)
   */
  markGenerating(): void {
    this.status = DocumentStatus.GENERATING;
  }

  /**
   * Mark the document as failed
   */
  markFailed(): void {
    this.status = DocumentStatus.FAILED;
  }

  /**
   * Check if the document has been successfully generated
   */
  isCompleted(): boolean {
    return this.status === DocumentStatus.COMPLETED;
  }

  /**
   * Check if the document is currently being generated
   */
  isGenerating(): boolean {
    return this.status === DocumentStatus.GENERATING;
  }

  /**
   * Check if the document generation failed
   */
  hasFailed(): boolean {
    return this.status === DocumentStatus.FAILED;
  }
}
