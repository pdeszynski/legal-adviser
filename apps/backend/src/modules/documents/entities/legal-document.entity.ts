import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  ManyToOne,
  JoinColumn,
  CreateDateColumn,
  UpdateDateColumn,
  Index,
  BeforeInsert,
  BeforeUpdate,
} from 'typeorm';
import {
  FilterableField,
  IDField,
  QueryOptions,
  Relation,
} from '@ptc-org/nestjs-query-graphql';
import {
  ObjectType,
  ID,
  Field,
  GraphQLISODateTime,
  registerEnumType,
} from '@nestjs/graphql';
import { UserSession } from '../../users/entities/user-session.entity';

/**
 * Document Type Enum
 *
 * Defines the type of legal document:
 * - LAWSUIT: Court lawsuit document
 * - COMPLAINT: Legal complaint document
 * - CONTRACT: Contract or agreement document
 * - OTHER: Other legal document types
 */
export enum DocumentType {
  LAWSUIT = 'LAWSUIT',
  COMPLAINT = 'COMPLAINT',
  CONTRACT = 'CONTRACT',
  OTHER = 'OTHER',
}

/**
 * Document Status Enum
 *
 * Defines the generation/processing status of a document:
 * - DRAFT: Initial draft, not yet processed by AI
 * - GENERATING: Currently being generated by AI
 * - COMPLETED: Successfully generated and ready
 * - FAILED: Generation failed
 */
export enum DocumentStatus {
  DRAFT = 'DRAFT',
  GENERATING = 'GENERATING',
  COMPLETED = 'COMPLETED',
  FAILED = 'FAILED',
}

/**
 * Moderation Status Enum
 *
 * Defines the moderation status of a document:
 * - PENDING: Document is flagged and pending moderation review
 * - APPROVED: Document has been approved by moderator
 * - REJECTED: Document has been rejected by moderator
 */
export enum ModerationStatus {
  PENDING = 'PENDING',
  APPROVED = 'APPROVED',
  REJECTED = 'REJECTED',
}

// Register enums with GraphQL
registerEnumType(DocumentType, {
  name: 'DocumentType',
  description: 'Type of legal document',
});

registerEnumType(DocumentStatus, {
  name: 'DocumentStatus',
  description: 'Status of document generation',
});

registerEnumType(ModerationStatus, {
  name: 'ModerationStatus',
  description: 'Moderation status of document',
});

/**
 * Document Metadata Interface
 *
 * Context variables used during document generation
 * (e.g., defendant name, claim amount, dates)
 */
export interface DocumentMetadata {
  /** Name of the defendant (if applicable) */
  defendantName?: string;
  /** Name of the plaintiff (if applicable) */
  plaintiffName?: string;
  /** Monetary claim amount (if applicable) */
  claimAmount?: number;
  /** Currency for claim amount */
  claimCurrency?: string;
  /** Additional context variables */
  [key: string]: unknown;
}

/**
 * GraphQL Object Type for Document Metadata
 * Used by nestjs-query for field resolution
 */
@ObjectType('DocumentMetadata')
export class DocumentMetadataType {
  @Field(() => String, { nullable: true })
  plaintiffName?: string;

  @Field(() => String, { nullable: true })
  defendantName?: string;

  @Field(() => Number, { nullable: true })
  claimAmount?: number;

  @Field(() => String, { nullable: true })
  claimCurrency?: string;
}

/**
 * LegalDocument Entity
 *
 * Represents a legal document generated or managed by the system.
 * Documents are created within user sessions and processed by the AI engine.
 *
 * Aggregate Root: LegalDocument
 * Invariants:
 *   - A document cannot be marked `COMPLETED` without content
 *   - content_raw must be a valid string
 *
 * Uses nestjs-query decorators for auto-generated CRUD resolvers.
 */
@Entity('legal_documents')
@ObjectType('LegalDocument')
@QueryOptions({ enableTotalCount: true })
@Relation('session', () => UserSession)
@Index(['sessionId'])
@Index(['type'])
@Index(['status'])
@Index(['createdAt'])
@Index('idx_legal_document_search', { synchronize: false }) // Full-text search index, created manually via migration/SQL
export class LegalDocument {
  @PrimaryGeneratedColumn('uuid')
  @IDField(() => ID)
  id: string;

  @Column({ type: 'uuid' })
  @FilterableField()
  sessionId: string;

  @ManyToOne(() => UserSession, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'sessionId' })
  session: UserSession;

  @Column({ type: 'varchar', length: 500 })
  @FilterableField()
  title: string;

  @Column({
    type: 'enum',
    enum: DocumentType,
    default: DocumentType.OTHER,
  })
  @FilterableField(() => DocumentType)
  type: DocumentType;

  @Column({
    type: 'enum',
    enum: DocumentStatus,
    default: DocumentStatus.DRAFT,
  })
  @FilterableField(() => DocumentStatus)
  status: DocumentStatus;

  /**
   * Raw content of the document (Markdown or structured text)
   * This field stores the AI-generated content
   */
  @Column({ type: 'text', nullable: true })
  @Field(() => String, { nullable: true })
  contentRaw: string | null;

  /**
   * Metadata containing context variables used during generation
   * Stored as JSON (e.g., defendant name, claim amount)
   */
  @Column({ type: 'jsonb', nullable: true })
  @Field(() => DocumentMetadataType, { nullable: true })
  metadata: DocumentMetadata | null;

  /**
   * URL to download the PDF version of this document
   * This field stores a signed URL that can be used to download the PDF
   * The URL is generated on-demand when the pdfUrl field is requested
   */
  @Column({ type: 'varchar', nullable: true })
  @Field(() => String, {
    nullable: true,
    description: 'Signed URL to download the PDF version of this document',
  })
  pdfUrl: string | null;

  /**
   * Moderation status of the document
   * Documents can be flagged for moderation review
   */
  @Column({
    type: 'enum',
    enum: ModerationStatus,
    nullable: true,
  })
  @FilterableField(() => ModerationStatus, {
    nullable: true,
    description: 'Moderation status of the document',
  })
  moderationStatus: ModerationStatus | null;

  /**
   * Reason for moderation action (approval/rejection)
   * Stores the moderator's explanation
   */
  @Column({ type: 'text', nullable: true })
  @Field(() => String, {
    nullable: true,
    description: 'Reason for moderation decision',
  })
  moderationReason: string | null;

  /**
   * ID of the admin user who moderated this document
   */
  @Column({ type: 'uuid', nullable: true })
  @Field(() => ID, {
    nullable: true,
    description: 'ID of the admin who moderated this document',
  })
  moderatedById: string | null;

  /**
   * Timestamp when document was flagged for moderation
   */
  @Column({ type: 'timestamp', nullable: true })
  @Field(() => GraphQLISODateTime, {
    nullable: true,
    description: 'When the document was flagged for moderation',
  })
  flaggedAt: Date | null;

  /**
   * Timestamp when moderation action was taken
   */
  @Column({ type: 'timestamp', nullable: true })
  @Field(() => GraphQLISODateTime, {
    nullable: true,
    description: 'When the document was moderated',
  })
  moderatedAt: Date | null;

  @CreateDateColumn({ type: 'timestamp' })
  @FilterableField(() => GraphQLISODateTime)
  createdAt: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  @FilterableField(() => GraphQLISODateTime)
  updatedAt: Date;

  /**
   * PostgreSQL tsvector column for full-text search
   * This column is automatically populated via trigger or application code
   * Searchable fields: title, contentRaw, metadata fields
   * Note: This column is not exposed via GraphQL, it's internal for search queries
   */
  @Column({
    type: 'tsvector',
    nullable: true,
    select: false, // Don't select by default as it's internal
  })
  searchVector: string | null;

  /**
   * Lifecycle hook to prepare search content before insert/update
   * The actual tsvector is computed by PostgreSQL via raw query in the service
   */
  @BeforeInsert()
  @BeforeUpdate()
  prepareSearchContent(): void {
    // Search vector will be updated via raw SQL in the service
    // This hook is a placeholder for any pre-processing if needed
  }

  /**
   * Get searchable text content for full-text search indexing
   * Combines all searchable fields into a single text for tsvector creation
   */
  getSearchableContent(): string {
    const parts: string[] = [];

    // Add title with higher weight
    if (this.title) {
      parts.push(this.title);
    }

    // Add content
    if (this.contentRaw) {
      parts.push(this.contentRaw);
    }

    // Add metadata fields
    if (this.metadata) {
      if (this.metadata.plaintiffName) {
        parts.push(this.metadata.plaintiffName);
      }
      if (this.metadata.defendantName) {
        parts.push(this.metadata.defendantName);
      }
    }

    return parts.join(' ');
  }

  /**
   * Check if the document can be marked as completed
   * A document requires content to be completed
   */
  canComplete(): boolean {
    return this.contentRaw !== null && this.contentRaw.trim().length > 0;
  }

  /**
   * Mark the document as completed
   * @throws Error if document has no content
   */
  markCompleted(): void {
    if (!this.canComplete()) {
      throw new Error('Cannot complete document without content');
    }
    this.status = DocumentStatus.COMPLETED;
  }

  /**
   * Mark the document as generating (AI processing in progress)
   */
  markGenerating(): void {
    this.status = DocumentStatus.GENERATING;
  }

  /**
   * Mark the document as failed
   */
  markFailed(): void {
    this.status = DocumentStatus.FAILED;
  }

  /**
   * Check if the document has been successfully generated
   */
  isCompleted(): boolean {
    return this.status === DocumentStatus.COMPLETED;
  }

  /**
   * Check if the document is currently being generated
   */
  isGenerating(): boolean {
    return this.status === DocumentStatus.GENERATING;
  }

  /**
   * Check if the document generation failed
   */
  hasFailed(): boolean {
    return this.status === DocumentStatus.FAILED;
  }

  /**
   * Flag document for moderation review
   */
  flagForModeration(): void {
    this.moderationStatus = ModerationStatus.PENDING;
    this.flaggedAt = new Date();
  }

  /**
   * Approve the document after moderation review
   * @param moderatorId - ID of the admin approving the document
   * @param reason - Optional reason for approval
   */
  approve(moderatorId: string, reason?: string): void {
    this.moderationStatus = ModerationStatus.APPROVED;
    this.moderatedById = moderatorId;
    this.moderatedAt = new Date();
    this.moderationReason = reason ?? null;
  }

  /**
   * Reject the document after moderation review
   * @param moderatorId - ID of the admin rejecting the document
   * @param reason - Reason for rejection (required)
   */
  reject(moderatorId: string, reason: string): void {
    if (!reason || reason.trim().length === 0) {
      throw new Error('Rejection reason is required');
    }
    this.moderationStatus = ModerationStatus.REJECTED;
    this.moderatedById = moderatorId;
    this.moderatedAt = new Date();
    this.moderationReason = reason;
  }

  /**
   * Check if document is pending moderation
   */
  isPendingModeration(): boolean {
    return this.moderationStatus === ModerationStatus.PENDING;
  }

  /**
   * Check if document is approved
   */
  isApproved(): boolean {
    return this.moderationStatus === ModerationStatus.APPROVED;
  }

  /**
   * Check if document is rejected
   */
  isRejected(): boolean {
    return this.moderationStatus === ModerationStatus.REJECTED;
  }

  /**
   * Reset moderation status (allows re-moderation)
   */
  resetModeration(): void {
    this.moderationStatus = null;
    this.moderatedById = null;
    this.moderatedAt = null;
    this.moderationReason = null;
    this.flaggedAt = null;
  }
}
